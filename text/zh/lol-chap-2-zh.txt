第二章闭包
型2.1封闭型编程
得出我们的结论之一是“对象”不需要原始概念编程语言;他们可以构建对象和一个从分配价值多细胞行为和良好的旧lambda表达式。
?人斯蒂尔的设计方案
有时吗?年代称为一个闭包,其他时候救了词汇的环境。或者,就像有些人喜欢说,让/λ。无论您使用的术语,掌握一个闭包的概念是成为一名职业的第一步lisp程序员。事实上,这个技能是至关重要的许多现代编程语言的正确使用,甚至那些不?t显式地包含让或λ,比如Perl或Javascript。
闭包是一个有些好奇的概念是困难的,因为它们很简单。一旦程序员成为用于复杂的解决一个问题,简单的解决同样的问题感到不完整和不舒服。但是,我们很快就会看到,闭包可以更简单、更直接的解决问题的办法,如何组织数据和代码比对象。更重要的是比他们简单、闭包代表
更好的抽象构建宏时使用?这本书的主题。
我们可以构建对象和类与我们关闭原语不?t意味着对象系统是无用的lisp程序员。远非如此。事实上,COMMON LISP的包含一个有史以来最强大的对象系统设计:秘密地,COMMON LISP对象系统。尽管我非常印象深刻的灵活性和功能的秘密地,我很少找到需要使用更高级的功能的,由于分配值细胞和美好λ,表达式。
尽管这本书的假设一个合理的水平的lisp技巧,本章试图教从最基本的理论和使用闭包以及将使用闭包提供一个通用的术语,在这本书的其余部分。本章还考察了闭包效率的影响,认为现代编译器优化。
2.2。环境和范围
斯蒂尔意味着什么分配值细胞是一种存储指针数据环境,环境是所谓的不确定程度。这是奇特的方式,我们可以继续在任何时间指的是这样一个环境中。一旦我们分配这样的环境下,它和它的引用有只要我们需要他们。考虑一下这个C函数:
# include < stdlib.h >
输入int * environment_with_indefinite_extent (int) {int * a = malloc (sizeof (int));* =输入;返回一个;
}
“秘密地Common Lisp的核心,简直就不可能在Common Lisp程序没有它。
当我们调用这个函数和接收返回的指针,我们能继续无限期指的是分配的内存。在C语言中,当调用一个函数创建新的环境,但C程序员知道malloc()返回时所需的内存使用以外的功能。
相反,下面这个例子是有缺陷的。C程序员考虑一个函数返回时自动收集,因为环境是在堆栈上分配。换句话说,根据lisp程序员,分配与暂时的程度。
输入int * environment_with_temporary_extent (int) f {int =输入;返回卡;
}
C环境和lisp环境之间的区别是,除非你明确告诉lisp否则它总是假定您想使用不定程度。换句话说,lisp总是假定您想调用malloc()以上。可以说,这是固有的低效率比使用临时程度,但好处几乎总是超过边际成本性能。什么?年代,lisp通常可以确定当数据可以安全地自动分配在堆栈上,将这样做。您甚至可以使用显式声明告诉lisp这样做。我们将在第七章详细讨论声明,宏观效率的话题。
但由于lisp吗?动态特性,它也?t有明确的指针值或类型像C .这可以迷惑,如果你作为一个C程序员,用于铸造指针和值来表示类型。Lisp思考这一切都略有不同。在lisp,一个方便的口头禅是:
变量不?t类型。只有值类型。
不过,我们不得不返回指针。在lisp中有许多可以存储的数据结构指针。其中最青睐的lisp程序员是一个简单的结构:
缺点电池。每个缺点细胞有两个指针,亲切地称为汽车和cdr。当调用environment-with-indefinite-extent,缺点电池将与汽车返回指向任何作为输入,并通过cdr指向零。,最重要的是,这个缺点细胞(和它的指针输入)不定程度我们可以继续引用它,只要我们所需要的。:
(defun environment-with-indefinite-extent(输入)(输入零缺点))
不定程度的效率不足作为艺术的状态接近的事物在lisp编译技术的改进。环境和程度是密切相关的闭包和更多的在这一章将会对他们说。
2.3。词汇和动态范围
在考虑变量的技术术语引用有效范围。最常见的在现代语言被称为词法作用域范围。当一个代码片段被词法绑定的一个变量,该变量是词法作用域的绑定。让形式,这是最常见的一种方法来创建绑定,可以介绍这些词法作用域变量:
* (let ((x 2)) x)
的x体内让形式是通过词法范围。同样,参数λ定义的函数或defun也词法绑定变量在函数定义的文本。词法变量变量只能访问代码出现的上下文内,例如,
上面的形式。因为词法作用域是一个直观的方法来限制访问一个变量的范围,它可以似乎是唯一的方法。还有其他的可能性范围?
一样有用的组合不确定范围和词法范围是,直到最近没有被用于它最大程度在主流编程语言。第一个实现是史蒂夫·罗素Lisp 1.5 [msrory-or-usP]和随后直接进入语言,像Algol60设计,计划,和CoMMON Lisp。尽管和富有成果的历史很长,词法作用域的众多优势只是慢慢被很多球。
尽管C语言提供的范围方法有限,C程序员也需要程序在不同的环境中。要做到这一点,他们经常使用一个不严密地定义范围称为指针范围。指针范围闻名调试困难,大量的安全风险,有些人为的,它的效率。指针范围背后的想法是定义一个领域特定语言的控制寄存器和内存冯Neumman计算机类似于大多数现代CPUsjrarpix),然后使用该语言来访问和操纵数据结构相当直接的命令来运行程序的CPU。指针范围是必要的体面的lisp编译器发明之前由于性能的原因,但现在被视为一个问题,而不是一个的特点,现代编程语言。
尽管lisp程序员很少考虑指针,指针的理解范围是非常宝贵的建设有效的lisp代码。指针范围在7.4节,我们将调查实现指针范围的罕见情况下,我们需要指示编译器在特定的代码创建。但是现在我们只需要讨论其力学。在C语言中,我们有时会想访问一个变量定义在函数我们写作:
# include < stdio . h >
空白pointer_scope_test () {
int;scanf (“% d”, ka);}
在上面的函数我们使用C &运算符给我们当地的实际内存中的地址变量scanf函数,所以它知道要写的数据扫描。词法作用域在lisp中直接禁止我们的执行。在lisp中,我们可能会通过一个匿名函数假设的lisp scanf函数,允许它集词法变量即使scanf之外定义我们的词法作用域:
(let (a) (scanf "%d" (lambda (v) (setf a v))))
词法作用域是闭包支持功能。事实上,闭包与词法作用域的概念,更具体地说他们通常称为词法闭包来区别于其他类型的闭包。除非另外注明,闭包在这本书里都是词汇。
除了词法作用域,COMMON LISP提供了动态范围。这是临时的结合程度lisp俚语和全球范围。动态范围是一种范围,lisp是独一无二的,因为它提供了一个非常不同的行为但有着相同的语法和词法作用域。在COMMON LISP我们故意选择唤起注意变量访问与动态范围特殊变量通过调用它们。这些特殊的变量可以定义defvar。一些程序员遵循公约与星号加前缀和后缀的特殊变量名称,像* temp-special *。这就是所谓的御寒耳罩公约。原因解释3.7节中,对偶Syntaz,这本书不使用耳罩我们特殊变量声明如下:
(defvar temp-special)
当这样的定义,temp-special将指定特别的东西吗?但不会被初始化值。在这种状态下,一个
?我们也可以显示变量通过使用声明的特殊性使其在本地特殊。
据说是飘散的特殊变量。只有特殊变量可以释放吗?词法变量总是绑定,因此总是有价值。另一种思维方式,默认情况下所有符号代表词汇方面的变量。正如词法变量,我们可以分配一个值与setq或setf特殊变量。有些地,如计划,没有动态范围。其他人,像EuLispsmatu-rieces-p46),使用不同的语法来访问词法和特殊变量。但在COMMON LISP的语法是共享的。许多lispers认为这一特性。在这里,我们我们的特殊变量temp-special赋值:
(setq temp-special 1)
到目前为止,这种特殊的变量不?t似乎特别。似乎只是另一个变量,约束的全局名称空间。这是因为我们只能绑定一次吗?其默认特殊全球绑定。特殊变量是最有趣的绑定时,或跟踪,新环境。如果我们定义一个函数,简单地评估并返回temp-special:
(defun temp-special-returner () temp-special)
这个函数可以用来检查lisp的价值评估temp-special目前在时间当它被称为:
* (temp-special-returner)
1

3因为我们创建一个动态绑定我们不是真正创建一个词汇的环境。它看起来如此。
*(让((temp-special 2)) (temp-special-returner))
注意返回值2,这意味着tempspecial值被从我们让环境,不是其全球特殊价值。如果这似乎仍不有趣,看看这样做不能在其他大多数传统编程语言以这片哭伪代码:
int global_var = 0;
无论()函数{int global_var = 1;do_stuff_that_uses_global_var ();}
函数do_stuff_that_uses_global_var () {/ / global_var 0}
而词汇的内存位置或寄存器分配绑定在编译时是已知的吗?、特殊变量绑定是在运行时确定?在某种意义上。由于有一个巧妙的方法,特殊变量不是吗?像看上去的那么效率低下。一个特殊的变量实际上总是指在内存中相同的位置。当你使用我们来绑定一个特殊的变量,你实际上是在代码编译,存储变量的副本,盖一个新值的内存位置,评估的形式让身体,,最后,恢复原始值的副本。
特殊的变量是永远与符号用来命名它们。位置在内存中被一个特殊的变量称为符号的符号单元。这是直接与词法变量。词法变量是在编译时只显示符号。因为词法变量
4有时候词法作用域被称为“静态作用域”这个原因。
只能从内部访问的词法作用域绑定编译器甚至没有理由记得的符号被用来引用词法变量,所以它将从编译后的代码删除它们。我们将在6.7节延伸这种说法的真实性,Pandoric宏。
尽管COMMON LISP并提供宝贵的特性的动态范围、词法变量是最常见的。动态范围使用lisp,但最本质的特征,从ComMON lisp,几乎完全取代了词法范围。从词法范围使诸如词法闭包(我们很快检查),以及更有效的编译器优化,动态范围的取代主要被视为一件好事。然而,COMMON LISP的设计师给我们留下了非常透明窗口的世界动态范围,现在承认它的本来面目:特别。
2.4让它成为λ
创建一个环境让lisp是一种特殊形式的名字(绑定)初始化结果评估相应的形式。这些名字可以让身体内的代码而连续,对其形式返回最终形式的结果。虽然我们所做的是明确的,它是如何故意离开不明。是什么让它分开。不知怎么的,我们需要提供一个数据结构来存储指针的值。
不可否认缺点细胞用于指针,正如上面我们看到的,但是有许多可以使用的结构。最好的方法之一来存储指针在lisp是让lisp照顾你让形式。让你只需要名字(绑定)这些指针和lisp会为你找出如何存储它们。有时我们帮助编译器能更有效的通过给它额外的信息的形式声明:
(defun register-allocated-fixnum()(声明(优化速度(3)(安全0)))
(让((ace 0))(循环我从1到100 (incf (fixnum acc) (fixnum我)))acc))
例如,在register-allocated-fixnum我们为编译器提供一些提示,让它从1到100的整数之和是非常有效的。在编译时,该函数将分配寄存器中的数据,完全消除需要指针。尽管我们似乎?已经要求lisp创建无限期程度环境来保存acc和我,lisp编译器将能够优化这个函数通过存储的值只在CPU寄存器。结果可能是这台机器代码:
3; O90CEB52: 3109 XOR ECX, ECX 3 54: B804000000 MOV EAX, 4
3 59:EBO5 JMP李
3 5 b: LO: 01 c1添加连成一片,EAX 3 5 d: 830004添加EAX, 4
3 60:李:3 d90010000 CMP EAX, 400 3 65: TEF4 JLE瞧
注意,4代表1和400代表100因为fixnum转移由两位在编译后的代码。这与标签,假装是一个指针,但实际上里面存储数据。我们的lisp编译器吗?年代标签计划好的好处,没有需要进行转向索引词对齐的内存| pesicn-or-cmuct]。我们会更好地了解我们的lisp编译器在第7章,宏观效率的话题。
但如果lisp确定您可能想参考这个环境之后就会少用一些瞬态寄存器。一个通用的结构来存储环境是一个数组的指针。如果每个环境都有一个数组和变量引用封闭的环境只是引用到这个数组,我们有一个高效的环境潜在的不确定程度。
正如上面提到的,我们将返回过去的评价形式的身体。这是常见的许多lisp特殊形式和宏,如此普遍,这种模式通常被称为隐式progn由于progn特殊形式设计有时什么也不做但是这�最有价值的东西让形式返回一个匿名函数,利用提供的词汇环境让形式。创建这些功能我们使用lisp中λ。
λ是一个简单的概念,因为它的灵活性和重要性,则可能让人生畏。λlisp和scheme欠其根·教堂?逻辑系统但已经完全进化,改编成自己的lisp规范。λ是一个简明的方式来重复分配临时名称(绑定)值为一个特定的词汇上下文和lisp背后?一个函数的概念。一个lisp函数非常不同于数学函数描述教堂所想要的。这是因为λ已经演变为一个强大的、实用的工具的一代又一代的lispers,延伸和扩展它更早期的逻辑学家可以预见。
尽管崇敬lisp程序员对λ,本质上没有什么特殊的符号。我们会看到,λ是许多可能的方法之一来表达这种变量命名。特别是,我们将看到宏允许我们定制的重命名变量的方式ef通过不可能在其他编程语言。但是在探索这个问题,我们将回到λ,发现它非常接近最优的符号来表达这类命名。这并非偶然。教堂,过时的和无关紧要的他似乎我们现代编程环境,真正的东西。他的数学符号,随着它的许多增强手中的一代又一代的lisp专业人士,已经演变成一个灵活、通用工具�
λ是如此有用,像许多lisp吗?年代的特性,最
* Progn实际上也用于集群的形式给他们所有顶级的行为。
�宏观的典型例子是让作为λ的实现形式。我不会生你的这本书。
现代语言开始lisp的理念导入到自己的系统。一些语言设计者认为λ太冗长,而不是使用fn或一些其他的缩写。另一方面,一些人认为λ作为一个概念如此基本,模糊一个较小的名字是异端。在这本书中,尽管我们将描述和探索许多变体λ,我们高兴地称它为λ,正如一代又一代的lisp程序员在我们面前。
但是lisp是什么?λ?首先,正如所有的名字在lisp,λ是一个象征。我们可以引用它,把它,并将它存储在列表。λ时只有一个特殊的意义似乎是一个列表的第一个元素。似乎那里时,列表称为一个λ形式或功能指示器。但这种形式不是一个函数。这种形式是一个列表的数据结构,可以使用函数特殊形式转化为一个函数:
*(函数?(λ(x) (+ 1 x)))
# <解释功能>
COMMON LISP给我们提供了一个方便快捷的# ?(sharp-quote)读取宏。而不是写功能如上所述,对于同样的效果我们可以利用这个快捷方式:
* #? (lambda (x) (+ 1 x))
# <解释功能>
作为进一步的便利功能,λ定义成一个宏,展开成一个调用上面的函数的特殊形式。Common Lisp ANSI标准requiresjansi-c1-tsoCOMPATIBILITY] &λ宏定义如下所示:
(defmacroλ普克(完整形式)(声明(忽略身体))? # ?形式)
忽略忽略现在申报吗?。这个宏是一个简单的方法来自动应用功能特殊形式函数指示器。这个宏允许我们评估函数指示器创建功能,因为它们扩展到sharp-quoted形式:
*(λ(x) (x) + 1) # <解释功能>
很少有理由前缀λ表单与# ?多亏了λ宏。因为这本书没有努力支持pre-ANSI CoMMON LISP的环境中,向后兼容性的原因很容易拒绝。但是风格反对呢?保罗•格雷厄姆在ANSI COMMON LISP [cranamAnst-ci],认为这个宏,连同其简洁的好处,一个“似是而非的最多的优雅”。格雷厄姆?年代反对似乎是,因为你仍然需要sharp-quote函数引用的符号,系统似乎是不对称的。然而,我相信不是sharp-quotingλ形式实际上是一个风格的改进,因为它强调了不对称存在于第二个名称空间规范。使用sharp-quote符号指的是第二个名称空间,而功能由λ形式,当然,无名。
甚至没有调用λ宏,我们可以使用lambda形式作为函数调用的第一个参数。就像当一个符号是发现在这个位置和lisp假定我们引用symbol-function细胞的象征,如果找到一个λ形式,它被认为代表一个匿名函数:
* (Clambda (x) (+ 1 x)) 2) 3
但是注意,就像你可以吗?t调用一个函数来动态返回符号用于普通的函数调用,可以? t
7 U-Language声明。
调用一个函数返回一个λ形式在功能位置。对于这两个任务,使用funcall或适用。
lambda表达式的一个好处,主要是外国函数在C和其他语言lisp编译器完全可以经常优化他们的存在。例如,尽管compiler-test看起来一个增量函数适用于2号并返回结果,一个体面的编译器将足够聪明知道这个函数始终返回值3和只会返回这一数字直接调用过程中没有功能。这叫做λ折叠:
(defun compiler-test () (funcall(λ(x) (x) + 1) 2))
效率的一个重要的观察是,编译λ形式是一个常数形式。这意味着您的程序编译后,所有引用该函数只是指向一块机器代码。这个指针可以从函数返回和嵌入在新环境中,所有没有函数创建开销。程序编译时的开销是吸收。换句话说,一个函数,它返回另一个函数只是一个常数时间指针返回功能:
(defun lambda-returner () (lambda (x) (+ 1 x)))
这是直接让形式相比,其目的是在运行时创建一个新的环境,这些操作通常不是一个常数,因为垃圾收集的开销隐含的词法闭包,不确定的程度。
(defun let-over-lambda-returner()(让(y(1))(λ(x) (incf y x))))
每次let-over-lambda-returner调用,必须创建一个新的环境中,嵌入常量指针的代码所代表的λ形成这个新环境,然后返回结果。我们可以用时间来看看这个环境的方法是:多小
* (progn(编译? ? let-over-lambda-returner)(时间(let-over-lambda-returner)))
;评价了:3 24字节缺点。
# <闭包在函数>

上面的使用让封闭一个λ是如此重要,我们将在本章的其余部分讨论的模式和变化。
2.5让λ
让/λ是一个绰号词法闭包。让/λ更紧密地反映了lisp代码用于创建闭包比大多数术语。在让/λ的情况下,最后一个返回的形式让语句是一个lambda表达式。它确实看起来像让坐在上面λ:
* (let ((x 0)) (lambda () x))
# <解释功能>
回想一下,让形式返回的结果评估最后形成其体内,这就是为什么评估这让/λ生产函数形式。然而,有一些特别的最后形式。这是一个λ与x作为自由变量形式。Lisp是足够聪明来确定x这个函数应该参考:x从周围的词法环境创建的形式。因为在lisp中一切都是默认的不确定程度,环境将这个函数可以使用,只要它需要它。
所以词法作用域是一个工具用于指定哪里引用一个变量是有效的,和什么参考引用。闭包的一个简单的例子是一个计数器,一个闭包,它存储一个整数的环境和增量,并返回这个值在每个调用。这是它通常是如何实现,让/λ:
(让((计数器0))(λ()(incf计数器)))
这个闭包将返回1,第一次2随后的时间,等等。思考闭包的一种方法是函数与状态。这些功能并不是数学函数,而是过程,自己的每一点记忆。有时数据结构代码和数据绑定在一起被称为对象。一个对象是一组相关的程序和一些状态。因为对象是如此密切相关的关闭,他们常常被认为是一回事。闭包是一个对象,正好有一个方法:funcall。对象就像一个闭包,您可以以多种方式funcal1。
虽然闭包总是一个函数和它的封闭环境中,多个方法,对象系统的内部类,静态变量都有关闭同行。模拟多个方法的一个可能的方法是简单地返回多个λ在相同的词法作用域:
(让((计数器0))(值(λ()(incf计数器))
(λ()(decf计数器))))
这让/ 2λ模式将返回两个功能,这两个访问相同的封闭计数器变量。第一个增量,第二次衰减。还有许多其他的方式可以做到这一点。dlambda,其中一个是5.7节中所讨论的,dlambda。原因解释当我们沿着,这本书将所有数据结构中的代码使用闭包,而不是对象。提示:这与宏。
2.6λ/ /λ
在某些对象系统之间有明显的区别对象,集合的过程与状态有关,和类,用于创建对象的数据结构。这个区别没有?t存在和闭包。我们看到形式可以评估创建闭包的例子,其中大多数模式后让/λ,但是我们的程序根据需要创建这些对象如何?
答案是非常简单的。如果我们可以评估他们的REPL,我们也可以评估在一个函数。如果我们创建一个函数,它的唯一目的是评估/λ和返回的结果吗?因为我们用λ表示函数,它会看起来像这样:
(λ)(((计数器0))(λ()(incf计数器))))
当λ/我们/λ被调用时,将会创建一个新的包含计数器绑定关闭并返回。记住,lambda表达式是常量:纯粹的机器代码的指针。这个表达式是一个简单的代码,创建新环境,内部lambda表达式(本身就是一个常量,编译形式),正如我们在做REPL。
与对象系统,一块代码创建对象被称为一个类。但λ/我们/λ是略有不同
比许多语言的类。虽然大多数语言需要命名的类,这个模式完全避免命名。λ,/我们/λ表单可以被称为匿名类。
虽然匿名类通常是有用的,我们通常做的类名称。最简单的方法给他们的名字是认识到,这些课程是普通函数。我们通常名字的功能如何?当然,与defun形式。命名后,上述匿名类变成了:
(defun计数器类()(让((计数器0))(λ()(incf计数器))))
第一个λ去了哪里?Defun供应一个隐式λ形式在其身体周围。当你写正则函数defun他们仍然λ形式下但这事实是隐藏在表面之下的defun语法。
不幸的是,大多数lisp编程书不?t提供现实的闭包使用的例子,给读者留下了错误的印象只闭包是适合的玩具例子计数器。没有什么可以进一步从真相。闭包是lisp的基石。环境,在这些环境中定义的功能,和宏defun让使用方便,造型都需要任何问题。这本书旨在阻止lisp程序员使用基于对象的语言开始作用于他们的直觉的系统(比如秘密地。而秘密地确实有某些事情提供专业lisp程序员,不使用它当λ就足够了。
为了激励使用闭包,一个现实的例子提出:block-scanner。block-scanner解决的问题是,对于某些形式的数据传输中的数据交付组(块)的不确定的大小。这些尺寸一般方便应用程序的底层系统而不是程序员,经常被诸如操作系统决定缓冲区,硬盘块,或网络数据包。扫描的数据为一个特定的序列,需要的不仅仅是扫描每一块
清单2.1:BLOCK-SCANNER
(defun block-scanner (trigger-string)(让*((三角(强迫trigger-string ?列表))(咕咕叫三角))
(λ(数据字符串)(((数据(强迫数据字符串?列表)))
(dolist (c数据)
(如果咕咕叫(setq咕咕叫(如果(char =(汽车咕咕叫)c) (cdr咕咕叫);下一个char三角))))}重新开始(不是咕咕叫)))));返回t如果方德斯与常规,无状态的过程。我们需要保持状态之间的每个块的扫描,因为可能我们扫描序列将分成两个(或更多)。
最直接的、自然的方式来实现这个状态存储在现代语言是一个闭包。给出了基于闭包块的初始草图扫描仪block-scanner。像所有lisp开发,创建闭包是一个迭代的过程。我们在block-scanner可能从代码开始,决定提高其效率,避免强迫的字符串列表,或者提高收集的信息通过计算序列出现的次数。
尽管block-scanner最初的实现有待改善,这仍然是一个好的示范使用的λ/ /λ。这是一个演示它的使用,假装某种通信利用特定列入黑名单的话,看了圣战:
* (defvar扫描仪(block-scanner“圣战”))
扫描仪* (funcall扫描仪“我们将开始”)
NIL # (funcall扫描仪“霁”)
零* (funcall扫描仪“明天。”)
T
2.7让λ/ /λ
对象系统的用户他们想要存储值之间共享某个类的所有对象到所谓的类变量或静态变量在lisp�,闭包之间共享状态的概念是由环境一样,闭包本身存储的状态。从一个环境可以无限期地,只要它仍然是可以引用它,我们保证可以只要是必要的。
如果我们想要保持全球所有柜台方向,增加每个闭包?计数器和衰减,然后我们可能想要使用一个λ/我们/λ模式:
(让((?))(defun toggle-counter-direction () (setq方向(如果(eq方向?)>
>)))
(defun计数器类()(让((计数器0))(λ()(如果(eq方向?)
静态甌他词最重载的编程语言之一。类的所有对象共享的变量被称为静态变量在Java之类的语言中,这是远亲C静态的意义之一。
(incf计数器)(decf计数器))))))
在上面的例子中,我们从一节长计数器类。现在调用闭包创建counterclass将增加它的计数器绑定或减量,根据方向的值绑定所有计数器之间共享。请注意,我们还利用另一个λ方向内环境通过创建一个功能叫做toggle-counter-direction所有计数器的当前的方向变化。
虽然这让和λ是如此有用,其他语言采用了这类或静态变量的形式,存在其他的组合让和λ,允许结构代码和国家的方式不?t在对象系统�对象直接模拟系统的一个子集的一种形式化方式让和λ的组合,有时与继承了这样的噱头!�因此,lisp程序员通常不?认为类和对象。让和λ是根本;对象和类衍生品。斯蒂尔说,“对象”不需要编程语言的原始概念。一旦分配值细胞和老式的lambda表达式可用,对象系统,在最好的情况下,偶尔有用的抽象,在最坏的情况下,特殊情况和冗余。
*但是这些类似物有时是建立在对象系统。\ 0宏是无限地比拥有更重要的产业。

