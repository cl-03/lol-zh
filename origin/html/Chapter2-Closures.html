
<!-- saved from url=(0054)https://letoverlambda.com/textmode.cl/guest/chap2.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Let Over Lambda</title>
</head><body>

<center>
<h1>Let Over Lambda -- 50 Years of Lisp</h1>
<h2>by Doug Hoyte</h2>
</center>
<h2>Closures</h2>

<script type="text/javascript">
function toggle_note(n) {
  if (document.getElementById("note_"+n).style.display == "") {
    document.getElementById("note_"+n).style.display = "none";
  } else {
    document.getElementById("note_"+n).style.display = "";
  }
}
</script><h3 id="sec_1">Closure-Oriented Programming</h3>
<p><i>One of the conclusions that we reached was that the "object" need not be a primitive notion in a programming language; one can build objects and their behaviour from little more than assignable value cells and good old lambda expressions.

—Guy Steele on the design of Scheme</i></p><p>Sometimes it's called a <i>closure</i>, other times a saved lexical environment. Or, as some of us like to say, <i>let over lambda</i>. Whatever terminology you use, mastering this concept of a closure is the first step to becoming a professional lisp programmer. In fact, this skill is vital for the proper use of many modern programming languages, even ones that don't explicitly contain let or lambda, such as Perl or Javascript.</p><p>Closures are one of those few curious concepts that are paradoxically difficult because they are so simple. Once a programmer becomes used to a complex solution to a problem, simple solutions to the same problem feel incomplete and uncomfortable. But, as we will soon see, closures can be a simpler, more direct solution to the problem of how to organise data and code than objects. Even more important than their simplicity, closures represent a better abstraction to use when constructing macros—the topic of this book.</p><p>The fact that we can build objects and classes with our closure primitives doesn't mean that object systems are useless to lisp programmers. Far from it. In fact, C<small>OMMON</small> L<small>ISP</small> includes one of the most powerful object systems ever devised: <i>CLOS</i>, the C<small>OMMON</small> L<small>ISP</small> Object System. Although I am very impressed with the flexibility and features of CLOS, I seldom find a need to use its more advanced features<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(1); return false"><sup>1</sup></a><span id="note_1" style="display:none"> <sup><i>CLOS is so central to C<small>OMMON</small> L<small>ISP</small> that it is literally impossible to program in C<small>OMMON</small> L<small>ISP</small> without it.</i></sup> </span>, thanks to assignable value cells and good old lambda expressions.</p><p>While much of this book assumes a reasonable level of lisp skill, this chapter attempts to teach the theory and use of closures from the very basics as well as to provide a common terminology for closures that will be used throughout the rest of this book. This chapter also examines the efficiency implications of closures and considers how well modern compilers optimise them.</p><h3 id="sec_2">Environments and Extent</h3>
<p>What Steele means by assignable value cells is an environment for storing pointers to data where the environment is subject to something called <i>indefinite extent</i>. This is a fancy way of saying that we can continue to refer to such an environment at any time in the future. Once we allocate this environment, it and its references are there to stay as long as we need them. Consider this C function:</p><p></p><pre class="lol_pre">#include &lt;stdlib.h&gt;

int *environment_with_indefinite_extent(int input) {
  int *a = malloc(sizeof(int));
  *a = input;
  return a;
}</pre><p></p><p>After we call this function and receive the pointer it returns, we can continue to refer to the allocated memory indefinitely. In C, new environments are created when invoking a function, but C programmers know to <b>malloc()</b> the required memory when returning it for use outside the function.</p><p>By contrast, the example below is flawed. C programmers consider <b>a</b> to be automatically collected when the function returns because the environment is allocated on the <i>stack</i>. In other words, according to lisp programmers, <b>a</b> is allocated with <i>temporary extent</i>.</p><p></p><pre class="lol_pre">int *environment_with_temporary_extent(int input) {
  int a = input;
  return &amp;a;
}</pre><p></p><p>The difference between C environments and lisp environments is that unless you explicitly tell lisp otherwise it always assumes you mean to use indefinite extent. In other words, lisp always assumes you mean to call <b>malloc()</b> as above. It can be argued that this is inherently less efficient than using temporary extent, but the benefits almost always exceed the marginal performance costs. What's more, lisp can often determine when data can safely be allocated on the stack and will do so automatically. You can even use <i>declarations</i> to tell lisp to do this explicitly. We will discuss declarations in more detail in <a href="https://letoverlambda.com/textmode.cl/guest/chap7.html">chapter 7, Macro Efficiency Topics</a>.</p><p>But because of lisp's dynamic nature, it doesn't have explicit pointer values or types like C. This can be confusing if you, as a C programmer, are used to casting pointers and values to indicate types. Lisp thinks about all this slightly differently. In lisp, a handy mantra is the following:</p><p><i>Variables don't have types. Only values have types.</i></p><p>Still, we have to return something to hold pointers. In lisp there are many data structures that can store pointers. One of the most favoured by lisp programmers is a simple structure: the <i>cons cell</i>. Each cons cell holds exactly two pointers, affectionately called car and cdr. When <b>environment-with-indefinite-extent</b> is invoked, a cons cell will be returned with the car pointing to whatever was passed as <b>input</b> and the cdr pointing to <b>nil</b>. And, most importantly, this cons cell (and with it the pointer to <b>input</b>) has indefinite extent so we can continue to refer to it as long as we need to:</p><p></p><pre class="lol_pre">(defun environment-with-indefinite-extent (input)
  (cons input nil))</pre><p></p><p>The efficiency disadvantages of indefinite extent are approaching irrelevance as the state of the art in lisp compilation technology improves. Environments and extent are closely related to closures and more will be said about them throughout this chapter.</p><h3 id="sec_3">Lexical and Dynamic Scope</h3>
<p>The technical term for where to consider a variable reference valid is <i>scope</i>. The most common type of scope in modern languages is called <i>lexical</i> scope. When a fragment of code is surrounded by the lexical binding of a variable, that variable is said to be in the lexical scope of the binding. The <b>let</b> form, which is one of the most common ways to create bindings, can introduce these lexically scoped variables:</p><p></p><pre class="lol_pre">* (let ((x 2))
    x)

2</pre><p></p><p>The <b>x</b> inside the body of the <b>let</b> form was accessed through lexical scope. Similarly, arguments to functions defined by <b>lambda</b> or <b>defun</b> are also lexically bound variables inside the text of the function definition. Lexical variables are variables that can only be accessed by code appearing inside the context of, for instance, the above <b>let</b> form. Because lexical scoping is such an intuitive way to limit the scope of access to a variable, it can appear to be the only way. Are there any other possibilities for scoping?</p><p>As useful as the combination of indefinite extent and lexical scoping turns out to be, it has until recently not been used to its fullest extent in mainstream programming languages. The first implementation was by Steve Russell for Lisp 1.5<sup><small>[HISTORY-OF-LISP]</small></sup> and was subsequently designed directly into languages like Algol-60, Scheme, and C<small>OMMON</small> L<small>ISP</small>. Despite this long and fruitful history, the numerous advantages of lexical scoping are only slowly being taken up by many Blubs.</p><p>Although the scoping methods provided by C-like languages are limited, C programmers need to program across different environments too. To do so, they often use an imprecisely defined scoping known as <i>pointer scope</i>. Pointer scope is famous for its difficulty to debug, numerous security risks, and, somewhat artificially, its efficiency. The idea behind pointer scoping is to define a domain specific language for controlling the registers and memory of a Von Neumman machine similar to most modern CPUs<sup><small>[PAIP-PIX]</small></sup>, then to use this language to access and manipulate data-structures with fairly direct commands to the CPU running the program. Pointer scoping was necessary for performance reasons before decent lisp compilers were invented but is now regarded as a problem with, rather than a feature of, modern programming languages.</p><p>Even though lisp programmers seldom think in terms of pointers, the understanding of pointer scoping is very valuable in the construction of efficient lisp code. In <a href="https://letoverlambda.com/textmode.cl/guest/chap7.html#sec_4">section 7.4, Pointer Scope</a> we will investigate implementing pointer scoping for the rare cases where we need to instruct the compiler on specific code creation. But for now we only need discuss its mechanics. In C, we sometimes would like to access a variable defined outside the function we are writing:</p><p></p><pre class="lol_pre">#include &lt;stdio.h&gt;

void pointer_scope_test() {
  int a;
  scanf("%d", &amp;a);
}</pre><p></p><p>In the above function we use the C <b>&amp;</b> operator to give the actual address in memory of our local variable <b>a</b> to the <b>scanf</b> function so it knows where to write the data it scans. Lexical scoping in lisp forbids us from implementing this directly. In lisp, we would likely pass an anonymous function to a hypothetical lisp <b>scanf</b> function, allowing it to set our lexical variable <b>a</b> even though <b>scanf</b> is defined outside our lexical scope:</p><p></p><pre class="lol_pre">(let (a)
  (scanf "%d" (lambda (v) (setf a v))))</pre><p></p><p>Lexical scope is the enabling feature for closures. In fact, closures are so related to this concept of lexical scope that they are often referred to more specifically as <i>lexical closures</i> to distinguish them from other types of closures. Unless otherwise noted, all closures in this book are lexical.</p><p>In addition to lexical scope, C<small>OMMON</small> L<small>ISP</small> provides <i>dynamic scope</i>. This is lisp <i>slang</i> for the combination of temporary extent and global scope. Dynamic scoping is a type of scoping that is unique to lisp in that it offers a very different behaviour but shares an identical syntax with lexical scope. In C<small>OMMON</small> L<small>ISP</small> we deliberately choose to call attention to variables accessed with dynamic scope by calling them <i>special variables</i>. These special variables can be defined with <b>defvar</b>. Some programmers follow a convention of prefixing and postfixing special variable names with asterisks, like <b>*temp-special*</b>. This is called the <i>earmuff</i> convention. For reasons explained in <a href="https://letoverlambda.com/textmode.cl/guest/chap3.html#sec_7">section 3.7, Duality of Syntax</a>, this book does not use earmuffs so our special variable declarations look like this:</p><p></p><pre class="lol_pre">(defvar temp-special)</pre><p></p><p>When defined like this, <b>temp-special</b> will be designated special<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(2); return false"><sup>2</sup></a><span id="note_2" style="display:none"> <sup><i>We can also indicate the specialness of variables by using declarations to make them locally special.</i></sup> </span> but will not be initialised with a value. In this state, a special variable is said to be <i>unbound</i>. Only special variables can be unbound—lexical variables are always bound and thus always have values. Another way of thinking of this is that by default all symbols represent lexically unbound variables. Just as with lexical variables, we can assign a value to special variables with <b>setq</b> or <b>setf</b>. Some lisps, like Scheme, do not have dynamic scope. Others, like EuLisp<sup><small>[SMALL-PIECES-P46]</small></sup>, use different syntax for accessing lexical versus special variables. But in C<small>OMMON</small> L<small>ISP</small> the syntax is shared. Many lispers consider this a feature. Here we assign a value to our special variable <b>temp-special</b>:</p><p></p><pre class="lol_pre">(setq temp-special 1)</pre><p></p><p>So far, this special variable doesn't seem that special. It seems to be just another variable, bound in some sort of global namespace. This is because we have only bound it once—its default special global binding. Special variables are most interesting when they are re-bound, or <i>shadowed</i>, by new environments. If we define a function that simply evaluates and returns <b>temp-special</b>:</p><p></p><pre class="lol_pre">(defun temp-special-returner ()
  temp-special)</pre><p></p><p>This function can be used to examine the value that lisp evaluates <b>temp-special</b> to be at the moment in time when it was called:</p><p></p><pre class="lol_pre">* (temp-special-returner)

1</pre><p></p><p>This is sometimes referred to as evaluating the form in a <i>null lexical environment</i>. The null lexical environment obviously doesn't contain any lexical bindings. Here the value of <b>temp-special</b> returned is that of its global special value, 1. But if we evaluate it in a non-null lexical environment—one that contains a binding for our special variable—the specialness of <b>temp-special</b> reveals itself<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(3); return false"><sup>3</sup></a><span id="note_3" style="display:none"> <sup><i>Because we create a dynamic binding we are not actually creating a lexical environment. It just looks that way.</i></sup> </span>:</p><p></p><pre class="lol_pre">* (let ((temp-special 2))
    (temp-special-returner))

2</pre><p></p><p>Notice that the value 2 was returned, meaning that the <b>temp-special</b> value was taken from our <b>let</b> environment, not its global special value. If this still does not seem interesting, see how this cannot be done in most other conventional programming languages as exemplified by this piece of Blub pseudo-code:</p><p></p><pre class="lol_pre">int global_var = 0;

function whatever() {
  int global_var = 1;
  do_stuff_that_uses_global_var();
}

function do_stuff_that_uses_global_var() {
  // global_var is 0
}</pre><p></p><p>While the memory locations or register assignments for lexical bindings are known at compile-time<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(4); return false"><sup>4</sup></a><span id="note_4" style="display:none"> <sup><i>Sometimes lexical scoping is called "static scoping" for this reason.</i></sup> </span>, special variable bindings are determined at run-time—in a sense. Thanks to a clever trick, special variables aren't as inefficient as they seem. A special variable actually always does refer to the same location in memory. When you use <b>let</b> to bind a special variable, you are actually compiling in code that will store a copy of the variable, over-write the memory location with a new value, evaluate the forms in the let body, and, finally, restore the original value from the copy.</p><p>Special variables are perpetually associated with the symbol used to name them. The location in memory referred to by a special variable is called the <b>symbol-value</b> cell of a symbol. This is in direct contrast to lexical variables. Lexical variables are only indicated with symbols at compile-time. Because lexical variables can only be accessed from inside the lexical scope of their bindings, the compiler has no reason to even remember the symbols that were used to reference lexical variables so it will remove them from compiled code. We will stretch the truth of this statement in <a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#sec_7">section 6.7, Pandoric Macros</a>.</p><p>Although C<small>OMMON</small> L<small>ISP</small> does offer the invaluable feature of dynamic scope, lexical variables are the most common. Dynamic scoping used to be a defining feature of lisp but has, since C<small>OMMON</small> L<small>ISP</small>, been almost completely replaced by lexical scope. Since lexical scoping enables things like lexical closures (which we examine shortly), as well as more effective compiler optimisations, the superseding of dynamic scope is mostly seen as a good thing. However, the designers of C<small>OMMON</small> L<small>ISP</small> have left us a very transparent window into the world of dynamic scoping, now acknowledged for what it really is: special.</p><h3 id="sec_4">Let It Be Lambda</h3>
<p><b>Let</b> is a lisp special form for creating an environment with names (bindings) initialised to the results of evaluating corresponding forms. These names are available to the code inside the <b>let</b> body while its forms are evaluated consecutively, returning the result of the final form. Although what <b>let</b> does is unambiguous, how it does it is deliberately left unspecified. What <b>let</b> does is separated from how it does it. Somehow, <b>let</b> needs to provide a data structure for storing pointers to values.</p><p>Cons cells are undeniably useful for holding pointers, as we saw above, but there are numerous structures that can be used. One of the best ways to store pointers in lisp is to let lisp take care of it for you with the <b>let</b> form. With <b>let</b> you only have to name (bind) these pointers and lisp will figure out how best to store them for you. Sometimes we can help the compiler make this more efficient by giving it extra bits of information in the form of declarations:</p><p></p><pre class="lol_pre">(defun register-allocated-fixnum ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((acc 0))
    (loop for i from 1 to 100 do
      (incf (the fixnum acc)
            (the fixnum i)))
    acc))</pre><p></p><p>For example, in <b>register-allocated-fixnum</b> we provide some hints to the compiler that allow it to sum the integers from 1 to 100 very efficiently. When compiled, this function will allocate the data in registers, eliminating the need for pointers altogether. Even though it seems we've asked lisp to create an indefinite extent environment to hold <b>acc</b> and <b>i</b>, a lisp compiler will be able to optimise this function by storing the values solely in CPU registers. The result might be this machine code:</p><p></p><pre class="lol_pre">; 090CEB52:       31C9             XOR ECX, ECX
;       54:       B804000000       MOV EAX, 4
;       59:       EB05             JMP L1
;       5B: L0:   01C1             ADD ECX, EAX
;       5D:       83C004           ADD EAX, 4
;       60: L1:   3D90010000       CMP EAX, 400
;       65:       7EF4             JLE L0</pre><p></p><p>Notice that 4 represents 1 and 400 represents 100 because fixnums are shifted by two bits in compiled code. This has to do with <i>tagging</i>, a way to pretend that something is a pointer but actually store data inside it. Our lisp compiler's tagging scheme has the nice benefit that no shifting needs to occur to index word aligned memory<sup><small>[DESIGN-OF-CMUCL]</small></sup>. We'll get to know our lisp compiler better in <a href="https://letoverlambda.com/textmode.cl/guest/chap7.html">chapter 7, Macro Efficiency Topics</a>.</p><p>But if lisp determines that you might want to refer to this environment later on it will have to use something less transient than a register. A common structure for storing pointers in environments is an array. If each environment has an array and all the variable references enclosed in that environment are just references into this array, we have an efficient environment with potentially indefinite extent.</p><p>As mentioned above, <b>let</b> will return the evaluation of the last form in its body. This is common for many lisp special forms and macros, so common that this pattern is often referred to as an <i>implicit progn</i> due to the <b>progn</b> special form designed to do nothing but this<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(5); return false"><sup>5</sup></a><span id="note_5" style="display:none"> <sup><i><b>Progn</b> is actually also useful for clustering forms to give them all top-level behaviour.</i></sup> </span>. Sometimes the most valuable thing to have a let form return is an anonymous function which takes advantage of the lexical environment supplied by the let form. To create these functions in lisp we use <i>lambda</i>.</p><p><i>Lambda</i> is a simple concept that can be intimidating because of its flexibility and importance. The lambda from lisp and scheme owes its roots to Alonzo Church's logic system but has evolved and adapted into its altogether own lisp specification. Lambda is a concise way to repeatably assign temporary names (bindings) to values for a specific lexical context and underlies lisp's concept of a function. A lisp function is very different from the mathematical function description that Church had in mind. This is because lambda has evolved as a powerful, practical tool at the hands of generations of lispers, stretching and extending it much further than early logicians could have foreseen.</p><p>Despite the reverence lisp programmers have for lambda, there is nothing inherently special about the notation. As we will see, lambda is just one of many possible ways to express this sort of variable naming. In particular, we will see that macros allow us to customise the renaming of variables in ways that are effectively impossible in other programming languages. But after exploring this, we will return to lambda and discover that it is very close to the optimal notation for expressing such naming. This is no accident. Church, as dated and irrelevant as he might seem to our modern programming environment, really was on to something. His mathematical notation, along with its numerous enhancements in the hands of generations of lisp professionals, has evolved into a flexible, general tool<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(6); return false"><sup>6</sup></a><span id="note_6" style="display:none"> <sup><i>The classic example of a macro is an implementation of <b>let</b> as a lambda form. I will not bore you with that in this book.</i></sup> </span>.</p><p>Lambda is so useful that, like many of lisp's features, most modern languages are beginning to import the idea from lisp into their own systems. Some language designers feel that lambda is too lengthy, instead using <b>fn</b> or some other abbreviation. On the other hand, some regard lambda as a concept so fundamental that obscuring it with a lesser name is next to heresy. In this book, although we will describe and explore many variations on lambda, we happily call it lambda, just as generations of lisp programmers before us.</p><p>But what is lisp's lambda? First off, as with all names in lisp, lambda is a <i>symbol</i>. We can quote it, compare it, and store it in lists. Lambda only has a special meaning when it appears as the first element of a list. When it appears there, the list is referred to as a <i>lambda form</i> or as a <i>function designator</i>. But this form is not a function. This form is a list data structure that can be converted into a function using the <b>function</b> special form:</p><p></p><pre class="lol_pre">* (function '(lambda (x) (+ 1 x)))

#&lt;Interpreted Function&gt;</pre><p></p><p>C<small>OMMON</small> L<small>ISP</small> provides us a convenience shortcut for this with the #' (sharp-quote) read macro. Instead of writing <b>function</b> as above, for the same effect we can take advantage of this shortcut:</p><p></p><pre class="lol_pre">* #'(lambda (x) (+ 1 x))

#&lt;Interpreted Function&gt;</pre><p></p><p>As a further convenience feature, lambda is also defined as a macro that expands into a call to the function special form above. The C<small>OMMON</small> L<small>ISP</small> ANSI standard requires<sup><small>[ANSI-CL-ISO-COMPATIBILITY]</small></sup> a <b>lambda</b> macro defined like so:</p><p></p><pre class="lol_pre">(defmacro lambda (&amp;whole form &amp;rest body)
  (declare (ignore body))
  `#',form)</pre><p></p><p>Ignore the ignore declaration for now<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(7); return false"><sup>7</sup></a><span id="note_7" style="display:none"> <sup><i>A U-Language declaration.</i></sup> </span>. This macro is just a simple way to automatically apply the <b>function</b> special form to your function designators. This macro allows us to evaluate function designators to create functions because they are expanded into sharp-quoted forms:</p><p></p><pre class="lol_pre">* (lambda (x) (+ 1 x))

#&lt;Interpreted Function&gt;</pre><p></p><p>There are few good reasons to prefix your lambda forms with #' thanks to the <b>lambda</b> macro. Because this book makes no effort to support pre-ANSI C<small>OMMON</small> L<small>ISP</small> environments, backwards compatibility reasons are easily rejected. But what about stylistic objections? Paul Graham, in <i>ANSI C<small>OMMON</small> L<small>ISP</small></i><sup><small>[GRAHAM-ANSI-CL]</small></sup>, considers this macro, along with its brevity benefits, a "specious sort of elegance at best". Graham's objection seems to be that since you still need to sharp-quote functions referenced by symbols, the system seems asymmetric. However, I believe that not sharp-quoting lambda forms is actually a stylistic improvement because it highlights the asymmetry that exists in the second namespace specification. Using sharp-quote for symbols is for referring to the second namespace, whereas functions created by lambda forms are, of course, nameless.</p><p>Without even invoking the <b>lambda</b> macro, we can use lambda forms as the first argument in a function call. Just like when a symbol is found in this position and lisp assumes we are referencing the <b>symbol-function</b> cell of the symbol, if a lambda form is found, it is assumed to represent an anonymous function:</p><p></p><pre class="lol_pre">* ((lambda (x) (+ 1 x)) 2)

3</pre><p></p><p>But note that just as you can't call a function to dynamically return the symbol to be used in a regular function call, you can't call a function to return a lambda form in the function position. For both of these tasks, use either <b>funcall</b> or <b>apply</b>.</p><p>A benefit of lambda expressions that is largely foreign to functions in C and other languages is that lisp compilers can often optimise them out of existence completely. For example, although <b>compiler-test</b> looks like it applies an increment function to the number 2 and returns the result, a decent compiler will be smart enough to know that this function always returns the value 3 and will simply return that number directly, invoking no functions in the process. This is called <i>lambda folding</i>:</p><p></p><pre class="lol_pre">(defun compiler-test ()
  (funcall
    (lambda (x) (+ 1 x))
    2))</pre><p></p><p>An important efficiency observation is that a compiled lambda form is a constant form. This means that after your program is compiled, all references to that function are simply pointers to a chunk of machine code. This pointer can be returned from functions and embedded in new environments, all with no function creation overhead. The overhead was absorbed when the program was compiled. In other words, a function that returns another function will simply be a constant time pointer return function:</p><p></p><pre class="lol_pre">(defun lambda-returner ()
  (lambda (x) (+ 1 x)))</pre><p></p><p>This is in direct contrast to the <b>let</b> form, which is designed to create a new environment at run-time and as such is usually not a constant operation because of the garbage collection overhead implied by lexical closures, which are of indefinite extent.</p><p></p><pre class="lol_pre">(defun let-over-lambda-returner ()
  (let ((y 1))
    (lambda (x)
      (incf y x))))</pre><p></p><p>Every time <b>let-over-lambda-returner</b> is invoked, it must create a new environment, embed the constant pointer to the code represented by the lambda form into this new environment, then return the resulting <i>closure</i>. We can use <b>time</b> to see just how small this environment is:</p><p></p><pre class="lol_pre">* (progn
    (compile 'let-over-lambda-returner)
    (time (let-over-lambda-returner)))

; Evaluation took:
;   ...
;   24 bytes consed.
;
#&lt;Closure Over Function&gt;</pre><p></p><p>If you try to call compile on a closure, you will get an error saying you can't compile functions defined in non-null lexical environments<sup><small>[CLTL2-P677]</small></sup>. You can't compile closures, only the functions that create closures. When you compile a function that creates closures, the closures it creates will also be compiled<sup><small>[ON-LISP-P25]</small></sup>.</p><p>The use of a let enclosing a lambda above is so important that we will spend the remainder of this chapter discussing the pattern and variations on it.</p><h3 id="sec_5">Let Over Lambda</h3>
<p><i>Let over lambda</i> is a nickname given to a lexical closure. Let over lambda more closely mirrors the lisp code used to create closures than does most terminology. In a let over lambda scenario, the last form returned by a <b>let</b> statement is a <b>lambda</b> expression. It literally looks like <b>let</b> is sitting on top of <b>lambda</b>:</p><p></p><pre class="lol_pre">* (let ((x 0))
    (lambda () x))

#&lt;Interpreted Function&gt;</pre><p></p><p>Recall that the <b>let</b> form returns the result of evaluating the last form inside its body, which is why evaluating this let over lambda form produced a function. However, there is something special about the last form in the <b>let</b>. It is a <b>lambda</b> form with <b>x</b> as a <i>free variable</i>. Lisp was smart enough to determine what <b>x</b> should refer to for this function: the <b>x</b> from the surrounding lexical environment created by the <b>let</b> form. And, because in lisp everything is of indefinite extent by default, the environment will be available for this function to use as long as it needs it.</p><p>So lexical scope is a tool for specifying exactly where references to a variable are valid, and exactly what the references refer to. A simple example of a closure is a <i>counter</i>, a closure that stores an integer in an environment and increments and returns this value upon every invocation. Here is how it is typically implemented, with a let over lambda:</p><p></p><pre class="lol_pre">(let ((counter 0))
  (lambda () (incf counter)))</pre><p></p><p>This closure will return 1 the first time it is called, 2 the subsequent time, and so on. One way of thinking about closures is that they are functions with <i>state</i>. These functions are not mathematical functions, but rather procedures, each with a little memory of its own. Sometimes data structures that bundle together code and data are called <i>objects</i>. An object is a collection of procedures and some associated state. Since objects are so closely related to closures, they can often be thought of as one and the same. A closure is like an object that has exactly one method: <b>funcall</b>. An object is like a closure that you can <b>funcall</b> in multiple ways.</p><p>Although closures are always a single function and its enclosing environment, the multiple methods, inner classes, and static variables of object systems all have their closure counterparts. One possible way to simulate multiple methods is to simply return multiple <b>lambda</b>s from inside the same lexical scope:</p><p></p><pre class="lol_pre">(let ((counter 0))
  (values
    (lambda () (incf counter))
    (lambda () (decf counter))))</pre><p></p><p>This <i>let over two lambdas</i> pattern will return two functions, both of which access the same enclosing counter variable. The first increments it and the second decrements it. There are many other ways to accomplish this. One of which, <b>dlambda</b>, is discussed in <a href="https://letoverlambda.com/textmode.cl/guest/chap5.html#sec_7">section 5.7, Dlambda</a>. For reasons that will be explained as we go along, the code in this book will structure all data using closures instead of objects. Hint: It has to do with macros.</p><h3 id="sec_6">Lambda Over Let Over Lambda</h3>
<p>In some object systems there is a sharp distinction between objects, collections of procedures with associated state, and classes, the data structures used to create objects. This distinction doesn't exist with closures. We saw examples of forms you can evaluate to create closures, most of them following the pattern let over lambda, but how can our program create these objects as needed?</p><p>The answer is profoundly simple. If we can evaluate them in the REPL, we can evaluate them inside a function too. What if we create a function whose sole purpose is to evaluate a let over lambda and return the result? Because we use <b>lambda</b> to represent functions, it would look something like this:</p><p></p><pre class="lol_pre">(lambda ()
  (let ((counter 0))
    (lambda () (incf counter))))</pre><p></p><p>When the <i>lambda over let over lambda</i> is invoked, a new closure containing a counter binding will be created and returned. Remember that <b>lambda</b> expressions are constants: mere pointers to machine code. This expression is a simple bit of code that creates new environments to close over the inner <b>lambda</b> expression (which is itself a constant, compiled form), just as we were doing at the REPL.</p><p>With object systems, a piece of code that creates objects is called a class. But lambda over let over lambda is subtly different than the classes of many languages. While most languages require classes to be named, this pattern avoids naming altogether. Lambda over let over lambda forms can be called <i>anonymous classes</i>.</p><p>Although anonymous classes are often useful, we usually do name classes. The easiest way to give them names is to recognise that such classes are regular functions. How do we normally name functions? With the <b>defun</b> form, of course. After naming, the above anonymous class becomes:</p><p></p><pre class="lol_pre">(defun counter-class ()
  (let ((counter 0))
    (lambda () (incf counter))))</pre><p></p><p>Where did the first <b>lambda</b> go? <b>Defun</b> supplies an <i>implicit lambda</i> around the forms in its body. When you write regular functions with <b>defun</b> they are still lambda forms underneath but this fact is hidden beneath the surface of the <b>defun</b> syntax.</p><p>Unfortunately, most lisp programming books don't provide realistic examples of closure usage, leaving readers with the inaccurate impression that closures are only good for toy examples like counters. Nothing could be further from the truth. Closures are the building blocks of lisp. Environments, the functions defined inside those environments, and macros like <b>defun</b> that make using them convenient, are all that are needed for modelling any problem. This book aims to stop beginning lisp programmers used to object-based languages from acting upon their gut instinct of reaching for systems like CLOS. While CLOS does have certain things to offer the professional lisp programmer, do not use it when a lambda will suffice.</p><p></p><fieldset><legend>BLOCK-SCANNER</legend><pre class="lol_code">(defun block-scanner (trigger-string)
  (let* ((trig (coerce trigger-string 'list))
         (curr trig))
    (lambda (data-string)
      (let ((data (coerce data-string 'list)))
        (dolist (c data)
          (if curr
            (setq curr
                  (if (char= (car curr) c)
                    (cdr curr) ; next char
                    trig))))   ; start over 
        (not curr))))) ; return t if found</pre></fieldset><p></p><p>In order to motivate the use of closures, a realistic example is presented: <b>block-scanner</b>. The problem <b>block-scanner</b> solves is that for some forms of data transfer the data is delivered in groups (blocks) of uncertain sizes. These sizes are generally convenient for the underlying system but not for the application programmer, often being determined by things like operating system buffers, hard drive blocks, or network packets. Scanning a stream of data for a specific sequence requires more than just scanning each block as it comes in with a regular, stateless procedure. We need to keep state between the scanning of each block because it is possible that the sequence we are scanning for will be split between two (or more) blocks.</p><p>The most straightforward, natural way to implement this stored state in modern languages is with a closure. An initial sketch of a closure-based block scanner is given as <b>block-scanner</b>. Like all lisp development, creating closures is an iterative process. We might start off with code given in <b>block-scanner</b> and decide to improve its efficiency by avoiding coercion of strings to lists, or possibly improve the information gathered by counting the number of occurrences of the sequence.</p><p>Although <b>block-scanner</b> is an initial implementation waiting to be improved, it is still a good demonstration of the use of lambda over let over lambda. Here is a demonstration of its use, pretending to be some sort of communications tap watching out for a specific black-listed word, <i>jihad</i>:</p><p></p><pre class="lol_pre">* (defvar scanner
    (block-scanner "jihad"))

SCANNER
* (funcall scanner "We will start ")

NIL
# (funcall scanner "the ji")

NIL
* (funcall scanner "had tomorrow.")

T</pre><p></p><h3 id="sec_7">Let Over Lambda Over Let Over Lambda</h3>
<p>Users of object systems store values they want shared between all objects of a certain class into so-called <i>class variables</i> or <i>static variables</i><a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(8); return false"><sup>8</sup></a><span id="note_8" style="display:none"> <sup><i>The term static is one of the most overloaded programming language terms. Variables shared by all objects of a class are called static variables in languages like Java, which is distantly related to one of the meanings of static in C.</i></sup> </span>. In lisp, this concept of sharing state between closures is handled by environments in the same way that closures themselves store state. Since an environment is accessible indefinitely, as long as it is still possible to reference it, we are guaranteed that it will be available as long as is needed.</p><p>If we want to maintain a global direction for all counters, <b>up</b> to increment each closure's counter and <b>down</b> to decrement, then we might want to use a let over lambda over let over lambda pattern:</p><p></p><pre class="lol_pre">(let ((direction 'up))
  (defun toggle-counter-direction ()
    (setq direction
          (if (eq direction 'up)
            'down
            'up)))

  (defun counter-class ()
    (let ((counter 0))
      (lambda ()
        (if (eq direction 'up)
          (incf counter)
          (decf counter))))))</pre><p></p><p>In the above example, we have extended <b>counter-class</b> from the previous section. Now calling closures created with <b>counter-class</b> will either increment its counter binding or decrement it, depending on the value of the direction binding which is shared between all counters. Notice that we also take advantage of another <b>lambda</b> inside the direction environment by creating a function called <b>toggle-counter-direction</b> which changes the current direction for all counters.</p><p>While this combination of <b>let</b> and <b>lambda</b> is so useful that other languages have adopted it in the form of class or static variables, there exist other combinations of <b>let</b> and <b>lambda</b> that allow you to structure code and state in ways that don't have direct analogs in object systems<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(9); return false"><sup>9</sup></a><span id="note_9" style="display:none"> <sup><i>But these analogs can sometimes be built on top of object systems.</i></sup> </span>. Object systems are a formalisation of a subset of let and lambda combinations, sometimes with gimmicks like <i>inheritance</i> bolted on<a href="https://letoverlambda.com/textmode.cl/guest/chap2.html#" onclick="toggle_note(10); return false"><sup>10</sup></a><span id="note_10" style="display:none"> <sup><i>Having macros is immeasurably more important than having inheritance.</i></sup> </span>. Because of this, lisp programmers often don't think in terms of classes and objects. Let and lambda are fundamental; objects and classes are derivatives. As Steele says, the "object" need not be a primitive notion in programming languages. Once assignable value cells and good old lambda expressions are available, object systems are, at best, occasionally useful abstractions and, at worst, special-case and redundant.</p><center><p>All material is (C) Doug Hoyte unless otherwise noted or implied. All rights reserved.</p></center>

</body></html>