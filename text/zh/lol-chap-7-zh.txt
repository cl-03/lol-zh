第七章宏观效率的话题
7.1 Lisp是快
如果你用瓷砖瓷砖地板缩略图的大小,你呢?浪费很多。
?Paul Graham
有些人认为lisp是缓慢的。虽然这可能是对一些早期的lisp语言实现,多年很明显是假的。事实上,现代地像COMMON LISP设计让我们利用宏LISP快。非常快。本章的目标可能会让你大吃一惊哦如果你相信性能神话说低级比lisp语言更有效。本章旨在说明lisp可以比任何其他编程语言和低级编程语言C实际上是吗?因为他们缺乏宏?在lisp的性能不利。Lisp允许我们写的代码更有效率比我们将不得不编写的代码在任何其他语言。特别是对于大型和复杂的程序,宏允许创建代码与明确的性能优势在哭的语言。有时候我们的语言设计,高效的实现,但更多的则是为了为程序员提供最大限度的表达能力。当我们做选择的效率,lisp是快。非常快。
而其他语言给你小广场砖,lisp允许您选择的任何大小和形状的瓷砖。与C程序员总是使用一种语言,是直接绑定到一个花哨的fixnum加法器的功能。除了程序和结构,抽象是可能相比之下,在c . lisp并不是围绕机器的能力和局限性。
但是其他语言可以用低效率,更方便的方式。毕竟,Perl程序员可以创造奇迹,一个密集的表达式也提供了许多升级更快的代码路径。所以这是什么意思,当我们说lisp允许我们控制我们的抽象的效率没有其他语言?现在,你可能期待的答案涉及我们的书的主题:宏。
而不是询问是什么使一个程序快,吗?年代好问是什么让一个程序慢。这是编程中最研究主题之一。根本原因大致可以分为三大类:坏算法,糟糕的数据结构,和通用代码。
所有语言的实现需要良好的算法。一个算法是一个大概的研究过程的描述如何执行编程任务。因为投资需要提出一个算法比实现一个更大的,算法的使用在所有的计算机科学无处不在。有人已经找到了如何以及为什么,以及如何快速算法;使用一种算法你所要做的是将其伪代码转化为您的系统能够理解的东西。因为COMMON LISP的实现通常由聪明人,不断改进实现几十年来,他们通常使用一些最好的和最快的算法最常见的任务。例如,CMUCL使用一种调整堆实现排序列表和向量和梅森素数的旋风19937算法及其大得离谱的时期!用于生成随机数?。
T(1 -(19937)出口食品2)? MT19937序列是由一个线性递归,本身不适合加密。
良好的数据结构也需要什么像样的编程语言。数据结构是如此重要,以至于忽视他们将导致任何语言实现缓慢爬行。优化数据结构本质上可以归结为一个概念叫做位置。解释这个概念是很容易的吗?访问最频繁的数据应该是最快的访问。数据结构和位置非常重要,他们可以清楚的观察到在几乎每一个级别的计算性能要求:大套的CPU寄存器,内存缓存,数据库和缓存网络代理有一些亮点。Lisp提供了一组巨大的标准数据结构和实现它们通常很好。哈希表,链表(显然),向量指针为填补,包与internable符号,和更多的指定,COMMON LISP程序员利用实现的。
如果lisp提供了这样好的算法和数据结构,怎么可能,lisp代码可以低于代码在其他语言?解释是基于lisp的最重要的设计决策:通用代码,否则我们熟悉的概念作为syntaz的二元性。当我们写lisp代码,使用尽可能多的二元性。语言的结构鼓励我们。的部分原因lisp程序通常比哭更短程序是因为任何给定的一段lisp代码可用于多可以一块相应的经常哭代码可以重用它。来自哭语言的角度来看会觉得罕见编写更少,但这是重要的lisp设计决定我们一直在说什么?二元性的语法。二元性附加到每个表达式越多,越短程序似乎。那么这是否意味着达到或超过C ?年代的性能,我们需要让我们的lisp程序和相应的C程序一样长,危险吗?不。Lisp宏。
7.2宏Lisp快
本节展示的例子使用三种类型的宏来帮助创建有效的程序:定期宏,读和宏
这里介绍一种新型的宏:编译器宏。
宏可以用来控制算法,数据结构,类型检查,安全检查,优化级别的代码或部分代码,等等。我们可以安全的和通用的代码在同一个程序共存?甚至函数?和危险的代码一样快。简而言之,没有其他语言提供了一个开放的接口控制编译器的lisp,和它吗?感谢所有(还有什么?)宏。粗略地阅读的ANSI标准似乎表明,宏和声明,编译器最直接的交流方式,唐?t一起工作得很好:
宏观形式不能扩展到声明;声明表达式必须出现的实际的子表达式的形式引用。
ANSI意味着以下宏观不会像期望的工作:
(defmacro快跑();坏了!*(声明(优化速度(3)(安全0))))
我们可以吗?t把宏调用的地方声明预计。另一种思考这个系统吗?年代code-walker不需要扩大宏特殊形式的身体检查之前声明。想去快是一个常见的声明,所以也许我们可以做得更好比上面的有缺陷的快跑宏。当我们想要尽可能压缩的意思,通常我们要读宏。宏也适合扩大解读声明,因为他们是扩大之前code-walker试图走代码。他们在实际的子表达式。
Sharp-f是读宏,可以用来控制最重要的性能权衡可用COMMON LISP程序:之间的平衡的速度和安全声明。例如,sharp-f本身读取在我们希望快点进入:
清单7.1:SHARP-F
(set-dispatch-macro-character # \ # # \ f(λ(流sub-char numarg)(声明(忽略流sub-char)) (setq numarg(或numarg 3))(除非(< = numarg 3)(错误“坏值# f: ~“numarg)) ?(声明(优化(速度、numarg)(安全、(- 3 numarg))))))
*高频(声明(优化速度(3)(安全0)))
然而,我们可以改变这一切,宣布我们价值以上安全速度通过提供一个数量小于3作为读者数量的参数。所有分派读宏可以接受这样的数值参数。它是作为第三个参数传递,通常被称为numarg,读取宏函数。下面是一个例子,我们值的安全速度提供0:
* ? #(声明(优化速度(0)(安全3)))
1和2的值也可以通过导致以下声明。这些不同的声明设置的优点是非常取决于编译器,所以你几乎从来没有使用它们:
* ? (# 1 # 2 f)
((声明(优化速度(1)(2)安全))(声明(优化速度(2)(安全1))))
尽管宏可以吗?t直接扩展到声明,我们仍然可以使用正则宏控制声明。因为code-walker可以吗?t走宏观形式搜索声明
清单7.2:FAST-PROGN
(defmacro fast-progn(休息身体)?(本地# f, Q@body))
清单7.3:SAFE-PROGN
(defmacro safe-progn(休息身体)?(本地# 0 f, @body))
直到它扩大了宏观,没有办法,它可以告诉如果这个宣言是一个实际的子表达式的形式你写或如果宏添加声明时扩大。
Fast-progn和safe-progn简单的宏的例子,扩展到包含声明形式。请注意,我们使用本地?年代隐progn代替progn本身因为progn呢?t接受声明吗?。这两个宏使用sharp-f读宏定义。我们可以使用这些形式的版本progn的封闭表达式优化速度(但是是危险的),一个版本是确保安全(并可能慢):
* (macroexpand > (fast-progn
在本地(2 + 1)))((声明(优化速度(3)(安全0)))(2)+ 1)
T
我们还可以提供其他声明在宏参数,因为它们的位置不是也不能验证,直到宏扩展:
* (macroexpand
3因为它?t建立绑定。
>(快?-progn(声明(类型fixnum)) (fixnum (+ 1))))
(本地(声明(优化速度(3)(安全0)))(声明(类型FIXNUM)) (FIXNUM (+ 1)))
T
当试验宏观扩张,有时我们想看看会发生什么,当我们将它们嵌入到各种词汇上下文。结合4.1节中描述的读取期评估宏观,运行时在阅读时间和*变量,使过去三REPL结果可以让我们看到我们的形式按预期评估:
* (((0))#。*)
但要注意,虽然上面的正确评估,声明有时只有充分考虑编译的代码。例如,由于我们上面的评价解释代码?,它可能会忽略安全声明和继续bignum促进一个溢出的结果。让吗?看到如果发生这种情况:
*(让((most-positive-fixnum)) # 4)
536870912
它的功能。CMUCL忽略声明解释代码。我们想继续玩表达目前在* * *,但是自从我们呢?不知道我们?要把它放在下一个尝试,让?把它带回*我们不?t失去它:
*在大多数的实现。CK
(本地(声明(优化速度(3)(安全0)))(声明(类型FIXNUM)) (FIXNUM (+ 1)))
在这里。所以我们现在有三个更多的机会使它工作。让吗?试着编译它,看看我们可以观察fixnum包装:
* (funcall(编译nil ?(λ()(((most-positive-fixnum))
�))))
;警告:这不是一个(FIXNUM普克T值):;536870912
536870912
嗯,到底发生了什么事?没有吗?我们告诉lisp不检查这个吗?推理是声明进一步复杂化compiletime优化像常数合并。发生了什么是,当lisp编译形式能够在编译时执行的因为我们是添加常数,因此它知道结果还将持续,不需要在运行时计算。lisp这么做的时候看到我们的宣言成为fixnum肯定是错的。警告是lisp ?年代的方式告诉我们“我,你假吗?m无视你的声明,因为你可以吗?t是可信的。”如果我们稍微调整以便lisp表达式?t褶皱任意常数,我们终于可以看到了fixnum包装效果:
* (funcall (compile nil ?(lambda (a)
2 * #))
most-positive-fixnum) -536870912
声明的另一个重要特性是它们能影子其他声明在同样的意义上,词法变量可以影子其他词法变量。例如,我们可能想编写一个宏,执行安全检查,即使它是嵌入在代码声明不安全:
(defmacro错误检查()? (safe-progn(声明(整数型var)) do-whatever-other-error-checking))
包装多一层,我们可以使用这些宏在一些代码添加错误检查代码安全需要运行得很快,而不是通过嵌套另一个使用这些宏,其他的fastprogn:
(defun对于封装操作()(safe-progn do-whatever-error-checking (fast-progn but-this-needs-to-go-fast)))
安全验证参数的错误检查周围地区的快速实现一些功能在高性能lisp代码是一种常见的模式。尤其是对迭代过程像数组遍历,戏剧性的改善运行时性能可以通过做错误检查类型和边界检查前面的一个操作,然后省略它们尽可能在执行它。
常见LIspP首先是设计成强大的程序;效率是一个遥远的次要问题。然而,这些特性,功率和效率,唐?t不一定代表一种折衷。与宏我们可以应用lisp的力量
解决效率问题。除了常规的宏和读宏?这本身已经提供相当大的权力吗?COMMON LISP编译器还提供了宏。编译器宏宏在同样的意义上,其他类型的宏是:他们是程序的程序。编译器宏是吗?t大多数lisp教程中描述这是指示性的频率性能是一个优先的程序员(几乎没有)。然而,编译器宏是优雅的解决某些类型的效率问题和值得每一个lisp专业吗?作为工具。
编译器宏定义转换,lisp编译器将适用于(命名)函数调用。这意味着你可以把一个函数创建defun告诉lisp编译,而不是调用这个函数,它应该由编译器编译一些任意代码表示的宏。为什么要使用一个函数结合宏观而不只是一个编译器首先编写一个宏的名称吗?第一,更重要的原因是,这让我们吸收更多的控制在编译的开销。特别是,COMMON LISP并吗?t指定何时或如何扩大。通常一个宏解释代码可能是一个宏将扩大每次调用它�在编译时优化我们想执行一个(可能是漫长而昂贵的)计算在运行功能之前,以减少计算这个函数本身。编译器宏给我们表演一次冗长的编译计算准确,当我们编译代码?是应该的。
但更重要的是比执行编译计算只有一次,在正确的时间,编译器宏是有用的,因为它们引入了语法在语言的二元性。编译器宏让我们添加一个双重意义代表(命名)函数调用的任何形式。除了常规的意义,宏观添加一个编译器编译的意思。你很强烈建议,以确保你的编制意义实现了与常规意义相同的任务,但你都是免费的
甀n句话说,宏展开并缓存?保证当口译。
改变它如何执行它(?的点)。使用双语法的优点是,我们可以更改代码的效率,而无需修改代码。我们可以把现有的代码库吗?一个可能使用大量的函数调用?和改变代码编译通过引入双语法。所有我们要做的就是找到无法接受昂贵的函数调用,然后实现编译器扩展宏将他们转化为便宜。
什么样的函数调用是昂贵的?作为第一个例子,回忆从4.6节,读者安全功能可以执行λ解构,这是更普遍的一个子集defmacro destructuring�当函数接受关键字参数我们通过分组对关键字的符号及其对应的值。关键字参数是非常有用但功能使用它们不幸遭受比函数调用的开销唐? t。解构不是吗?t自由。编译器需要编译代码扫描的功能在一定可变长度参数列表,获取值放入正确的顺序(包括插入默认值),然后执行这个函数。一般来说,快速lisp编译代码destructuring这些关键字参数,所以我们几乎从不注意(或关心)这个小效率低下。但是,在有些情况下当我们做护理,尤其是当我们调用这种函数在一个性能关键型循环。
Fast-keys-strip实用程序需要一个λdestructuring列表组成的常规和关键字参数并返回一个列表的符号指这些论点。换句话说,它返回(a b c)通过(a b c)或(b键(0)),但是通过它(可选b c)是禁止的。
Defun-with-fast-keywords用于defun一样。defun一样,它的第一个参数是一个符号命名函数,第二个参数列表,和其他形式的函数被定义为执行。然而,与defun defun-with-fastkeywords形式只能定期和关键字参数
甃ambda destructuring可以吗?t变性列表作为参数传递,缺乏一些defmacro等功能。
清单7.4:FAST-KEYWORDS-STRIP (defun FAST-KEYWORDS-STRIP (args)(如果args(电导率(Ceq(汽车args) ?关键)(FAST-KEYWORDS-STRIP (cdr args))) (Cconsp(汽车args))(缺点(caar args) # 1 = (-keywords-strip快
(cdr args)))) (t
(缺点(汽车args) # 1 #)))))
清单7.5:DEFUN-WITH-FAST-KEYWORDS
(defmacro !普克defun-with-fast-keywords(名称args身体)? (progn (defun、名称、参数、@body) (defun g ! fast-fun
,�fast-keywords-strip args)籃身体)(编译? g ! fast-fun) (define-compiler-macro、名称(普克(destructuring-bind args(列表�,g !fast-fun, @ (fast-keywords-strip args))))))
籫 irest) 籫 irest
清单7.6:KEYWORDS-TESTS (defun slow-keywords-test (b键(0)(0))(公元前+ d))
(编译? slow-keywords-test) (defun-with-fast-keywords
fast-keywords-test (b Bkey c(0)(0))(公元前+ d))(没有可选,休息,等)。练习:扩展fast-keywords-strip来处理所有λdestructuring列表?。
的扩张defun-with-fast-keywords是复杂的。它扩展到三种形式�首先定义了函数,就像我们使用了正则defun代替。第二个定义了一个函数命名与自动gensym g ! fast-fun。这个函数类似于第一个,除了它只是将nonkeyword参数为每个参数(关键字)。下一个编译器定义宏调用我们的第一个函数转换成调用第二个函数。所以第一个函数执行关键字解构,我们利用编译时的知识形式用于调用功能,把关键字与destructuring bind成正确的顺序。
我们现在有一个(几乎)与defun双语法。普通函数的定义与关键字参数slowkeywords-test的样子。下面是编译的基准测试的目的。Fast-keywords-test写相同slow-keywordstest除了它使用defun-with-fast-keywords代替defun。原来我们不?t需要编译这个函数因为defun-with-fast-keywords展开成一个调用编译的只有一个定义,需要它?命名的
7但记住Norvig呢?lisp年代黄金定律:永远不要混合关键字和可选的参数。
8这都视为顶级,因为顶级progn形式特殊对待?COMMON LISP的一个有价值的特性。
清单7.7:KEYWORDS-BENCHMARK
(defun keywords-benchmark (n)(格式t缓慢键:~ %)(时间(我从1到n循环(slow-keywords-test 1 2: d 3: c�n)))(格式t快键:~ %)(时间(我从1到n循环(fast-keywords-test 1 2: d 3: c�n))))(编译? keywords-benchmark)自动gensym g ! fast-fun。
Keywords-benchmark是一个简单的函数,使用宏的时间告诉我们一个等价的一系列调用需要多长时间的函数。请注意,我们编译keywords-benchmark太。更多关于基准测试将在7.7节说,写作和基准测试编译器。
*�(keywords-benchmark 100000000)缓慢密钥:
3;评估了:
;17.68秒的时间
快速键:3;评估了:;10.03秒的时间
调用这个函数1亿倍都足以让我们看到,即使编译的函数,该函数定义了defun-with-fast-keywords大约快40%由于其编译器宏。还需要注意的是,编译器宏?性能不?t依赖的关键字参数是已知在编译时常量值。看到我们通过n, lisp形式,不同的参数:c字。所以宏观扩展了快速编译器版本一模一样的
版本是缓慢的,除了它不?t字destructuring开销。
所以为什么不呢?t CoMMoN LISP这样做对每一个函数,它接受关键词和总是避免开销?在编译时编译器宏只是应用但是我们想保留变性参数在运行时的能力。这是重要的关于编译器宏:编译器宏被优化函数调用,函数本身。在关键词的情况下,编译器宏允许我们消除对编译函数调用的开销,同时仍然保留最初的功能?和它的关键字解构代码?在运行时使用。编译器宏给我们一个双重的语法只有背景区分两种不同的操作。另一种避免关键词开销看到Norvig吗?年代PAIP | rai-ps23}。
其他函数调用可以受益于编译器宏?我们不仅可以减少destructuring开销,但我们常常可以减少开销函数本身的预处理常数参数。编译器的宏可以在编译时执行一些准备没有?t必须在运行时完成。这方面的一个最明显的例子是函数的格式。考虑如何格式(或者,在C语言中,printf)工作。这是一个函数,通过在运行时控制字符串。然后处理控制字符串格式和打印格式化输出到一个流(或将其作为字符串返回)。从本质上说,当你使用你让一个函数调用的格式控制字符串的格式字符串翻译程序。通过编译器宏我们可以消除函数调用,预处理控制字符串,并将专业代码的函数调用拼接成的调用编译器可以进一步优化。听起来困难,并?t吗?我们必须知道如何格式控制字符串转换成等价的lisp代码。幸运的是,与很多其他事情一样,COMMON LISP已经想到了这一点。COMMON LISP格式是否正确。这是领域特定语言,它指定用于创建格式化输出可以macro-compile本身lisp代码。这是lisp哲学的一部分吗?一切都应该编译lisp。的
宏lisp编译控制字符串格式化程序。当你给一个控制字符串格式化程序将扩展到λ形式执行所需的格式。例如,这里有一个扩展为一个简单的控制字符串呢?:
* (macroexpand吗?(格式化程序“你好~ ~ %”))
#吗?(λ(可选流(#:格式- arg - 1783(错误“失踪arg”))普克格式::ARGS)(块NIL(弦乐“Hello”流)(PRINC #:格式- arg - 1783流)(TERPRI流)格式::ARGS)
所以格式化程序展开成一个λ,形成!lisp编译了控制字符串形式,适用于宏观评价或嵌入到其他lisp代码,它将成为一个编译函数或将内联到编译后的代码调用。注意但是格式化程序必须通过一连串的扩张和不能接受零格式。这是因为格式化程序扩展的功能(如writestring和terpri)需要流。使用with-output-tostring宏为了解决这个问题。
Fformat是一个完全透明的包装格式。它存在我们可以定义一个编译器宏格式化。我们需要一个新的函数名从格式,因为编译器定义宏的功能指定由COMMON LISP forbiddenictri2-r26q . .我们的编译器宏观利用defmacro解构功能,整体。我们使用这个表单绑定到实际的宏调用的列表结构。这样做是为了利用编译器特性的宏:编译器
流癟erpri输出一个换行符。104年sharp-quotedλ形式。
清单7.8:FFORMAT
(defun fformat普克(全部)(应用# ?格式))(编译? fformat)
(define-compiler-macro fformat(整体形式流普克fmt参数)(如果(constantp fmt)(如果流* (funcall (formatter, fmt)流,@args)(让(g !流(gensym“流”)))? (with-output-to-string (g !流)(funcall (formatter, fmt) gistream, @args))))))宏可以选择不扩大。如果我们返回形式,lisp会发现我们只是返回表单通过(通过检查它与情商),将要求编译器没有进一步扩张的宏观形式?尽管我们正在扩大与编译器使用一个函数宏。编译时我们选择使用其他形式的意义。这是一个编译器的基本区别宏观和常规的宏。编译器的宏可以共享一个精确的双语法功能但常规宏观不能。在fformat编译器宏选择不会扩展到更有效的意义控制字符串参数是不恒定。在fformat,我们仍然希望调用fformat non-string控制字符串(如函数调用返回的字符串)。换句话说,我们仍然希望能够在运行时生成控制字符串。这样调用显然不能使用编译时优化控制字符串。
Fformat-benchmark keywordsbenchmark函数几乎是相同的了。它使用时间比较需要执行大量的格式操作
清单7.9:FFORMAT-BENCHMARK
(defun fformat-benchmark (n)(格式t格式:~ %)(时间(我从1到n循环(格式nil“你好~ ~ a7%”?世界n)))(格式t Fformat: 7%)(时间(我从1到n循环(Fformat nil“你好~ ~ a7%”? ?世界n))))(编译? fformat基准)和新fformat使用常规格式。这里有一百万次迭代的结果:
* (fformat-benchmark 1000000)
Format:
;评估了:
;37.74秒的时间
;(运行时间包括GC运行时4.08秒);1672008896字节的缺点。
Fformat:
;评估了:
;26.79秒的时间
;(运行时间包括GC运行时3.47秒);1408007552字节的缺点。
约30%的改善。编译器不仅宏执行格式化减少所需的时间,但也少缺点(进而减少垃圾收集时间)。编译器宏观避免了格式字符串的解释在运行时,而不是执行大部分的函数被编译时只计算一次?是应该的。不幸的是,基准常常掩盖或消除重要细节。在预编译格式字符串fformat将消除解释开销,将这样做的代价更大
编译程序。即使主内存充足,大型代码可以运行更慢通过减少指令缓存性能。
在本节中,我们研究了如何定制代码的性能使用正则宏,宏,阅读和一种特殊类型的宏观设计只是为了这个任务:编译器宏。希望这部分,本章的剩余部分会让你相信,如果你想真正高效的代码,写你想CoMMON Lisp。和你想要的COMMON LISP宏。
练习:下载Edi Weitz ?CL-PPCRE(第4.4节中描述,CL-PPCRE),看看api。lisp使用编译器宏。参观Edi吗?网站和下载他的一些lisp包看起来很有趣。
锻炼:当我们写编译器宏观fformat我们被迫使用gensym明确,因为没有define-compiler-macro !宏。解决这个问题。困难锻炼:定义define-compiler-macro !所以它使用defmacro的功能!和不?t叫gensym本身。提示:跳出思考框架。
7.3了解你的反汇编程序
很难真正了解什么是昂贵的在lisp中没有检查原始lisp处理器执行的指令不同形式。就像在编写宏这经常帮助来查看他们的扩张,有时看着lisp程序的编译扩张?通常汇编指令?也同样有用。因为lisp编译器可以和经常被认为是宏观扩展器,他们生成的机器代码,在一种奇怪的感觉,lisp代码。因为lisp与其说是一种语言,因为它是一个建筑材料和织物用于创建语言,lisp是用于定义和编译语言,恰好是同一种语言的指令集处理器。
CoMMON LIsP给我们提供了一个名为拆开看的函数编译扩展。拆卸的模拟CMUCL macroexpand-all [userut-tispatcos2]中描述的扩展。通过拆卸一个函数,或的一个象征
symbol-function绑定存在,我们可以看看原始机器代码指令将如果函数调用执行。
问题是这些原始机器代码指令不?看起来像lisp。而不是lisp ?舒缓的嵌套的括号,这些指令通常是奇怪,一些非常微小的步骤任意机器。看着lisp代码的编译扩张是类似于用放大镜看海报。你可以看到你喜欢的任何部分的细节,仅从这个解释大局是困难的或不可能的。更糟糕的是,当看着代码在这个级别的细节,有时候可能看任何一个特定的机器代码,告诉编译器把它放在那里的原因。
不幸的是,没有人真正知道如何最好地实现lisp编译的功能。有很多更宏观展开代码完成,这是肯定的,其中一些是板上钉钉的事,因此它可能是标准化的,但最好的方式使用硬件资源(如CPU周期和内存仍然(和可能永远)是一个非常热门的研究课题。更难比编译器设计的改善跟踪持续改进硬件。优化,有意义最初可能变得无关紧要甚至是不正确的。我们不?t需要找太远的例子如何改变世界对效率影响假设。
科学家们! !用于在代码中避免使用浮点计算需要表现良好,而不是选择machineword,定点计算。这是因为电脑没有?t有专门的硬件和被迫使用浮点处理器呢?整数指令来模拟它。因为处理器吗?t真正优化,浮点运算总是比定点操作慢得多。然而,随着时间的推移,硬件开始发芽专用浮点协处理器的设计来执行这些浮点操作以闪电般的速度。几乎一夜,科学家从能够假设定点运算总是比浮点运算速度要快得多,
?为数不多的计算机用户人口统计,需要高效的代码。
清单7.10:说
(defmacro dis (args &rest body) ?(disassemble (compile nil (lambda ,(mapcar (lambda (a) (if (consp a) (cadr a) a))
args)(宣布籃(mapcar #”(类型、(汽车)、(cadr al)) (remove-if-not # ?consp args)))籃身体)))),在决定前调查和基准测试硬件。硬件的发展改变了浮点性能的现实。不久之后,电脑开始有2、4或更多浮点协处理器以及科学家发现,如果他们能够保持浮点指令的管道,浮点运算通常执行甚至比定点操作。许多程序,选择定点由于性能原因了吗?在十年左右的时间框架?从选择正确的实现选择错误的实现。
一样有用的看macroexpand和macroexpand-all输出而发展中宏,它有助于分解输出,不仅要了解您的实现功能,而且确保你给lisp所需的所有信息来生成有效的扩张。说一个宏,便于检查分解输出的lisp代码的一部分。它的第一个参数是一个列表的符号或列表的类型和一个符号。看到说单词,扩大它。这就是dis扩展为一个简单的二进制加法:
* (macroexpand (dis (b) (+ b)))
(拆卸(编译NIL(λ(B)(宣布)(+ B))))
为什么空的声明形式吗?它是一个占位用的,说可以插入类型声明如果你指定的参数如下:
* (macroexpand (dis ((fixnum a) (integer b)) (+ a b)))
(拆卸(编译NIL(λ(B)(声明(类型FIXNUM)整数类型(B)) (+ B))))
因为说展开成一个(包装)λ,形式,很像一个。如果你愿意,你可以添加额外的声明和返回值是很重要的(因为λ形式提供隐式progn)。这本书吗?年代代码加载,试试这种形式输入到您的lisp环境:
(dis (a b) (+ a b))
机器代码应该相当短,但这是因为大部分的复杂性隐藏一个预编译函数的调用?有足够的智慧来提供所有的lisp数量等功能类型传染,合理简化,等等。这就是所谓的间接和可能是相当明显的反汇编程序输出:
叫# x1000148;通用- +试试三个参数:
(dis (a b c) (ab + c))
练习:有多少间接一般加法函数你看到了什么?如何在N (< = 0 N)参数?现在尝试锁定类型的一个变量。相比与前面的例子没有声明的类型:
(dis ((fixnum a) b) (+ a b))
某种OBJECT-NOT-FIXNUM-ERROR现在应该很明显。Lisp编译一些额外的代码来做这类型检查,同时还间接控制通用加法函数在编译时因为b的类型是未知的,因此可能需要所有Lisp ?年代的数值行为蔓延。
这不是如何获得快的代码。事实上这段代码甚至可能比以前效率比较低。快的代码,我们需要利用这一过程被称为内联。对于一些特殊的操作,当足够的类型信息是可用的,lisp编译器知道如何避免间接和直接的机器代码添加到函数被编译执行所需的操作。不应该有间接的通用加法函数如下:
(dis ((fixnum a) (fixnum b)) (+ a b))
内联过程可能导致更多的机器代码比间接就业。这是因为一些(但不是所有)的功能是实现泛型添加功能复制到我们编译的函数。虽然看起来更长,在某些情况下,这段代码将表现得更好,因为更少的间接。
但这混乱的机器代码仍然是少很多的效率比C实现的可能。还有各种各样的参数计算,类型,和溢出检查编译?这么多的实际成本相比仍然较低,除了其开销。如果我们在一个循环中使用这个函数,这个开销可能是不可接受的。
到处都有语言如C指定类型和执行安全地方所以代码总是有效的,不安全,总是讨厌写作。与大多数动态哭语言指定类型,执行安全无处不在所以代码总是安全的,不会讨厌,但也不会有效。最强,哭的静态语言你指定类型和执行安全到处都因此代码总是有效和安全的,但总是烦人。Lisp给你选择。因为lisp违约safe-and-not-annoying模式,lisp程序通常似乎略低于C的同龄人,但几乎总是安全。因为系统lisp允许程序员一个优秀的类型声明和实现有这样优秀的编译器,lisp程序几乎总是和他们一样安全动态哭等价物,通常更快。最重要的是,lisp宏如果是烦人的,嗯,改变它!
让吗?年代继续问lisp使我们快速增加。记得sharp-f读宏观缩写是一个高速、lowsafety声明。
(dis ((fixnum a) (fixnum b)) #f (+ a b))
这个机器代码指令序列应该比以前有点短。类型检查和参数计数检查应该被删除。但这还不是吗?t单指令,砰砰地打,危险fixnum除了我们正在寻找。了解正在发生的事情,我们应该检查编译器。报告由编译器的观察意见,这使得本质上说:“你看起来像你吗?试图做一些有效的,你呢?差不多了,但是我需要一点澄清你的意图。在这里吗?小费让它更清楚……”
编译器记录信息的宝贵来源。当试图创造高效的lisp代码时,你应该仔细阅读并考虑他们。Lisp编译器使用类型推断系统的代码,即使你发现复杂的属性,程序员,可能没有考虑。在上面的例子中,我们的编译器应该给我们一个地方请注意:
;注意:做签名字整数强制3(成本20)“<返回值>”。
Lisp并吗?t做任何愚蠢的像忽略fixnum溢出,除非我们明确地问它! ?。为了让lisp把谨慎抛到九霄云外,我们写一个函数,真的烧伤,但可能是不安全的,我们需要避免签署词(fixnum)整数(bignum)检查和胁迫。我们需要告诉lisp溢出是可以接受的,是的,我们真的想悄悄返回fixnum:
(dis ((fixnum a) (fixnum b)) #f (the fixnum (+ a b)))
现在我们吗?重新燃烧。这是大致相当于一个C fixnum添加功能:一些机器指令加在一起两个寄存器,然后控制返回给调用者。当你反汇编程序可以提供许多见解lisp效率的所有领域,主要有两个技能,它会教你。第一个技能主要是本节讨论:如何使用声明得到高效数值行为,尤其是内部循环。第二个是如何有效地使用数组/矢量数据结构。这将是7.4节中所讨论的,指针范围。
就像技术进步改变了浮点运算?年代效率的现实的东西应该避免的东西应该利用,在lisp编译器技术进步吗?结合COMMON LISP吗?正确的类型和安全宣言系统?正在改变我们如何
21 m C程序,fixnum溢出是一个安全漏洞类,通常是针对性和被攻击者利用。
考虑效率。用这些工具,软件系统的日益复杂化的要求!*,问题正在从如何使lisp尽可能高效的低级语言如何让其他语言lisp一样有效。当然,答案是使用lisp宏来实现它们。
7.4指针范围
并将指针从一种语言减少语言的力量?特别是,lisp吗?年代缺乏明确的指针范围有效地阻止我们实现算法中指定指针的算术?原来没有,缺乏直接支持指针在lisp中并不构成一个理论或实践的挑战。任何算法或数据结构,可以使用指针来实现像C语言lisp可以相同或更好的实现。
但是,真的,指针范围和为什么要使用它呢?指针范围涉及治疗电脑吗?年代内存或虚拟内存大,可转位数组,它可以加载和存储fixnum值。这听起来很危险吗?应该,因为它是许多复杂的缺陷的原因和直接原因的几个最大的类软件的安全问题。
指针范围是一个指定间接的方式,即在环境中访问,这也是与fixnum算术。我们通常计划在环境如何?我们使用的词汇或动态范围由COMMON LIsP,两双组合,或新类型的范围由宏。——宏观和指针的指针- *函数示例,素描的一些幻想指针范围,显示,当你认为你需要一个指针时,你可能需要一个闭包。第一个也是唯一一个提到这个类比指针和闭包我听说房价在一篇描述lang.scheme新闻组
131 isp ?年代优化潜力真正闪光的时候宏观技术用于提高大型和复杂的应用程序的性能。
清单7.11:POINTER-SCOPING-SKETCH
(defmacro !指针——(obj) ?(λ(%可选(g !设置? g !临时))(如果(eq, giset ? g !临时)籵bj (setf, obj, g !)))) (defun指针- * (addr) (funcall addr))
(defsetf指针- * (addr) (val) * (addr, funcall val))
(defsetf指针——(addr) (val) ? (setf(指针- *,addr), val))奥列格Kiselyovpomrers-as-ciosures]。他建议使用闭包来模拟指针和提供了一个实现方案! *。
指针——和指针- *显示的方式来模拟指针间接通过闭包。当我们使用指针——宏观它展开成一个λ形式有一些智慧,以确定如果你想获取或设置值,并相应地也。指针——使用gensyms来做到这一点。而不是使用它们作为绑定的名字以避免不必要的变量捕获在编译时,指针——使用它们,以确保不可能捕获运行时,我们无法设定一个闭包?年代价值一定的价值,因为它与我们的实现冲突。例如,我们可能会选择零的lisp违约这通常会工作除非我们试图通过nil作为参数。Gensyms方便使用在运行时因为我们知道永远不会有另一个值gensym情商。那是他们存在吗?可能。
指针- *及其defsetf框架通过全面访问这些间接值变量。defsetf为指针,指针,以便扩张
4奥列格?网站包含许多这样的洞察力和强烈推荐阅读。
知道如何将嵌套的间接。作为一个简单的例子,我们可以创建一个闭包,模拟中常见的指针的指针模式C通过创建一个引用绑定在一个让环境:
*(让((x))(指针——(指针- x)))
# <解释功能>
让吗?这个闭包存储起来,供以后使用的转移从*特殊变量(让吗?把所有这些连续星号):
�(defvar temp-pointer *) # <解释功能>
现在我们可以废弃这个闭包:*(指针- * temp-pointer) # <解释功能>
似乎我们有另一个闭包。我们只有取消引用指针链的一步。使用*特殊变量引用前面的结果,让?年代废弃进一步:*(指针- * *)0
0是原始对象,我们指出。我们也可以用这个非关联化语法呢?这当然是一种幻觉/闭包?设置该对象的值通过指针链:
�(setf(指针- * - * temp-pointer(指针)5)
5
果然,这改变了最初让环境被指出,这样一个新值,5:
*(指针- * - * temp-pointer(指针)5如果我们喜欢,我们可以添加另一个间接层:*(指针——temp-pointer) # <解释函数>目前需要三个取消引用:
- * - * *(指针(指针(指针- * *)))
5
和本身可以作为一个普遍变量访问:�(setf(指针- * - *(指针(指针- * * *)))9)9
尽管他们可能在不同级别的间接寻址,所有的闭包在这个非关联化链还点回到最初让环境:
*(指针- * - * temp-pointer(指针)9
但这可能不是吗?你认为我们是什么意思通过指针范围。因为大多数计算机处理器考虑内存fixnum大数组,因为C是围绕现有处理器的功能设计,C ?年代永久指针范围与fixnum算术。在C语言中,当你废弃一个指针总是知道正在发生的事情:编译器编译
在代码索引到内存fixnum和检索或设置fixnum值。C最大的区别?年代指针范围和我们上面关闭非关联化技术,尽管C允许我们改变指针指向通过添加或减去fixnum,指针的指针——编制的闭包和访问- *是固定的。代码访问和设置呢?什么可能?在编译时被添加到间接环境。即使在我们上面的简单示例中,我们使用至少两种不同类型的闭包,这两种,由于普遍变量,可以通过一个统一的非关联化的语法。x我们最初指的是一个词法变量和temp-pointer隧道变量,我们指的是一个动态变量。正如6.7节中我们看到,Pandoric宏,我们可以定制闭包,以任何方式,从而间接,我们想要的。
实际上闭包是更灵活和更少的危险比C风格的指针。当你认为你需要一个指针,你可能需要一个闭包。而不是一个fixnum可以作为地址,闭包是编译的代码检索和设置在任何环境中任何类型的数据。尽管对于大多数任务闭包是最好的构造实现间接,有时候我们想利用我们的处理器吗?年代fixnum寻址功能实现非常高效的代码。C让我们做;COMMON LISP让我们做得更好。
在lisp中使用c风格的指针其实是非常简单的,也?t需要离开我们通常lisp的技术。我们只是提供一个fixnum数组,使用数字索引数组索引吗?思考就像c,然后使用声明lisp下降类型和安全检查,所以编译就像c。最后,我们使用宏使整个过程方便和安全。
一般来说,索引为一个数组是一个复杂的、缓慢的过程。编译器需要检查你的指数数字,你试图索引数组和数组的索引范围内。此外,不同类型的数组可以可以有不同的代码来访问元素。这本书吗?年代代码加载,尝试评估以下表格(dis详细描述
7.8节,了解你的反汇编程序):
(dis (arr印第安纳州)(印第安纳州的arr aref))
因为aref可能意味着很多可能的事情当没有类型,编译器可能不内联数组访问的代码。在上面的拆卸输出,您应该看到一个类似CMUCL函数调用吗?data-vector-ref。练习:lisp环境获得的源代码并检查这个函数。在CMUCL array.lisp的文件。也检查该文件中的其他功能,包括data-vector-set。如果lisp环境?t完整的源代码,或者你是吗?t能做任何你想做的你有源代码,升级你的尽快COMMON LISP的环境。
