<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.4 Free Variables &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="3.5 Unwanted Capture" href="3.5-unwanted-capture.html" />
    <link rel="prev" title="3.3 Control Structures" href="3.3-control-structures.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第三章：宏基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="3.1-iterative-development.html">3.1 Iterative Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.2-domain-specific-languages.html">3.2 Domain Specific Languages</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.3-control-structures.html">3.3 Control Structures</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.4 Free Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.5-unwanted-capture.html">3.5 Unwanted Capture</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.6-once-only.html">3.6 Once Only</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.7-duality-of-syntax.html">3.7 Duality of Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第三章：宏基础</a> &raquo;</li>
      <li>3.4 Free Variables</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter03/3.4-free-variables.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="free-variables">
<h1>3.4 Free Variables<a class="headerlink" href="#free-variables" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>A <em>free variable</em> is any variable or function referenced in an expression that doesn’t have a global special binding or an enclosing lexical binding. In the following expression, <strong>x</strong> is free:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>But in the following, we create a binding around the form which <em>captures</em> the variable <strong>x</strong>, depriving it of its freedom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">x</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The terminology of freedom and capture may seem strange at first. After all, freedom implies consciousness and an ability to make decisions—something a simple expression is obviously lacking. But freedom doesn’t refer to what the expression can do, rather what we, as programmers, can do with the expression. For example, we can take the expression <strong>(+ 1 x)</strong> and embed it anywhere we want, allowing our expression to access a binding named <strong>x</strong> in the surrounding code. We then say that the code has <em>captured</em> our free variable. After the free variables in an expression are captured, as in the above <strong>let</strong> form, other surrounding code has no option of capturing our variable <strong>x</strong>. Our formerly free variable has already been captured. It is now completely unambiguous which <strong>x</strong> it refers to. Because of this, there isn’t really any need for lisp to keep the reference to the symbol <strong>x</strong> in the code at all. As was described in detail in <a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap2.html#sec_3">section 2.3, Lexical and Dynamic Scope</a>, lisp compilers will forget the symbols that were used to represent lexical variables.</p>
<p>Although any language with expressions can have expressions with free variables, lisp’s macro capabilities mean that free variables are much more useful in lisp than in other languages. In most languages we are forced to obey <em>referential transparency</em>. If there is no global or object variable <strong>x</strong> defined in a Blub program, the following code is unconditionally incorrect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">some_function_or_method</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">anythind</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is no way that <strong>some_function_or_method</strong> can create an <em>implicit binding</em> for <strong>x</strong>. In Blub, any use of a variable must have a textually apparent definition<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">8</a>. Languages with primitive macro systems (like C) can accomplish some of this in a very limited sense. But just as general purpose macros are impractical or impossible to write in C, so are the special cases involving free variables.</p>
<p>In lisp we can push around expressions with free variables as we please and either splice them into new expressions for them to be captured by surrounding code, or define global special variables to capture them. We can also write macros to modify which variables are free in an expression, either by re-writing the expression so it has fewer free variables (say by wrapping it in a let form, as above) or by modifying the expression in a way that adds new free variables. Such addition of free variables is the opposite of capturing variables and is called <em>free variable injection</em>.</p>
<p>The simplest possible free variable injection is a macro that expands into a symbol reference:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defmacro</span> <span class="n">x</span><span class="o">-</span><span class="n">injector</span> <span class="p">()</span>
  <span class="s1">&#39;x)</span>
</pre></div>
</div>
<p>Because a macro is just a function, it executes its body as a regular lisp form. The above injector macro evaluates the quoted symbol and, of course, returns a symbol—a free variable—to be spliced into any expression that uses the <strong>x-injector</strong> macro. Discussing such free variable injection in <em>On Lisp</em>, Paul Graham writes</p>
<blockquote>
<div><p><em>This kind of lexical intercourse is usually viewed more as a source of contagion than a source of pleasure. Usually it would be bad style to write such a macro. Of all the macros in this book, only [two isolated cases] use the calling environment in this way.</em></p>
</div></blockquote>
<p>By contrast, this book gets much pleasure from this sort of lexical intercourse. Free variable injection—writing a macro with full knowledge of the lexical environment it will be expanded in—is just another approach to lisp macro programming, one that is especially useful when there are a few slightly different lexical contexts that you would like to write mostly identical code inside. Although often the main advantage of a function call is that you throw out your lexical environment, sometimes, to lisp programmers, this is just a guide-line that can be ignored through the use of macros. In fact, once accustomed to it, some lisp programmers try to always write macros, extending the lexical context as far as possible, using a function only when they need to evaluate arguments or just chicken out and want a new lexical context. In <a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#sec_6">section 3.6, Once Only</a> we will see a way to avoid throwing out your lexical environment when you need arguments evaluated. Keeping the lexical environment around as much as possible allows for very interesting macro <em>combinations</em>, where a macro adds lexical context around a use of one or more other macros. Expanding into code that uses the very macro being defined is a special case of macro combination and is treated in <a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap5.html#sec_5">section 5.5, Recursive Expansions</a>.</p>
<p>The shortest distance between two points is a straight line. Free variables and, more generally, extended lexical contexts are often the easiest way to programmatically construct a program. Using macros in this way might seem like a hack, and might feel objectionable on stylistic grounds, but it works conveniently and reliably. Especially after we consider <strong>macrolet</strong> in <a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap5.html#sec_4">section 5.4, Code-Walking with Macrolet</a>, this style of programming—combining macros—will begin to feel more comfortable. Just remember that macro programming is not about style; it is about power. Macros allow us to do many things that are impossible in other languages. Free variable injection is one of them.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3.3-control-structures.html" class="btn btn-neutral float-left" title="3.3 Control Structures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="3.5-unwanted-capture.html" class="btn btn-neutral float-right" title="3.5 Unwanted Capture" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>