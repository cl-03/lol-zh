<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5.2 自上而下的编程 &mdash; Let Over Lambda 中文文档  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.3 隐式上下文" href="5.3-implicit-contexts.html" />
    <link rel="prev" title="5.1 非函数式编程" href="5.1-lisp-is-not-functional.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第五章：Programs that program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="5.1-lisp-is-not-functional.html">5.1 非函数式编程</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.2 自上而下的编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.3-implicit-contexts.html">5.3 隐式上下文</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.4-code-walking-with-macrolet.html">5.4 使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 遍历代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.5-recursive-expansions.html">5.5 递归展开</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.6-recursive-solutions.html">5.6 递归方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.7-dlambda.html">5.7 Dlambda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第五章：Programs that program</a> &raquo;</li>
      <li>5.2 自上而下的编程</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter05/5.2-top-down-programming.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>5.2 自上而下的编程<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<blockquote>
<div><p>你教不会初学者自顶向下编程，因为他们不知道哪一端是上。 –C.A.R. Hoare</p>
</div></blockquote>
<p>在 <a class="reference internal" href="../Chapter03/3.2-domain-specific-languages.html"><span class="doc std std-doc">3.2 Domain Specific Language</span></a> 中，当我们第一次考虑特定域语言时，我们创建了个简单
的宏 <code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> 。这个宏允许我们用一种直观的、基于符号的语法，可以方便地以不
同的单位指定时间段：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">unit</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">time</span> <span class="mi">1</span> <span class="n">d</span><span class="p">)</span>

<span class="mi">86400</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> 是个很方便的特定域语言，因为程序员不必去记住一些东西，比如说，一天
有多少秒。<code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> 是用简单的宏实现的，该宏使用 case 语句作为底层展开的核心。</p>
<p>宏设计的一个重要原则就是自上而下编程。设计一个 lisp 宏时，首先要从抽象开始。你需要
在编写这个宏之前就想要使用这个宏。有点矛盾的是，在为该语言编写简洁的定义/实现之前，
你需要知道怎么用这个语言编程。</p>
<p>因此，构造个正规的宏的第一步是编写宏的用例，即使无法测试或使用它们。如果用新语言编
写的程序足够全面的话，那么接下来就会有个很棒的想法，即该语言实现编译器或解释器需要
什么。</p>
<p>回到 <code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> 宏，有没有办法将它提升到另一个级别的规格，并创建一种语言来创建
这些单位的方便的宏呢？好吧，<code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> 是个宏，为了实现目的就需要用宏来定义宏……</p>
<p>停！到此为止。</p>
<p>我们不是从考虑语言的实现开始的，而是问我们自己要用这个语言做什么。答案是我们想要个
简单的方法，用来定义这类帮助转换单位的工具。以下这个示例中，我们希望使用一种单位类
型——时间，其基本单位为：秒，用 <code class="docutils literal notranslate"><span class="pre">s</span></code> 来指代，以及一组单位和这个单位到基本单位的转换
因子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defunits</span><span class="o">%</span> <span class="n">time</span> <span class="n">s</span>
  <span class="n">m</span> <span class="mi">60</span>
  <span class="n">h</span> <span class="mi">3600</span>
  <span class="n">d</span> <span class="mi">86400</span>
<span class="n">ms</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1000</span>
<span class="n">us</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 会展开成定义宏的代码，就像在 <a class="reference internal" href="../Chapter03/3.2-domain-specific-languages.html"><span class="doc std std-doc">3.2 Domain Specific Language</span></a> 中编写的
<code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> ，允许我们将任意的时间单位转换为秒。还能写的更好吗？</p>
<p>在设计头脑风暴中，创新在大多数编程语言中都停滞不前。刚刚我们创建了一种将不同单位的
乘数值映射到代码中的方法，这种方法让我们能够方便地转换单位。但作为一个专业的 lisp
程序员会意识到这个映射本身就是一个程序，并且可以用我们经常增强 lisp 程序的方法来增
强它。当我们输入多种不同的单位是，用来指定对应的单位就会很有用。现在，让我们定义
个因子，这个因子用来增加单位的种类，可以是一个列表，该列表中的值与单位相对应，如
下所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defunits</span><span class="o">%%</span> <span class="n">time</span> <span class="n">s</span>
  <span class="n">m</span> <span class="mi">60</span>
  <span class="n">h</span> <span class="p">(</span><span class="mi">60</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">d</span> <span class="p">(</span><span class="mi">24</span> <span class="n">h</span><span class="p">)</span>
<span class="n">ms</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1000</span> <span class="n">s</span><span class="p">)</span>
<span class="n">us</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1000</span> <span class="n">ms</span><span class="p">))</span>
</pre></div>
</div>
<p>上面这个单位的列表看起来就比较自然了。我们以分钟为基础单位，秒、时基于分钟，天基
于小时。为了使用迭代的方法实现这个宏，首先需要用 <code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 来实现非链的版本，
然后用 <code class="docutils literal notranslate"><span class="pre">defunits%%</span></code> 实现链版本，最后添加适当的错误检查，就有了最终的版本：
<code class="docutils literal notranslate"><span class="pre">defunits</span></code>。</p>
<p>注意，这种新语言可以提供更多方便的语法来添加新的单元类型。这种语言还允许我们延迟
四舍五入对计算的影响，并允许 lisp 使用尽可能精确的算法。例如, furlong 相当于 1/8 英
里，所以我们使用链版本来对其进行编码，也就是说，近似的距离，就可以得到更准确的
结果，或者说更重要的是，与其他计算结果尽可能保持一致，都使用英里做单位。这是因为
我们可以添加找到的最精确的转换因子，而不需要自己进行任何转换，宏让我们在其他语言
中无法实现的表达式级别上构建转换例程。</p>
<p>使用 <a class="reference internal" href="../Chapter03/3.5-unwanted-capture.html"><span class="doc std std-doc">3.5 异常捕获</span></a> 中的 <code class="docutils literal notranslate"><span class="pre">gensym</span></code> ，<code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 就很容易编写。Graham 的 <code class="docutils literal notranslate"><span class="pre">symb</span></code> 函数
可以将转换宏生成个新的名字。例如，当 <code class="docutils literal notranslate"><span class="pre">time</span></code> 是内置的表示单位，那么转换宏就是
<code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code>。 <code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 是由最初定义的 <code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code> 构建的，<code class="docutils literal notranslate"><span class="pre">unit-of-time</span></code>
是在 <a class="reference internal" href="../Chapter03/3.2-domain-specific-languages.html"><span class="doc std std-doc">3.2 Domain Specific Language</span></a> 中定义的，在 <code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 中，由 <code class="docutils literal notranslate"><span class="pre">defmacro!</span></code>
和反引号组成，用来替换宏调用时需要重新生成的部分。</p>
<blockquote>
<div><p>Graham 是 On Lisp 的作者，会经常出现一些上面的内容，如果有时间的话，推荐去看
一下这本书。</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! defunits% (quantity base-unit &amp;rest units)
  `(defmacro ,(symb &#39;unit-of-quantity) (,g!val ,g!un)
     `(* ,,g!val
         ,(case ,g!un
           ((,base-unit) 1)
           ,@(mapcar (lambda (x)
                       `((,(car x)) ,(cadr x)))
                     (group units 2))))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 用了反引号（ ```）嵌套：一个非常难以理解的结构。用反引号编程就像在代码
中增加了一个维度的含义。在其他的语言中，给定的语句通常都有非常简单的语义计算。你能
清除的指导每段代码会在什么时候执行，因为每段代码都必须同一时间执行：运行时（run-time）。
但在 lisp 中，我们可以通过反引用嵌套来缩放引用的梯度。每次使用反引号时，都将我们的
梯度往上提了一级：反引号内的代码是一个列表，之后这个列表可能会被求值也可能不会。
但在里面的原始列表中，每遇到逗号时，有会将我们会回到上一个引用梯度，然后以合适的方式
执行对应梯度的代码。</p>
<p>因此，有一种简单的算法可以确定何时 lisp 代码会被求值。只需从表达式的根开始，在遇到
反引号后，标记一层引号。每遇到一个逗号，就把引号调低一级。正如 Steel 所指出的，
遵循这种级别的引用很具挑战性。追踪当前引用深度的这种困难，让使用反引用感觉像是在
常规编程中添加了另一个维度。在其他语言中，可以随意向“东南西北”四个方向走，但 lisp
还提供了向上的选择。</p>
<p><code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 是个好的开始，但却没有实现链。目前，实现该语言的宏主要是简单的替换。
要实现链行为需要更复杂的程序逻辑。简单的替代不起作用，因为宏的部分依赖于宏的其
他部分，所以在扩展时，需要完整地处理提供给宏的表单，而不仅仅是考虑可以插入的各
个部分。</p>
<p>记住，宏实际上就是函数，现在来创建了一个实用函数在宏定义中使用：<code class="docutils literal notranslate"><span class="pre">defunits-chaining%</span></code>。
这个实用函数接收一个单位，例如像 <code class="docutils literal notranslate"><span class="pre">S</span></code>、<code class="docutils literal notranslate"><span class="pre">M</span></code> 或是 <code class="docutils literal notranslate"><span class="pre">H</span></code> 这样的符号，同时接收该单位规格
列表。这个单位规格既可以是单个数字，这个数字被解释为基础单位，如 <code class="docutils literal notranslate"><span class="pre">(M</span> <span class="pre">60)</span></code>，
也可以是一个列表，该列表内部链式地指向另一个单位，如 <code class="docutils literal notranslate"><span class="pre">(H</span> <span class="pre">(60</span> <span class="pre">M))</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">defunits</span><span class="o">-</span><span class="n">chaining</span><span class="o">%</span> <span class="p">(</span><span class="n">u</span> <span class="n">units</span><span class="p">)</span>
  <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">spec</span> <span class="p">(</span><span class="n">find</span> <span class="n">a</span> <span class="n">units</span> <span class="p">:</span><span class="n">key</span> <span class="c1">#&#39;car)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">null</span> <span class="n">spec</span><span class="p">)</span>
      <span class="p">(</span><span class="n">error</span> <span class="s2">&quot;Unknown unit ~a&quot;</span> <span class="n">u</span><span class="p">)</span>
      <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">chain</span> <span class="p">(</span><span class="n">cadr</span> <span class="n">spec</span><span class="p">)))</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">listp</span> <span class="n">chain</span><span class="p">)</span>
           <span class="p">(</span><span class="o">*</span> <span class="p">(</span><span class="n">car</span> <span class="n">chain</span><span class="p">)</span>
              <span class="p">(</span><span class="n">defunits</span><span class="o">-</span><span class="n">chaining</span><span class="o">%</span>
                <span class="p">(</span><span class="n">cadr</span> <span class="n">chain</span><span class="p">)</span>
                <span class="n">units</span><span class="p">))</span>
           <span class="n">chain</span><span class="p">)))))</span>
</pre></div>
</div>
<p>这个实用函数是递归的。为了求基本单位的乘数，我们将链中的每一步乘以另一个实用
函数的调用，从而算出链的其余部分。当调用堆栈返回时，就会得到将给定单元的值转
换为基本单元的乘数。例如，在构建小时的乘数时，可以求得一小时是六十分钟，然后
递归得到一分钟是六十秒，再次递归时发现秒是这条链的末尾，然后就会直接将分钟设
为基础单位。因此，递归堆栈返回需要计算的是：<code class="docutils literal notranslate"><span class="pre">(*</span> <span class="pre">60</span> <span class="pre">(*</span> <span class="pre">60</span> <span class="pre">1))</span></code>，也就是
<code class="docutils literal notranslate"><span class="pre">3600</span></code>，这样就得到了一小时等于 3600 秒。</p>
<p>有了这个实用函数后，计算每个单位之间的乘数只需要对 <code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 进行简单的修改，
如下面的 <code class="docutils literal notranslate"><span class="pre">defunits%%</span></code>。我们不是直接从单元规格中拼接值，而是将每个单元和整个单
元规格传给 <code class="docutils literal notranslate"><span class="pre">defunits-chaining%</span></code> 实用程序。如上所述，这个函数递归地计算出将每
个单元转换为基本单元所需的乘数。通过这个乘数， <code class="docutils literal notranslate"><span class="pre">defunits%%</span></code> 可以像 <code class="docutils literal notranslate"><span class="pre">defunits%</span></code>
一样拼接到 <code class="docutils literal notranslate"><span class="pre">case</span></code> 语句中。</p>
<p>然而，这些宏并不完整。<code class="docutils literal notranslate"><span class="pre">defunits%</span></code> 宏不支持链式。 <code class="docutils literal notranslate"><span class="pre">defunits%%</span></code> 支持链式，但没有
错误检查。专业的宏编写人员总是小心地处理任何可能出现的错误条件。在无限循环或是
在 REPL 中难以调试的情况中，错误检查尤为重要。</p>
<p><code class="docutils literal notranslate"><span class="pre">defunits%%</span></code> 的问题实际上是我们设计的语言的一个属性：可以编写有环的程序。如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defunits</span> <span class="n">time</span> <span class="n">s</span>
  <span class="n">m</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">60</span> <span class="n">h</span><span class="p">)</span>
  <span class="n">h</span> <span class="p">(</span><span class="mi">60</span> <span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<p>为了提供适当的调试输出，需要稍微增强实现。最终的版本，<code class="docutils literal notranslate"><span class="pre">defunits</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun defunits-chaining (u units prev)
  (if (member u prev)
    (error &quot;~{ ~a~~ depends on ~}&quot;
      (cons u prev)))
  (let ((spec (find u units :key #&#39;car)))
    (if (null spec)
      (error &quot;Unknown unit ~a&quot; u)
      (let ((chain (cadr spec)))
        (if (listp chain)
          (* (car chain)
             (defunits-chaining
               (cadr chain)
               units
               (cons u prev)))
           chain)))))

(defmacro! defunits (quantity base-unit &amp;rest units)
  `(defmacro ,(symb &#39;unit-of- quantity)
             (,g!var ,g!un)
     `(* ,,g!val
         ,(case ,g!un
           ((,base-unit) 1)
           ,@(mapcar (lambda (x)
                       `((,(car x))
                           ,(defunits-chaining
                              (car x)
                              (cons
                                `(,base-unit 1)
                                (group units 2))
                              nil)))
                      (group units 2))))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defunits</span></code> 不但支持链式，而且如果该语言的用户指定了具有这种循环依赖关系的程序，
它还提供了有用的调试输出。之所以能做到是因为使用了 <code class="docutils literal notranslate"><span class="pre">defunits-chaining</span></code>——
<code class="docutils literal notranslate"><span class="pre">defunits-chaining%</span></code> 的升级版，<code class="docutils literal notranslate"><span class="pre">defunits-chaining%</span></code> 维护了以前访问过的所
有单元的列表。这样，当再次通过链式访问同一个单位时，就会抛出异常来简明的描述
这个问题:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">defunits</span> <span class="n">time</span> <span class="n">s</span>
    <span class="n">m</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">60</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">h</span> <span class="p">(</span><span class="mi">60</span> <span class="n">m</span><span class="p">))</span>

<span class="n">Error</span> <span class="ow">in</span> <span class="n">function</span> <span class="n">DEFUNITS</span><span class="o">-</span><span class="n">CHAINING</span><span class="p">:</span>
  <span class="n">M</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">H</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">M</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defunits</span></code> 宏与 <code class="docutils literal notranslate"><span class="pre">defunits%%</span></code> 完全相同，除了传递了个额外的参数 <code class="docutils literal notranslate"><span class="pre">nil</span></code> 给
<code class="docutils literal notranslate"><span class="pre">defunits-chain</span></code>，这是表示已经到了访问过的单位记录列表的末尾。如果一个
新单位被搜索，而我们已经访问过它，那么一个环就被检测到了。我们可以用这个
访问过的单元历史记录来向宏的用户（很可能是我们自己）显示有用的信息，这些
用户可能无意中写入了环。</p>
<p>因此，<code class="docutils literal notranslate"><span class="pre">defunits</span></code> 是种将单元输入到转换例程领域的专用语言。实际上，它精确
到更细的领域；也有很多可能的写法。由于在 <code class="docutils literal notranslate"><span class="pre">Blub</span></code> 中创建语言很困难，而在
lisp 中却很容易，所以lisp程序员通常不会把所有东西都塞到一个域中。相反，
它们只是使语言越来越精确到问题领域，直到问题变得很细致。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">defunits</span></code> 的例子是 <code class="docutils literal notranslate"><span class="pre">unit-of-distance</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defunits</span> <span class="n">distance</span> <span class="n">m</span>
  <span class="n">km</span> <span class="mi">1000</span>
  <span class="n">cm</span> <span class="mi">1</span><span class="o">/</span><span class="mi">100</span>
  <span class="n">mm</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span> <span class="n">cm</span><span class="p">)</span>
  <span class="n">nm</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1000</span> <span class="n">mm</span><span class="p">)</span>

  <span class="n">yard</span> <span class="mi">9144</span><span class="o">/</span><span class="mi">10000</span>  <span class="p">;</span> <span class="n">Defined</span> <span class="ow">in</span> <span class="mi">1956</span>
  <span class="n">foot</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="n">yard</span><span class="p">)</span>
  <span class="n">inch</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span> <span class="n">foot</span><span class="p">)</span>
  <span class="n">mile</span> <span class="p">(</span><span class="mi">1760</span> <span class="n">yard</span><span class="p">)</span>
  <span class="n">furlong</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span> <span class="n">mile</span><span class="p">)</span>

  <span class="n">fathom</span> <span class="p">(</span><span class="mi">2</span> <span class="n">yard</span><span class="p">)</span>  <span class="p">;</span> <span class="n">Defined</span> <span class="ow">in</span> <span class="mi">1929</span>
  <span class="n">nautical</span><span class="o">-</span><span class="n">mile</span> <span class="mi">1852</span>
  <span class="n">cable</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span> <span class="n">nautical</span><span class="o">-</span><span class="n">mile</span><span class="p">)</span>

  <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">nautical</span><span class="o">-</span><span class="n">mile</span>  <span class="p">;</span> <span class="n">Dropped</span> <span class="ow">in</span> <span class="mi">1970</span>
    <span class="p">(</span><span class="mi">6080</span><span class="o">/</span><span class="mi">3</span> <span class="n">yard</span><span class="p">)</span>
  <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">cable</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span> <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">nautical</span><span class="o">-</span><span class="n">mile</span><span class="p">)</span>
  <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">fathom</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">100</span> <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">cable</span><span class="p">))</span>
</pre></div>
</div>
<p>如果你想知道的话，1970 年采用国际海里制缩短了英寻（至少对英国水手而言）
的 1/76，也就 2 厘米多一点：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="o">/</span> <span class="p">(</span><span class="n">unit</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">distance</span> <span class="mi">1</span> <span class="n">fathom</span><span class="p">)</span>
     <span class="p">(</span><span class="n">unit</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">distance</span> <span class="mi">1</span> <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">fathom</span><span class="p">))</span>
<span class="o">*</span> <span class="p">(</span><span class="n">coerce</span>
    <span class="p">(</span><span class="n">unit</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">distance</span> <span class="mi">1</span><span class="o">/</span><span class="mi">76</span> <span class="n">old</span><span class="o">-</span><span class="n">brit</span><span class="o">-</span><span class="n">fathom</span><span class="p">)</span>
    <span class="s1">&#39;float)</span>

<span class="mf">0.024384</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="5.1-lisp-is-not-functional.html" class="btn btn-neutral float-left" title="5.1 非函数式编程" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="5.3-implicit-contexts.html" class="btn btn-neutral float-right" title="5.3 隐式上下文" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>