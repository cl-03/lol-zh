<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.2 领域特定语言 &mdash; Let Over Lambda 中文文档  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3.3 控制结构" href="3.3-control-structures.html" />
    <link rel="prev" title="3.1 迭代开发" href="3.1-iterative-development.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第三章：宏基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="3.1-iterative-development.html">3.1 迭代开发</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.2 领域特定语言</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.3-control-structures.html">3.3 控制结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.4-free-variables.html">3.4 自由变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.5-unwanted-capture.html">3.5 异常捕获</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.6-once-only.html">3.6 Once Only</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.7-duality-of-syntax.html">3.7 语法的二义性</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第三章：宏基础</a> &raquo;</li>
      <li>3.2 领域特定语言</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter03/3.2-domain-specific-languages.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>3.2 领域特定语言<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>COMMON LISP 与大多数其他编程环境一样，也有 <strong>sleep</strong> 函数 ，<strong>sleep</strong> 函数会让进程休眠 <strong>n</strong> 秒，其中 <strong>n</strong> 是一个非负数、非复杂的数字。 例如，想要休眠 3 分钟（180 秒的话），可以执行下面的语句：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sleep</span> <span class="mi">180</span><span class="p">)</span>
</pre></div>
</div>
<p>或者，如果喜欢以分钟为单位进行休眠的话，可以改为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sleep</span> <span class="p">(</span><span class="o">*</span> <span class="mi">3</span> <span class="mi">60</span><span class="p">))</span>
</pre></div>
</div>
<p>因为编译器知道如何折叠常量，所以上面两个调用都能正常执行。 为了更明确地说明我们在做什么，可以定义个 <strong>sleep-minutes</strong> 函数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">sleep</span><span class="o">-</span><span class="n">minutes</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="p">(</span><span class="n">sleep</span> <span class="p">(</span><span class="o">*</span> <span class="n">m</span> <span class="mi">60</span><span class="p">)))</span>
</pre></div>
</div>
<p>为想要使用的每个时间单位定义新函数既笨重又不方便。 我们需要的是某种抽象，可以指定时间单位和值。 我们真正需要的是一种特定领域的语言。</p>
<p>到目前为止，lisp 的解决方案与任何其他语言的解决方案相同：创建一个函数，该函数接受一个值和一个单位，并返回该值乘以与给定单位相关的某个常数。 但是当我们考虑代表这个单元的选项时，一个 lispy 改进变得很明显。 在像 C 这样的语言中，习惯上使用像 int 这样的底层数据类型并分配对应于不同单位的任意值：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define UNIT_SECONDS 1</span>
<span class="cp">#define UNIT_MINUTES 2</span>
<span class="cp">#define UNIT_HOURS 3</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">sleep_units</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">unit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">UNIT_SECONDS</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">UNIT_MINUTES</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="o">*</span><span class="mi">60</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">UNIT_HOURS</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="o">*</span><span class="mi">3600</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>​</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">sleep</span><span class="o">-</span><span class="n">units</span><span class="o">%</span> <span class="p">(</span><span class="n">value</span> <span class="n">unit</span><span class="p">)</span>
  <span class="p">(</span><span class="n">sleep</span>
    <span class="p">(</span><span class="o">*</span> <span class="n">value</span>
       <span class="p">(</span><span class="n">case</span> <span class="n">unit</span>
         <span class="p">((</span><span class="n">s</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">((</span><span class="n">m</span><span class="p">)</span> <span class="mi">60</span><span class="p">)</span>
         <span class="p">((</span><span class="n">h</span><span class="p">)</span> <span class="mi">3600</span><span class="p">)</span>
         <span class="p">((</span><span class="n">d</span><span class="p">)</span> <span class="mi">86400</span><span class="p">)</span>
         <span class="p">((</span><span class="n">ms</span><span class="p">)</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
         <span class="p">((</span><span class="n">us</span><span class="p">)</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)))))</span>
</pre></div>
</div>
<p>但在 lisp 中，最明显的方法就是使用符号来代表所需单元。 lisp 中的符号大部分与其他符号不相等。<strong>Eq</strong> 是最快的 lisp 比较运算符，大致对应于指针比较。 由于可以非常快速地比较指针，因此符号提供了一种非常快速和方便的方法来让两个或多个不同的 lisp 表达式知道指向同一个值。 在 lisp 中，可以定义 <strong>sleep-units%</strong> 函数，这样就能指定单位：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sleep</span><span class="o">-</span><span class="n">units</span><span class="o">%</span> <span class="mi">2</span> <span class="s1">&#39;m)</span>
<span class="p">(</span><span class="n">sleep</span><span class="o">-</span><span class="n">units</span><span class="o">%</span> <span class="mi">500</span> <span class="s1">&#39;us)</span>
</pre></div>
</div>
<p>因为比较符号只需要一个指针比较，<strong>sleep-units%</strong> 会编译成一个很快的运行时调度：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="mi">524</span><span class="p">:</span>       <span class="n">CMP</span>     <span class="n">ESI</span><span class="p">,</span> <span class="p">[</span><span class="c1">#x586FC4D0]    ; &#39;S</span>
<span class="mi">52</span><span class="n">A</span><span class="p">:</span>       <span class="n">JEQ</span>     <span class="n">L11</span>
<span class="mi">530</span><span class="p">:</span>       <span class="n">CMP</span>     <span class="n">ESI</span><span class="p">,</span> <span class="p">[</span><span class="c1">#x586FC4D4]    ; &#39;M</span>
<span class="mi">536</span><span class="p">:</span>       <span class="n">JEQ</span>     <span class="n">L10</span>
<span class="mi">538</span><span class="p">:</span>       <span class="n">CMP</span>     <span class="n">ESI</span><span class="p">,</span> <span class="p">[</span><span class="c1">#x586FC4D8]    ; &#39;H</span>
<span class="mi">53</span><span class="n">E</span><span class="p">:</span>       <span class="n">JEQ</span>     <span class="n">L9</span>
<span class="mi">540</span><span class="p">:</span>       <span class="n">CMP</span>     <span class="n">ESI</span><span class="p">,</span> <span class="p">[</span><span class="c1">#x586FC4DC]    ; &#39;D</span>
<span class="mi">546</span><span class="p">:</span>       <span class="n">JEQ</span>     <span class="n">L8</span>
<span class="o">...</span>
</pre></div>
</div>
<p>注意 <strong>sleep-units%</strong> 参数中的 uint 必须要引用。 因为当 lisp 执行函数时，它首先执行计算所有参数，然后将结果绑定到变量后再在函数内部使用。 数字和字符串以及其他原语会自动执行计算，这就是为什么不需要引用赋予 <strong>sleep-units%</strong> 的数值的原因。 但请注意，它们已被计算，因此只要愿意的话，都可以进行引用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sleep</span><span class="o">-</span><span class="n">units</span><span class="o">%</span> <span class="s1">&#39;.5 &#39;</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>然而，符号通常不会对自己进行计算<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">1</a>。当 lisp 计算执行符号时，会假定正在引用一个变量并尝试在给定的词法上下文的情况下查找与该变量关联的值（除非该变量被声明为特殊的，在这种情况下是动态环境）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro sleep-units (value unit)
  `(sleep
     (* ,value
        ,(case unit
           ((s) 1)
           ((m) 60)
           ((h) 3600)
           ((d) 86400)
           ((ms) 1/1000)
           ((us) 1/1000000)))))
</pre></div>
</div>
<p>为了避免引用单位，我们需要一个宏。 与函数不同，宏不计算其参数。 利用这一事实，我们将  <strong>sleep-units%</strong> 函数换成 <strong>sleep-units</strong> 宏。 现在就不需要引用单位：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sleep</span><span class="o">-</span><span class="n">units</span> <span class="mf">.5</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>虽然这个宏的主要目的是避免引用 <strong>unit</strong> 参数，但这个宏甚至比函数更高效，因为根本没有运行时调度：单位和乘数在编译时是已知的。 当然，每当发现这种好得令人难以置信的情况时，它可能真的好得令人难以置信。 这种效率提升并不是免费的。 通过前面的运行时调度，我们失去了在运行时确定时间单位的能力。 这让这个宏无法执行以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">sleep</span><span class="o">-</span><span class="n">units</span> <span class="mi">1</span> <span class="p">(</span><span class="k">if</span> <span class="nb">super</span><span class="o">-</span><span class="n">slow</span><span class="o">-</span><span class="n">mode</span> <span class="s1">&#39;d &#39;</span><span class="n">h</span><span class="p">))</span>
</pre></div>
</div>
<p>上面这段代码将无法执行，因为 <strong>sleep-units</strong> 第二个参数要是 case 语句中的符号，而是上面代码中是个列表，其中第一个元素是符号 <strong>if</strong>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro unit-of-time (value unit)
  `(* ,value
      ,(case unit
         ((s) 1)
         ((m) 60)
         ((h) 3600)
         ((d) 86400)
         ((ms) 1/1000)
         ((us) 1/1000000))))
</pre></div>
</div>
<p>回想一下，大多数宏都是为了创建更方便和有用的编程抽象而编写的，而不是为了提高底层代码的效率。 是否可以从这段代码中提取任何习语，使其对程序的其余部分（以及可能的其他未来程序）更有用？ 即使是现在，我们也可以预见想要用时间值做其他事情，而不仅仅是调用它们休眠。 时间单位宏从 <strong>sleep-units</strong> 宏中抽象出功能，返回一个值而不是对其调用 <strong>sleep</strong>。<strong>value</strong> 参数可以在运行时确定，因为它会被计算，但 <strong>unit</strong> 不能，因为在编译时需要这个信息，就像 <strong>sleep-units</strong> 一样。 以下是示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">unit</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">time</span> <span class="mi">1</span> <span class="n">d</span><span class="p">)</span>

<span class="mi">86400</span>
</pre></div>
</div>
<p>像 <strong>unit-of-time</strong> 这样简单的宏为解决特定领域的问题提供了更好的语法，并且可以带来显著的生产力和正确性优势。 我们将在<a class="reference internal" href="../Chapter05/5.2-top-down-programming.html"><span class="doc std std-doc">第 5.2 节：自上而下编程</span></a> 中继续开发这种单元语言。 与大多数编程语言不同，lisp 为创建编程环境的人提供了相同的工具。 宏足以实现 COMMON LISP 语言，也足以实现领域特定语言。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3.1-iterative-development.html" class="btn btn-neutral float-left" title="3.1 迭代开发" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="3.3-control-structures.html" class="btn btn-neutral float-right" title="3.3 控制结构" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>