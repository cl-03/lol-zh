

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>7.2 宏让 Lisp 更快 &mdash; Let Over Lambda 中文文档 V0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="7.3 了解你的反汇编器" href="disassembler.html" />
    <link rel="prev" title="7.1 Lisp 很快" href="lisp-is-fast.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第七章：宏的效率</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lisp-is-fast.html">7.1 Lisp 很快</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">7.2 宏让 Lisp 更快</a></li>
<li class="toctree-l2"><a class="reference internal" href="disassembler.html">7.3 了解你的反汇编器</a></li>
<li class="toctree-l2"><a class="reference internal" href="pointer-scope.html">7.4 指针作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="tlists-cons-pools.html">7.5 Tlists and Cons Pools</a></li>
<li class="toctree-l2"><a class="reference internal" href="sorting-networks.html">7.6 Sorting Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing-benchmarking.html">7.7 Writing and Benchmarking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 的变迁</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第七章：宏的效率</a> &raquo;</li>
        
      <li>7.2 宏让 Lisp 更快</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Chapter07/macros-make-lisp-fast.rst.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lisp">
<span id="macros-make-lisp-fast"></span><h1>7.2 宏让 Lisp 更快<a class="headerlink" href="#lisp" title="永久链接至标题">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Doug Hoyte</p>
</dd>
<dt class="field-even">Translator</dt>
<dd class="field-even"><p>Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<p>本节展示了用三种类型的宏来协助创建高效程序的示例：常规宏、读取宏和这里介绍的新类型宏 —— 编译宏。</p>
<p>宏可以用来控制算法、数据结构、类型检查、安全检查、代码或部分代码的优化级别等等。我们可以在一个程序（甚至函数）中同时存在安全和通用的代码，也可以同时存在执行快和危险的代码。简而言之，没有任何一种语言提供了像 lisp 这样的开放接口来控制编译器，这都要归功于宏（不然还能是什么呢？）。大概浏览下 ANSI 标准会发现标准里看起来是说：宏和声明（与编译器沟通的最直接方式）不能很好地协同工作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>宏结构不能展开成声明；声明表达式必须以它们所引用结构的实际子表达式的形式出现。
</pre></div>
</div>
<p>ANSI 的意思是，下面的宏不会按预期工作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro go-fast () ; Broken!
  &#39;(declare (optimize (speed 3) (safety 0))))
</pre></div>
</div>
<p>我们不能把宏调用放在需要声明的地方。这个问题的另一种思考角度是，在检查声明之前，系统的代码遍历程序不需要展开特殊结构主体中的宏。想要执行得快是件很常见的事情，所以也许可以做得比上面有问题的 <code class="docutils literal notranslate"><span class="pre">go-fast</span></code> 宏更好。想要尽可能多地压缩含义时，通常需要一个读宏。读宏也适合展开成声明，因为它们在代码遍历程序尝试遍历代码之前就展开了。它们是以实际的子表达式读入的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(set-dispatch-macro-character #\# #\f
  (lambda (stream sub-char numarg)
    (declare (ignore stream sub-char))
    (setq numarg (or numarg 3))
    (unless (&lt;= numarg 3)
      (error &quot;Bad value for #f: ~a&quot; numarg))
    `(declare (optimize (speed ,numarg)
                        (safety ,(- 3 numarg))))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#f</span></code> 是个读宏，能控制 COMMON LISP 程序最重要的性能权衡：声明的速度和安全之间的平衡。例如，<code class="docutils literal notranslate"><span class="pre">#f</span></code> 本身读取的是我们希望 <code class="docutils literal notranslate"><span class="pre">go-fast</span></code> 扩展的内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="s1">&#39;#f</span>
<span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
<p>但是，我们可以改变这一点，并将一个小于 3 的数作为 reader number 参数来声明安全高于速度。所有的调度读宏都可以接受这样一个数字参数，它作为第三个参数（通常称为 <code class="docutils literal notranslate"><span class="pre">numarg</span></code>）传递给 read 宏函数。下面是个体现我们重视安全而不是速度的例子，将 SPEED 的参数设为 0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="s1">&#39;#0f</span>
<span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>也可以设置为 1 和 2，从而产生以下声明。这些不同的声明设置的优点非常依赖于编译器，所以你几乎不会使用它们:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="s1">&#39;(#1f #2F)</span>
<span class="p">((</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</div>
<p>尽管宏不能直接扩展为声明，但我们仍然可以使用常规宏来控制声明。因为代码遍历程序在展开宏之前不能遍历宏结构来搜索声明，所以无法判断该声明是编写结构的实际子表达式，还是宏在展开时添加了声明。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro fast-progn (&amp;rest body)
  `(locally #f ,@body))

(defmacro safe-progn (&amp;rest body)
  `(locally #0f ,@body))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fast-progn</span></code> 和 <code class="docutils literal notranslate"><span class="pre">safe-progn</span></code> 是一些展开的结构中包含声明的简单例子。请注意，这里使用的是 <code class="docutils literal notranslate"><span class="pre">locally</span></code> 的隐式 progn 而不是 <code class="docutils literal notranslate"><span class="pre">progn</span></code> 本身，因为 <code class="docutils literal notranslate"><span class="pre">progn</span></code> 中不能有声明。这两个宏用了之前定义的 <code class="docutils literal notranslate"><span class="pre">#f</span></code> 读宏。我们可以使用这些结构作为 <code class="docutils literal notranslate"><span class="pre">progn</span></code> 的一个版本，其中内部表达式对执行速度进行了优化(但很危险)，另一个版本确保内部表达式是安全的(可能很慢)：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(fast-progn</span>
      <span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="n">LOCALLY</span>
  <span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="n">T</span>
</pre></div>
</div>
<p>我们还可以在宏参数中提供其他声明，因为它们的位置不是也不能在宏展开之前验证：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(fast-progn</span>
      <span class="p">(</span><span class="n">declare</span> <span class="p">(</span><span class="nb">type</span> <span class="n">fixnum</span> <span class="n">a</span><span class="p">))</span>
      <span class="p">(</span><span class="n">the</span> <span class="n">fixnum</span> <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="n">LOCALLY</span>
  <span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">TYPE</span> <span class="n">FIXNUM</span> <span class="n">A</span><span class="p">))</span>
  <span class="p">(</span><span class="n">THE</span> <span class="n">FIXNUM</span> <span class="p">(</span><span class="o">+</span> <span class="n">A</span> <span class="mi">1</span><span class="p">)))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>在尝试宏扩展时，有时会想看看在将宏扩展嵌入不同的词法上下文时会发生什么。将 <a class="reference internal" href="../Chapter04/runtime.html"><span class="doc">4.1 Run-Time at Read-Time</span></a> 中的读取时计算宏与 <code class="docutils literal notranslate"><span class="pre">*</span></code> 变量（保持最后三个REPL结果可用）结合起来，可以看到我们的代码的计算结果如预期的那样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">a</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1">#.*)</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>但是请注意，尽管上面的计算是正确的，但是声明有时只对编译后的代码进行充分考虑。例如，由于上面的计算解释了代码，它可能会忽略安全声明，并继续将溢出结果提升为大数（ <em>bignum</em> ）。来看看这里是否会发生这种情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">a</span> <span class="n">most</span><span class="o">-</span><span class="n">positive</span><span class="o">-</span><span class="n">fixnum</span><span class="p">))</span>
    <span class="c1">#.**)</span>
<span class="mi">536870912</span>
</pre></div>
</div>
<p>确实会将溢出结果提升为大数，CMUCL忽略了解释代码的声明。我们想在 <code class="docutils literal notranslate"><span class="pre">***</span></code> 中继续玩我们的表达式，但由于不确定下次是否能得到它，就把它带回 * ，这样就不会丢失表达式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">***</span>
<span class="p">(</span><span class="n">LOCALLY</span>
  <span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">OPTIMIZE</span> <span class="p">(</span><span class="n">SPEED</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">SAFETY</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">TYPE</span> <span class="n">FIXNUM</span> <span class="n">A</span><span class="p">))</span>
  <span class="p">(</span><span class="n">THE</span> <span class="n">FIXNUM</span> <span class="p">(</span><span class="o">+</span> <span class="n">A</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<p>就是这样。所以现在有三次机会让它工作。试试编译它，看下会不会得到个 <em>fixnum</em> 的封装：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (funcall
    (compile nil
      `(lambda ()
        (let ((a most-positive-fixnum))
,*))))
; Warning: This is not a (VALUES FIXNUM &amp;REST T):
;   536870912
536870912
</pre></div>
</div>
<p>Emm，到底发生了呢？我们不是告诉 lisp 不要检查吗？像常量折叠这样的编译时优化让声明的推导更复杂。当 lisp 编译代码时，它能够在编译时执行加法，因为我们添加的是常量，因此它知道结果也将是常量，所以就没必要在运行时计算它。当 lisp 这样做的时候，它看到我们对一个 fixnum 的声明肯定是错误的。这个警告是用 lisp 的方式告诉我们“你这个笨蛋，我无视你的声明，因为你不可信。”如果稍微改变一下表达式，让 lisp 不能折叠任何常量，最终可以看到 <em>fixnum</em> 封装的效果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (funcall
    (compile nil
`(lambda (a)
7.2. MACROS MAKE LISP FAST 215
        ,**))
    most-positive-fixnum)
-536870912
</pre></div>
</div>
<p>声明的另一个重要属性是，它们可以像词法变量可以遮蔽其他词法变量一样遮蔽其他声明。例如，我们可能希望编写个宏来执行安全检查，即便是被嵌入到声明为不安全的代码中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro error-checker ()
  `(safe-progn
    (declare (type integer var))
    do-whatever-other-error-checking))
</pre></div>
</div>
<p>再封装一层，我们可以用这些宏来添加错误检查代码，这些代码需要执行的比较快而不是比较安全，通过嵌套这些宏的其他用法来实现：<code class="docutils literal notranslate"><span class="pre">fast-progn</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">wrapped</span><span class="o">-</span><span class="n">operation</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">safe</span><span class="o">-</span><span class="n">progn</span>
    <span class="n">do</span><span class="o">-</span><span class="n">whatever</span><span class="o">-</span><span class="n">error</span><span class="o">-</span><span class="n">checking</span>
    <span class="p">(</span><span class="n">fast</span><span class="o">-</span><span class="n">progn</span>
      <span class="n">but</span><span class="o">-</span><span class="n">this</span><span class="o">-</span><span class="n">needs</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">go</span><span class="o">-</span><span class="n">fast</span><span class="p">)))</span>
</pre></div>
</div>
<p>在高性能lisp代码中，使用围绕某些功能的快速实现的错误检查区域安全地验证参数是一种常见模式。特别是对于数组遍历这样的迭代过程，可以通过在操作开始前进行类型和边界检查等错误检查，然后在执行时尽可能地忽略它们，从而显著提高运行时性能。</p>
<p>COMMON LISP 首先是为了强大的编程能力而设计的；效率是个较远的次要问题。然而，这些功能、功率和效率并不一定代表一种权衡。通过宏，我们可以应用 lisp 强大功能来解决效率问题。除了常规宏和读取宏（它们本身已经提供了相当强大的功能）之外，COMMON LISP还提供了编译宏。编译宏是与其他类型宏相同意义上的宏：它们是编程的程序。大多数lisp教程都没有很好地描述编译器宏，这表明性能对于程序员来说是多么重要（几乎从来没有）。然而，编译宏是某些效率问题的优雅解决方案，值得成为每个lisp专业人员的工具包。</p>
<p>编译宏定义了 lisp 编译器将应用于（命名）函数调用的转换。这意味着可以使用 <code class="docutils literal notranslate"><span class="pre">defun</span></code> 创建的函数，并告诉 lisp 不要编译对该函数的调用，而是应该编译编译宏指示的一些代码。为什么要将函数与编译宏结合使用，而不是一开始就用这个名字编写宏呢？第一个不太重要的原因是，这让我们能够更多地控制何时吸收编译开销。特别的是，COMMON LISP并没有指定何时或者多长时间扩展一个宏。在解释代码中，宏每次被调用时都有可能被展开。在进行编译时优化时，我们希望在运行函数之前执行一个（可能很长且昂贵的）计算，以减少函数本身必须执行的计算量。编译宏为我们提供了一种方法，当我们编译代码时，只执行一次冗长的编译计算 —— 它本该是这样的。</p>
<p>但比只在正确的时间执行一次编译计算更重要的是，编译宏很有用，因为它们将语法的二元性引入语言。编译宏允许我们为任何表示（命名）函数调用的代码结构添加双重含义。除了常规意义外，编译器宏还添加了编译意义。强烈推荐确保编译后的含义实现与常规含义任务相同，但可以随意改变它的执行方式（这是重点）。使用双重语法的好处是，可以改变代码的效率，而不需要修改代码。我们可以使用一个现有的代码库 —— 一个可能使用了大量函数调用的代码 —— 并通过引入双重语法来改变代码的编译方式。我们所要做的就是找到代价很高的函数调用，然后实现编译器宏，将它们转换为代价低的展开。</p>
<p>哪种类型的函数调用开销高呢？作为第一个例子，回想一下 <a class="reference internal" href="../Chapter04/reader-security.html"><span class="doc">4.6 Reader Security</span></a> 中，函数可以执行 lambda 析构，而且这是更通用的 defmacro 析构的子集。当函数接受关键字参数时，我们将它们作为分组的关键字符号对及其对应的值进行传递。关键字参数非常有用，但遗憾的是，使用关键字参数的函数比不使用关键字参数的函数调用开销更大。解构不是免费的。编译器需要将代码编译到函数中，该函数扫描必要的可变长度参数列表，以正确的顺序获取值(包括插入默认值)，然后实际执行函数。一般来说，lisp编译这些关键字参数的代码非常快，所以我们几乎从不注意（或关心）这种低效率。然而，在某些情况下，我们确实会关心这个问题，特别是当我们在性能关键的循环中调用这样的函数时。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">fast</span><span class="o">-</span><span class="n">keywords</span><span class="o">-</span><span class="n">strip</span> <span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="n">args</span>
    <span class="p">(</span><span class="n">cond</span>
      <span class="p">((</span><span class="n">eq</span> <span class="p">(</span><span class="n">car</span> <span class="n">args</span><span class="p">)</span> <span class="s1">&#39;&amp;key)</span>
        <span class="p">(</span><span class="n">fast</span><span class="o">-</span><span class="n">keywords</span><span class="o">-</span><span class="n">strip</span> <span class="p">(</span><span class="n">cdr</span> <span class="n">args</span><span class="p">)))</span>
      <span class="p">((</span><span class="n">consp</span> <span class="p">(</span><span class="n">car</span> <span class="n">args</span><span class="p">))</span>
        <span class="p">(</span><span class="n">cons</span> <span class="p">(</span><span class="n">caar</span> <span class="n">args</span><span class="p">)</span>
              <span class="c1">#1=(fast-keywords-strip</span>
                  <span class="p">(</span><span class="n">cdr</span> <span class="n">args</span><span class="p">))))</span>
      <span class="p">(</span><span class="n">t</span>
        <span class="p">(</span><span class="n">cons</span> <span class="p">(</span><span class="n">car</span> <span class="n">args</span><span class="p">)</span> <span class="c1">#1#)))))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fast-keys-strip</span></code> 是个实用程序，它接受由常规参数和关键字参数组成的 lambda 解构列表，并返回用于引用这些参数的符号列表。换句话说，当传递 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&amp;key</span> <span class="pre">b</span> <span class="pre">(c</span> <span class="pre">0))</span></code> 时，程序返回 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c)</span></code> ，但是传给程序 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&amp;optional</span> <span class="pre">b</span> <span class="pre">c)</span></code> 是不行的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! defun-with-fast-keywords
          (name args &amp;rest body)
  `(progn
      (defun ,name ,args ,@body)
      (defun ,g!fast-fun
            ,(fast-keywords-strip args)
            ,@body)
      (compile &#39;,g!fast-fun)
      (define-compiler-macro ,name (&amp;rest ,g!rest)
        (destructuring -bind ,args ,g!rest
          (list &#39;,g!fast -fun ,@(fast-keywords-strip args))))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defun-with-fast-keywords</span></code> 用法与 <code class="docutils literal notranslate"><span class="pre">defun</span></code> 相同。与 <code class="docutils literal notranslate"><span class="pre">defun</span></code> 类似，<code class="docutils literal notranslate"><span class="pre">defaun-with-fast-keywords</span></code> 的第一个参数是命名函数的符号，第二个参数是参数列表，其余的是定义要执行的函数的形式。然而，与 <code class="docutils literal notranslate"><span class="pre">defun</span></code> 不同的是，<code class="docutils literal notranslate"><span class="pre">defun-with-fast-keywords</span></code> 结构只能给出常规参数和关键字参数（没有 optional，rests 等）。练习：扩展 <code class="docutils literal notranslate"><span class="pre">fast-keywords-strip</span></code> 来处理所有的 lambda 解构列表。</p>
<p><code class="docutils literal notranslate"><span class="pre">defun-with-fast-keywords</span></code> 的展开非常复杂。它展开成三种结构。第一种展开对函数的定义和常规的 <code class="docutils literal notranslate"><span class="pre">defun</span></code> 函数一样。第二种展开将函数定义了一个名为 <code class="docutils literal notranslate"><span class="pre">g!fast-fun</span></code> 的函数。这个函数类似于第一个函数，除了对每个参数（是否关键字）接受一个非关键字参数。接下来定义一个编译器宏来将对第一个函数的调用转换为对第二个函数的调用。因此，我们不是让第一个函数执行关键字解构，而是利用调用函数的格式的编译时知识，并使用解构绑定将关键字按正确的顺序放在一起。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span>
  <span class="n">slow</span><span class="o">-</span><span class="n">keywords</span><span class="o">-</span><span class="n">test</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">key</span> <span class="p">(</span><span class="n">c</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">d</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="p">))</span>

<span class="p">(</span><span class="nb">compile</span> <span class="s1">&#39;slow-keywords-test)</span>

<span class="p">(</span><span class="n">defun</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">fast</span><span class="o">-</span><span class="n">keywords</span>
  <span class="n">fast</span><span class="o">-</span><span class="n">keywords</span><span class="o">-</span><span class="n">test</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">key</span> <span class="p">(</span><span class="n">c</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">d</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="p">))</span>
</pre></div>
</div>
<p>现在我们有了一个（几乎）双重语法 <code class="docutils literal notranslate"><span class="pre">defun</span></code>。带有关键字参数的函数的常规定义类似于 <code class="docutils literal notranslate"><span class="pre">slow-keyword-test</span></code>。编译它是为了下面的基准测试。<code class="docutils literal notranslate"><span class="pre">fast-keywords-test</span></code> 与 <code class="docutils literal notranslate"><span class="pre">slow-keywords-test</span></code> 的写法相同，只是用的是 <code class="docutils literal notranslate"><span class="pre">defun-with-fast-keywords</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">defun</span></code>。事实证明，我们不需要编译这个函数，因为 <code class="docutils literal notranslate"><span class="pre">defun-with-fast-keywords</span></code> 展开为一个调用，只对其中一个需要它的定义进行编译 —— 自动的 gensym <code class="docutils literal notranslate"><span class="pre">g!fast-fun</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">keywords</span><span class="o">-</span><span class="n">benchmark</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="n">t</span> <span class="s2">&quot;Slow keys: ~%&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="n">time</span>
    <span class="p">(</span><span class="n">loop</span> <span class="k">for</span> <span class="n">i</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="n">do</span>
      <span class="p">(</span><span class="n">slow</span><span class="o">-</span><span class="n">keywords</span><span class="o">-</span><span class="n">test</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">:</span><span class="n">d</span> <span class="mi">3</span> <span class="p">:</span><span class="n">c</span> <span class="n">n</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="n">t</span> <span class="s2">&quot;Fast keys: ~%&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="n">time</span>
    <span class="p">(</span><span class="n">loop</span> <span class="k">for</span> <span class="n">i</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="n">do</span>
      <span class="p">(</span><span class="n">fast</span><span class="o">-</span><span class="n">keywords</span><span class="o">-</span><span class="n">test</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">:</span><span class="n">d</span> <span class="mi">3</span> <span class="p">:</span><span class="n">c</span> <span class="n">n</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">compile</span> <span class="s1">&#39;keywords-benchmark)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">keywords-benchamrk</span></code> 是个简单的函数，其中使用了 <code class="docutils literal notranslate"><span class="pre">time</span></code> 宏来告诉我们对这两个函数进行等价的一系列调用需要多长时间。注意，我们还编译了 <code class="docutils literal notranslate"><span class="pre">keywords-benchmark</span></code>。关于基准测试的更多内容将在 <a class="reference internal" href="writing-benchmarking.html"><span class="doc">7.7 Writing and Benchmarking</span></a> 中介绍。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">keywords</span><span class="o">-</span><span class="n">benchmark</span> <span class="mi">100000000</span><span class="p">)</span>
<span class="n">Slow</span> <span class="n">keys</span><span class="p">:</span>
<span class="p">;</span> <span class="n">Evaluation</span> <span class="n">took</span><span class="p">:</span>
<span class="p">;</span>   <span class="mf">17.68</span> <span class="n">seconds</span> <span class="n">of</span> <span class="n">real</span> <span class="n">time</span>
<span class="n">Fast</span> <span class="n">keys</span><span class="p">:</span>
<span class="p">;</span> <span class="n">Evaluation</span> <span class="n">took</span><span class="p">:</span>
<span class="p">;</span>   <span class="mf">10.03</span> <span class="n">seconds</span> <span class="n">of</span> <span class="n">real</span> <span class="n">time</span>
</pre></div>
</div>
<p>调用这个函数1亿次足以让我们看到，即使两个函数都被编译了，使用 <code class="docutils literal notranslate"><span class="pre">defun-with-fast-keywords</span></code> 定义的函数运行速度也比它的编译宏快了 40% 左右。还要注意的是，编译宏的性能并不依赖于关键字参数是在编译时已知的常量。注意，我们传递了 <code class="docutils literal notranslate"><span class="pre">n</span></code>，一种不同的 lisp 结构，作为 <code class="docutils literal notranslate"><span class="pre">:c</span></code> 关键字的参数。因此，编译宏将快速版本展开为与慢版本相同的版本，除了没有关键字的析构开销。</p>
<p>那么，为什么 COMMON LISP 不为每个接受关键字的函数都这样做，并总是避免开销呢？编译宏只在编译时应用，但我们希望在运行时保留对参数进行解构的能力。下面是关于编译宏的要点：编译宏是对函数调用的优化，而不是对函数本身的优化。在关键字的情况下，编译宏允许我们消除对函数的编译调用的开销，同时仍然让原始函数（及其关键字解构代码）在运行时可用。编译宏为我们提供了两种不同操作的双重语法，这两种操作只能通过上下文来区分。另一种避免关键字开销的方法，请参阅 Norvig’s PAIP (PAIP-P323)。</p>
<p>还有哪些函数调用可以从编译宏中受益？我们不仅可以减少析构开销，而且通常还可以通过预处理常量参数来减少函数本身的开销。编译宏可以在编译时执行一些准备工作，因此不必在运行时执行。其中最明显的例子是 <code class="docutils literal notranslate"><span class="pre">format</span></code> 函数。想想 <code class="docutils literal notranslate"><span class="pre">format</span></code> （或者，在 C 语言中，<code class="docutils literal notranslate"><span class="pre">printf</span></code> ）是如何工作的。它是个在运行时将控制字符串传递给它的函数。然后 <code class="docutils literal notranslate"><span class="pre">format</span></code> 处理控制字符串并将格式化后的输出打印到流中（或将其作为字符串返回）。实际上，在使用 <code class="docutils literal notranslate"><span class="pre">format</span></code> 时，使用控制字符串作为程序对格式字符串解释器进行函数调用。使用编译宏，可以消除函数调用，预处理控制字符串，并将函数调用更改为与调用站点相连接的专门代码，编译器可以在其中进行进一步优化。听起来很难，不是吗？我们必须知道如何将格式控制字符串转换成等价的 lisp 代码。幸运的是，与许多其他事情一样，COMMON LISP 已经考虑过这个问题。COMMON LISP 对格式化的处理是正确的。这是它为创建格式化输出而指定的特定于领域的语言，可以将自己宏编译为 lisp 代码。这是 lisp 哲学的一部分 —— 所有的东西都应该编译成 lisp。将控制字符串编译为 lisp 的宏是 <code class="docutils literal notranslate"><span class="pre">formatter</span></code>。当把控制字符串提供给 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 时，它将展开为执行所需格式化的 lambda 结构。例如，下面是个简单控制字符串的展开：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span> <span class="s1">&#39;(formatter &quot;Hello ~a~%&quot;))</span>
<span class="c1">#&#39;(LAMBDA (STREAM &amp;OPTIONAL</span>
                  <span class="p">(</span><span class="c1">#:FORMAT-ARG-1783</span>
                    <span class="p">(</span><span class="n">ERROR</span> <span class="s2">&quot;Missing arg&quot;</span><span class="p">))</span>
                  <span class="o">&amp;</span><span class="n">REST</span> <span class="n">FORMAT</span><span class="p">::</span><span class="n">ARGS</span><span class="p">)</span>
    <span class="p">(</span><span class="n">BLOCK</span> <span class="n">NIL</span>
      <span class="p">(</span><span class="n">WRITE</span><span class="o">-</span><span class="n">STRING</span> <span class="s2">&quot;Hello &quot;</span> <span class="n">STREAM</span><span class="p">)</span>
      <span class="p">(</span><span class="n">PRINC</span> <span class="c1">#:FORMAT-ARG-1783 STREAM)</span>
      <span class="p">(</span><span class="n">TERPRI</span> <span class="n">STREAM</span><span class="p">))</span>
    <span class="n">FORMAT</span><span class="p">::</span><span class="n">ARGS</span><span class="p">)</span>
<span class="n">T</span>
</pre></div>
</div>
<p>所以说 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 展开成了个 lambda 结构。将控制字符串编译成 lisp 结构代码，适合于求值或将宏嵌入到其他 lisp 代码中，在那里它将成为一个编译函数或内联到调用站点的编译代码中。但是请注意，<code class="docutils literal notranslate"><span class="pre">formatter</span></code> 的展开必须要接受一个流，不能像 <code class="docutils literal notranslate"><span class="pre">format</span></code> 那样可以接受 <code class="docutils literal notranslate"><span class="pre">nil</span></code>。这是因为 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 展开的函数（如 <code class="docutils literal notranslate"><span class="pre">write-string</span></code> 和 <code class="docutils literal notranslate"><span class="pre">terpri</span></code> ）需要流。可以用 <code class="docutils literal notranslate"><span class="pre">with-output-to-string</span></code> 宏来解决这个问题。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun fformat (&amp;rest all)
  (apply #&#39;format all))

(compile &#39;fformat)

(define-compiler-macro fformat
                      (&amp; whole form
                        stream fmt &amp;rest args)
  (if (constantp fmt)
    (if stream
      `(funcall (formatter ,fmt)
        ,stream ,@args)
      (let ((g!stream (gensym &quot;stream&quot;)))
        `(with-output-to-string (,g!stream)
          (funcall (formatter ,fmt)
            ,g!stream ,@args))))
    form ))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fformat</span></code> 是个完全透明的 <code class="docutils literal notranslate"><span class="pre">format</span></code> 封装器。 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 的存在是为了定义一个编译宏来进行格式化。我们需要一个新的函数名，因为在 COMMON LISP 指定的函数上定义编译宏是不行的。我们的编译宏利用了 defmacro 的解构特性：&amp;whole。我们使用它将 <code class="docutils literal notranslate"><span class="pre">format</span></code> 绑定到宏调用的实际列表结构。这样做是为了利用编译宏的一个特性：编译宏完全可以选择不展开。如果我们返回 <code class="docutils literal notranslate"><span class="pre">form</span></code> ，lisp 会发现我们只是返回传递的 form（用 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 检查），同时 lisp 也将要求编译宏不对 form 进一步展开 —— 即便是我们正用编译宏展开成个函数的用法。在编译时，我们选择使用 form 的另一种含义。这是编译宏和普通宏之间的根本区别。编译宏可以与函数共享精确的双重语法，但普通宏不能。在 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 中，当它的控制字符串参数不是常量时，编译宏不展开为更有效的含义。在 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 中，我们仍然希望对非字符串控制字符串（比如返回字符串的函数调用）调用 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 来工作。换句话说，我们仍然希望能够在运行时生成控制字符串。这样的调用显然不能对控制字符串使用编译时优化。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">fformat</span><span class="o">-</span><span class="n">benchmark</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="n">t</span> <span class="s2">&quot;Format:~%&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="n">time</span>
    <span class="p">(</span><span class="n">loop</span> <span class="k">for</span> <span class="n">i</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="n">do</span>
      <span class="p">(</span><span class="nb">format</span> <span class="n">nil</span> <span class="s2">&quot;Hello ~a ~a~%&quot;</span> <span class="s1">&#39;world n)))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="n">t</span> <span class="s2">&quot;Fformat:~%&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="n">time</span>
    <span class="p">(</span><span class="n">loop</span> <span class="k">for</span> <span class="n">i</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="n">do</span>
      <span class="p">(</span><span class="n">fformat</span> <span class="n">nil</span> <span class="s2">&quot;Hello ~a ~a~%&quot;</span> <span class="s1">&#39;world n))))</span>
<span class="p">(</span><span class="nb">compile</span> <span class="s1">&#39;fformat -benchmark)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">format-benchmark</span></code> 与前面介绍的 <code class="docutils literal notranslate"><span class="pre">keywords-benchmark</span></code> 函数几乎相同。它使用 <code class="docutils literal notranslate"><span class="pre">time</span></code> 来比较使用常规 <code class="docutils literal notranslate"><span class="pre">format</span></code> 和新的 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 执行大量格式操作所需的时间。以下是 100 万次迭代的结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">fformat</span><span class="o">-</span><span class="n">benchmark</span> <span class="mi">1000000</span><span class="p">)</span>
<span class="n">Format</span><span class="p">:</span>
<span class="p">;</span> <span class="n">Evaluation</span> <span class="n">took</span><span class="p">:</span>
<span class="p">;</span>   <span class="mf">37.74</span> <span class="n">seconds</span> <span class="n">of</span> <span class="n">real</span> <span class="n">time</span>
<span class="p">;</span>   <span class="p">[</span><span class="n">Run</span> <span class="n">times</span> <span class="n">include</span> <span class="mf">4.08</span> <span class="n">seconds</span> <span class="n">GC</span> <span class="n">run</span> <span class="n">time</span><span class="p">]</span>
<span class="p">;</span>   <span class="mi">1</span><span class="p">,</span><span class="mi">672</span><span class="p">,</span><span class="mi">008</span><span class="p">,</span><span class="mi">896</span> <span class="nb">bytes</span> <span class="n">consed</span><span class="o">.</span>
<span class="n">Fformat</span><span class="p">:</span>
<span class="p">;</span> <span class="n">Evaluation</span> <span class="n">took</span><span class="p">:</span>
<span class="p">;</span> <span class="p">;</span> <span class="p">;</span>
<span class="mf">26.79</span> <span class="n">seconds</span> <span class="n">of</span> <span class="n">real</span> <span class="n">time</span>
<span class="p">[</span><span class="n">Run</span> <span class="n">times</span> <span class="n">include</span> <span class="mf">3.47</span> <span class="n">seconds</span> <span class="n">GC</span> <span class="n">run</span> <span class="n">time</span><span class="p">]</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">408</span><span class="p">,</span><span class="mi">007</span><span class="p">,</span><span class="mi">552</span> <span class="nb">bytes</span> <span class="n">consed</span><span class="o">.</span>
</pre></div>
</div>
<p>大概提升了 30%。编译宏不仅减少了执行格式化所需的时间，而且还减少了开销（这反过来又减少了垃圾回收的时间）。编译宏避免了在运行时解释格式字符串，而是在函数被编译时只执行一次大部分的计算 —— 这是它本该做的。不幸的是，基准测试常常模糊或删除重要的细节。虽然用 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 预编译格式字符串可以消除解释开销，但这样做的代价是编译一个更大的程序。即使主存充足，较大的代码也会因为指令缓存性能的降低而运行得更慢。</p>
<p>在本节中，我们讨论了使用常规宏、读取宏和专为这个任务设计的一种特殊类型的宏 —— 编译宏来定制代码性能的方法。希望本节和本章的其余部分能说服你，如果想编写真正有效的代码，就需要 COMMON LISP。因为宏，你需要 COMMON LISP。</p>
<p>练习1：下载 Edi Weitz 的 CL-PPCRE（在 <a class="reference internal" href="../Chapter04/cl-ppcre.html"><span class="doc">4.4 CL-PPCRE</span></a> 中），看看 <code class="docutils literal notranslate"><span class="pre">api.lisp</span></code> 怎么使用编译宏。访问Edi 的网站并下载一些他的 lisp 包，这些包看起来很有趣。</p>
<p>练习2：当我们为 <code class="docutils literal notranslate"><span class="pre">fformat</span></code> 编写编译宏时，我们被迫显式地使用 <code class="docutils literal notranslate"><span class="pre">gensym</span></code>，因为没有 <code class="docutils literal notranslate"><span class="pre">define-compiler-macro!</span></code> 宏。解决这个问题。</p>
<p>较难的练习：定义 <code class="docutils literal notranslate"><span class="pre">define-compiler-macro!</span></code> 这样就能使用了 <code class="docutils literal notranslate"><span class="pre">defmacro!</span></code> 的功能而不用调用 <code class="docutils literal notranslate"><span class="pre">gensym</span></code>。提示：跳出思维定势。</p>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="disassembler.html" class="btn btn-neutral float-right" title="7.3 了解你的反汇编器" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="lisp-is-fast.html" class="btn btn-neutral float-left" title="7.1 Lisp 很快" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, Yuqi Liu, Xuting Yang.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>