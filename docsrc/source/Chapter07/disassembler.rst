.. _disassembler:

======================================
7.3 了解你的反汇编器
======================================

:Author: Doug Hoyte
:Translator: Yuqi Liu <yuqi.lyle@outlook.com>

如果不检查处理器为不同的 lisp 结构执行的原始指令，就很难真正了解在 lisp 中那些代码的开销昂贵。就像在编写宏时，查看它们的展开通常很有帮助，有时查看lisp 程序编译后的展开（通常是汇编指令）也很有用。因为 lisp 编译器可以并且经常被认为是宏扩展器，它们生成的机器码，从某种奇怪的意义上说，本身就是 lisp 代码。因为 lisp 与其说是一种语言，不如说是一种创建语言的构建材料和结构，lisp 是用来定义和编译一种恰好与处理器指令集相同的语言。

COMMON LISP 提供了一个名为 ``disassemble`` 的函数来查看已编译的展开。 ``disassemble`` 类似于 `USEFUL-LISP-ALGOS2 <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.9152>`_ 中描述的CMUCL宏扩展 ``macroexpand-all`` 。给 ``disassembler`` 函数或存在的 ``symbol-function`` 绑定，我们可以查看在调用函数时要执行的原始机器码指令。

问题是这些原始的机器代码指令看起来一点也不像 lisp。这些指令对于某些非常随意的机器来说，通常是奇怪的、微小的步骤，而不是 lisp 舒服的嵌套括号。查看编译后的 lisp 代码展开就像用放大镜阅读海报一样。可以看到喜欢的任何部分的细节，但仅凭这一点来解释整体情况是困难的，甚至是不可能的。更糟糕的是，当查看这种细节级别的代码时，有时不可能查看任何一段机器码并确定编译器为什么把它放在那里。

不幸的是，没人知道超过 ``compile`` 函数的 lisp 的最好实现。毫无疑问，有很多宏展开来完整这个代码，其中一些是板上钉钉的事，因此它可能可以标准化，但最好的使用硬件资源（如 CPU 周期和内存）的方法仍然是（可能一直都是）个非常热门的研究课题。比编译器设计的改进更难跟踪的是硬件的不断改进。最初有意义的优化可能变得不相关甚至完全不正确。我们不需要找太多的例子来说明不断变化的世界是如何影响效率假设的。

科学家们过去避免在需要良好表现的代码中使用浮点计算，而是选择基于机器字的定点计算。这是因为计算机没有专门的浮点硬件，所以被迫使用处理器的整数指令来模拟它。因为处理器并没有为此进行真正的优化，浮点运算总是比定点运算慢得多。然而，随着时间的推移，硬件开始出现专门的浮点协同处理器，这些处理器被设计来以光速般的速度执行这些浮点运算。几乎在一夜之间，科学家们从假设固定点运算总是比浮点运算快得多，到不得不在做出决定之前对他们的硬件进行调查和基准测试。硬件的发展改变了浮点数的性能现实。不久之后，计算机开始配备 2 个、4 个或更多的浮点协同处理器，科学家们发现，如果他们能够让浮点指令的流水线充满，浮点运算通常可以比定点运算表现得更好。许多出于性能原因而选择固定点的程序 —— 在大约 10 年的时间框架内 —— 从选择正确的实现到选择错误的实现。

.. code-block::

  (defmacro dis (args &rest body)
    `(disassemble
       (compile nil
         (lambda ,(mapcar (lambda (a)
                            (if (consp a)
                              (cadr a)
                              a))
                          args)
            (declare
              ,@(mapcar
                  #`(type ,(car a1) ,(cadr a1))
                  (remove-if-not #'consp args)))
            ,@body))))

在开发宏时，同样有用的是看 ``macroexpand`` 和 ``macroexpand-all`` 的输出，这有助于查看 ``disassembler`` 的输出，不仅了解实现功能，而且确保给 lisp 所需的所有信息来生成有效的展开。 ``dis`` 是个令在反汇编输出中检查部分 lisp 代码变得很容易的宏。它的第一个参数是一个符号列表或一个类型和符号列表。想知道 ``dis`` 是怎么工作的，直接展开。这里是 ``dis`` 展开为一个简单的二进制加法:

.. code-block::

  * (macroexpand
      '(dis (a b) (+ a b)))
  (DISASSEMBLE
    (COMPILE NIL
      (LAMBDA (A B)
        (DECLARE)
        (+ A B))))
  T

为什么其中会有个空的 ``declare`` 结构呢？它是一个占位符，``dis`` 可以插入类型声明，当像下面那样在参数中指定它们:

.. code-block::

  * (macroexpand
      '(dis ((fixnum a) (integer b))
  (+ a b)))
  (DISASSEMBLE
    (COMPILE NIL
      (LAMBDA (A B)
        (DECLARE (TYPE FIXNUM A)
                (TYPE INTEGER B))
        (+ A B))))
  T

因为 ``dis`` 展开成一个（封装的）lambda 结构，所以它的工作方式与 lambda 非常相似。只要你想的话，可以添加额外的声明，并且返回值很重要（因为 lambda 结构提供了一个隐式的 progn）。加载了本书的代码后，试着在你的 lisp 环境中输入下面的代码：

.. code-block::

  (dis (a b)
    (+ a b))

机器码应该相当短，但这是因为调用了一个预编译函数 —— 这个函数足够的智能来提供所有花哨的 lisp 数字特性，如类型感染、有理数简化等，从而隐藏了大部分的复杂性。这被称为 *间接（ indirection ）* ，在反汇编器的输出中可能相当明显:

.. code-block::

  CALL #x1000148 ; GENERIC-+

用三个参数试试看：

.. code-block::

  (dis (a b c)
    (+ a b c))

练习：通用加法函数有多少层间接呢？ ``(<= 0 N)`` 中的参数 N 又有多少层呢?

现在尝试锁定其中一个变量的类型。将其与前面没有声明类型的示例进行比较：

.. code-block::

  (dis ((fixnum a) b)
    (+ a b))

某些 ``OBJECT-NOT-FIXNUM-ERROR`` 现在应该很明显了。Lisp 编译了一些额外的代码来做这种类型检查，同时间接控制泛型的加法函数，因为 ``b`` 的类型在编译时是未知的，因此可能需要 lisp 的所有花哨的数值行为，比如感染。

这不是获得高效代码的方法。事实上，这段代码的效率甚至可能比前一段代码略低。为了编写高效代码，需要用到一个称为 *内联（ inlining ）* 的进程。对于一些特殊的操作，当有足够的类型信息时，lisp 编译器知道如何避免间接或直接向正在编译的函数中添加机器代码来执行所需的操作。下面的通用加法函数中不应该有间接：

.. code-block::

  (dis ((fixnum a) (fixnum b))
    (+ a b))

这种内联过程可能会导致比使用间接方法的机器代码更多的机器代码。这是因为泛型加法函数中实现的一些（但不是全部）功能被复制到了编译的函数中。虽然看起来更长，但在某些情况下，由于更少的间接，该代码将执行效率更高。

但是这种混乱的机器码仍比 C 实现的效率低得多。在编译还是有各种参数计数、类型和溢出检查，以至于与开销相比，这么多的额外开销比实际添加的成本仍要低。如果在循环中使用这个函数，这种开销可能就不能接受了。

对于像 C 这样的语言，可以在任何地方指定类型，而在任何地方都不强制执行安全性，所以代码总是高效的，但也不安全，编写起来总是很麻烦。在大多数动态 Blub 语言中，不需要指定类型，并在任何地方都强制执行安全性，因此代码总是安全的，不烦人，但也不会高效。对于大多数强大的静态 Blub 语言，可以在任何地方指定类型，并在任何地方强制执行安全性，因此代码总是高效和安全的，但很烦人。Lisp 给了你选择。因为 lisp 默认为安全模式，lisp 程序通常看起来比 C 程序慢一些，但几乎总是更安全。因为 lisp 为程序员提供了一个优秀的类型声明系统和实现，并且有很优秀的编译器，所以 lisp 程序几乎总是和动态 Blub 程序一样安全，而且通常要快得多。最重要的是，lisp 有宏，所以如果有什么烦人的东西，好吧，改变它！

让我们继续，并让 lisp 让我们的加法更高效。回想一下， ``#f`` 是高速、低安全声明读宏的缩写。

.. code-block::

  (dis ((fixnum a) (fixnum b))
    #f
    (+ a b))

这次机器指令码应该比之前的短一点。类型检查和参数计数检查应该删除了。但这仍然不是我们想要的单一指令、混乱、危险的 fixnum 加法。为了深入了解正在发生的事情，我们应该检查编译器注释。注释是编译器所做的观察，它本质上是说：”你看起来像是在尝试做一些高效的事情，而且你已经快完成了，但我需要澄清一下你的意图。这里有个小窍门让你更清楚……“

编译注释是无价的信息来源。当试图创建高效的 lisp 代码时，应该仔细阅读并考虑它们。Lisp 编译器使用类型推断系统来发现代码的复杂属性，即使是程序员也可能没有考虑到这些属性。在上面的例子中，编译器应该会给我们这样的提示:

.. code-block::

  ; Note: Doing signed word to integer coercion
  ;       (cost 20) to "<return value>".

Lisp 不会做任何愚蠢的事情，比如忽略 fixnum 溢出，除非明确要求它这样做。因此，为了让 lisp 不小心给出了个可能不是很安全的函数，我们需要避免带符号的单词 （fixnum）到整数 （bignum）的检查和强制。我们需要告诉 lisp，溢出是可以接受的，是的，我们真的想安静地返回一个 fixnum：

.. code-block::

  (dis ((fixnum a) (fixnum b))
    #f
    (the fixnum (+ a b)))

现在已经燃起来了。这大致相当于一个 C 的 fixnum 加法函数：一些机器指令将两个寄存器相加，然后将控制权返回给调用者。虽然反汇编程序可以为 lisp 效率的所有领域提供许多见解，但它会教你两项主要的技能。第一个技巧在本节中主要介绍：如何使用声明来获得有效的数值行为，特别是在循环内部。第二个问题是如何有效地使用数组/向量数据结构。这将在 :doc:`pointer-scope` 中讨论。

就像技术进步将浮点运算的效率现实从应该避免的东西变成了应该利用的东西一样，lisp 编译器技术的进步 —— 结合 COMMON LISP 的正确类型和安全声明系统 —— 正在改变我们对效率的看法。有了这些工具，以及软件系统日益增长的复杂性需求，问题就从如何使 lisp 像低级语言一样高效变成了如何使其他语言像 lisp 一样高效。当然，答案是在 lisp 中用宏实现它们。
