<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5.7 Dlambda &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="第六章：回指(Anaphoric) 宏" href="../Chapter06/index.html" />
    <link rel="prev" title="5.6 递归方案" href="5.6-recursive-solutions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第五章：Programs that program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="5.1-lisp-is-not-functional.html">5.1 非函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.2-top-down-programming.html">5.2 自上而下的编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.3-implicit-contexts.html">5.3 隐式上下文</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.4-code-walking-with-macrolet.html">5.4 使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 遍历代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.5-recursive-expansions.html">5.5 递归展开</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.6-recursive-solutions.html">5.6 递归方案</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.7 Dlambda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 的变迁</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第五章：Programs that program</a> &raquo;</li>
      <li>5.7 Dlambda</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter05/5.7-dlambda.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="dlambda">
<h1>5.7 Dlambda<a class="headerlink" href="#dlambda" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>在讨论闭包时，我们提到了怎么将闭包当作对象使用，以及一般情况下，不确定范围和词法
作用域怎么替代复杂的对象系统。但是，到目前为止，我们忽略了对象通常都有的一个特性：
多方法。换句话说，虽然我们简单的计数器闭包示例只允许一个操作，即增量，但对象通常
都能能够用不同的行为响应不同的消息。</p>
<p>尽管闭包可以被认为是个只有一个方法（ <code class="docutils literal notranslate"><span class="pre">apply</span></code> ）的对象，但可以根据传递给它的参数
来设计个方法，使其具有不同的行为。例如，如果我们将第一个参数指定为表示所传递消息
的符号，则可以基于第一个参数用简单的 <code class="docutils literal notranslate"><span class="pre">case</span></code> 语句提供多个行为。</p>
<p>为实现一个具有增加和减少方法的计数器，可能会这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">count</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">(</span><span class="n">case</span> <span class="n">msg</span>
      <span class="p">((:</span><span class="n">inc</span><span class="p">)</span>
        <span class="p">(</span><span class="n">incf</span> <span class="n">count</span><span class="p">))</span>
      <span class="p">((:</span><span class="n">dec</span><span class="p">)</span>
        <span class="p">(</span><span class="n">decf</span> <span class="n">count</span><span class="p">)))))</span>
</pre></div>
</div>
<p>注意，上述例子中使用了关键字符号，也就是冒号 <code class="docutils literal notranslate"><span class="pre">:</span></code> 开头的符号，通常计算这些符号用来
指代消息。关键字很方便，因为不需要引用它们或从包中导出它们，而且很直观，因为它们
就是设计来执行这个和其他类型的解构。通常在 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 或 <code class="docutils literal notranslate"><span class="pre">defmacro</span></code> 结构中，关键字
在运行时不会被解构。但是由于我们正在实现一个消息传递系统，这个系统会在运行时解构，
所以我们将关键字处理操作留在运行时执行。如前所述，符号的解构是个高效的操作（仅仅
是指针比较）。计数器例子在编译时，可能会被缩减为以下机器码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="n">FC</span><span class="p">:</span>       <span class="n">MOV</span>  <span class="n">EAX</span><span class="p">,</span> <span class="p">[</span><span class="c1">#x582701E4]  ; :INC</span>
<span class="mi">302</span><span class="p">:</span>       <span class="n">CMP</span>  <span class="p">[</span><span class="n">EBP</span><span class="o">-</span><span class="mi">12</span><span class="p">],</span> <span class="n">EAX</span>
<span class="mi">305</span><span class="p">:</span>       <span class="n">JEQ</span>  <span class="n">L3</span>
<span class="mi">307</span><span class="p">:</span>       <span class="n">MOV</span>  <span class="n">EAX</span><span class="p">,</span> <span class="p">[</span><span class="c1">#x582701E8]  ; :DEC</span>
<span class="mi">30</span><span class="n">D</span><span class="p">:</span>       <span class="n">CMP</span>  <span class="p">[</span><span class="n">EBP</span><span class="o">-</span><span class="mi">12</span><span class="p">],</span> <span class="n">EAX</span>
<span class="mi">310</span><span class="p">:</span>       <span class="n">JEQ</span>  <span class="n">L2</span>
</pre></div>
</div>
<p>但为了方便起见，我们要避免每创建个对象或类时都要编写一个对应的条件语句。这里就要
用到宏了。我喜欢用的宏是 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code>，他会展开成 lambda 结构。这个展开包括一种方法，
这个方法可以根据应用的参数执行许多不同的代码分支。这种运行时解构的类型就是
<code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 名称的来源：它是 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 的解构或调度版本。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! dlambda (&amp;rest ds)
  `(lambda (&amp;rest ,g!args)
    (case (car ,g!args)
      ,@(mapcar
          (lambda (d)
            `(,(if (eq t (car d))
                t
                (list (car d)))
            (apply (lambda ,@(cdr d))
                  ,(if (eq t (car d))
                      g!args
                      `(cdr ,g!args)))))
        ds))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 的第一个参数是个关键词符号。根据使用的关键字符号，<code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 将执行相应
的代码段。例如，我们最喜欢的闭包例子：简单的计数器，可以使用 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code>，根据第一个
参数增加或减少计数。这就是所谓的 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">over</span> <span class="pre">dlambda</span></code> 模式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">symbol</span><span class="o">-</span><span class="n">function</span> <span class="s1">&#39;count-test)</span>
    <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">count</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="n">dlambda</span>
        <span class="p">(:</span><span class="n">inc</span> <span class="p">()</span> <span class="p">(</span><span class="n">incf</span> <span class="n">count</span><span class="p">))</span>
        <span class="p">(:</span><span class="n">dec</span> <span class="p">()</span> <span class="p">(</span><span class="n">decf</span> <span class="n">count</span><span class="p">)))))</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>既可以递增</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">inc</span><span class="p">)</span>

<span class="mi">1</span>
</pre></div>
</div>
<p>也可以递减</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">dec</span><span class="p">)</span>

<span class="mi">0</span>
</pre></div>
</div>
<p>闭包取决于传递的第一个参数。尽管在上面的 let over dlambda 中为空，关键字符号后面
的列表实际上是 lambda 析构列表。每个调度，或者说每个关键字参数，都可以有自己特定
的 lambda 解构列表，就像下面对计数器闭包的增强:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">symbol</span><span class="o">-</span><span class="n">function</span> <span class="s1">&#39;count-test)</span>
    <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">count</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="n">dlambda</span>
        <span class="p">(:</span><span class="n">reset</span> <span class="p">()</span> <span class="p">(</span><span class="n">setf</span> <span class="n">count</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">(:</span><span class="n">inc</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">incf</span> <span class="n">count</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">(:</span><span class="n">dec</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">decf</span> <span class="n">count</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">(:</span><span class="n">bound</span> <span class="p">(</span><span class="n">lo</span> <span class="n">hi</span><span class="p">)</span>
          <span class="p">(</span><span class="n">setf</span> <span class="n">count</span>
            <span class="p">(</span><span class="nb">min</span> <span class="n">hi</span>
                <span class="p">(</span><span class="nb">max</span> <span class="n">lo</span>
                      <span class="n">count</span><span class="p">)))))))</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>现在，我们有几个不同的 lambda 解构列表可以使用，具体取决于第一个关键词参数，
<code class="docutils literal notranslate"><span class="pre">:reset</span></code> 不需要参数，然后会将 <code class="docutils literal notranslate"><span class="pre">count</span></code> 置为 0：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">reset</span><span class="p">)</span>

<span class="mi">0</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">:inc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">:dec</span></code> 都接受数字参数，<code class="docutils literal notranslate"><span class="pre">n</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">inc</span> <span class="mi">100</span><span class="p">)</span>

<span class="mi">100</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">:bound</span></code> 确保 <code class="docutils literal notranslate"><span class="pre">count</span></code> 的值时在边界值 <code class="docutils literal notranslate"><span class="pre">lo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">hi</span></code> 之中。若 <code class="docutils literal notranslate"><span class="pre">count</span></code> 的值落在边界值
之外，那么它会变成离该值较近的那个边界值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">bound</span> <span class="o">-</span><span class="mi">10</span> <span class="mi">10</span><span class="p">)</span>

<span class="mi">10</span>
</pre></div>
</div>
<blockquote>
<div><p>上面代码的结果之所以为 10 是因为上面的值已经将 <code class="docutils literal notranslate"><span class="pre">count</span></code> 设置为 100 了，加上了
<code class="docutils literal notranslate"><span class="pre">:bond</span></code> 后就变成 10 了</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 一个重要的属性是，它使用 lambda 进行所有的解构，因此保留了正常的
错误检查和 COMMON LISP 环境中的调试（debugging）。例如，当只给 <code class="docutils literal notranslate"><span class="pre">count-test</span></code>
一个参数时，就会直接得到个和 lambda 程序类似的报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">bond</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>

<span class="n">ERROR</span><span class="p">:</span> <span class="n">Wrong</span> <span class="n">argument</span> <span class="n">count</span><span class="p">,</span> <span class="n">wanted</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">got</span> <span class="mf">1.</span>
</pre></div>
</div>
<p>特别是当 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 嵌入到词法环境中形成个闭包，<code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 可以让我们使用面向
对象的方式编程，就像是创建个多方法的对象。 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 经过适配，在不偏离
lambda 语法和用法的情况下，使该功能易于访问。 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 仍然会展开成单个
lambda 表达式，因此，它的求值结果与对 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 求值完全相同：一个可以保存、
应用的匿名函数，最重要的是，可以将这个 lambda 控件用作词法闭包。</p>
<p>但 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 将这种同步与 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 更进一步。为了让 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 尽可能平滑地
从包含 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 宏的代码转换，<code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 可以不将关键字参数作为第一个符号
传递的匿名函数调用。当我们通过正常的 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 接口使用闭包编写了大量的代码时，
我们希望能够添加特殊情况的 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 方法，而不改变其他代码调用接口的方式。</p>
<p>如果说最后可能的方法是给定符号 <code class="docutils literal notranslate"><span class="pre">t</span></code> 而不是关键字参数，在没有发现任何特殊情况的
关键字参数方法适用时，所提供的方法将始终被调用。以下是个特意编造的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">symbol</span><span class="o">-</span><span class="n">function</span> <span class="s1">&#39;dlambda-test)</span>
    <span class="p">(</span><span class="n">dlambda</span>
      <span class="p">(:</span><span class="n">something</span><span class="o">-</span><span class="n">special</span> <span class="p">()</span>
        <span class="p">(</span><span class="nb">format</span> <span class="n">t</span> <span class="s2">&quot;SPECIAL~%&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="n">t</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rest</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">format</span> <span class="n">t</span> <span class="s2">&quot;DEFAULT: ~a~%&quot;</span> <span class="n">args</span><span class="p">))))</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>有了这个定义，调用该函数的主要方法就是调用默认情况。默认情况用了 lambda 解构
参数的 <code class="docutils literal notranslate"><span class="pre">&amp;rest</span></code> 来接收所有可能的参数，我们可以通过提供更具体的 lambda 解构参数
自由地缩小可接受的参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">dlambda</span><span class="o">-</span><span class="n">test</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">DEFAULT</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">NIL</span>
<span class="o">*</span> <span class="p">(</span><span class="n">dlambda</span><span class="o">-</span><span class="n">test</span><span class="p">)</span>
<span class="n">DEFAULT</span><span class="p">:</span> <span class="n">NIL</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>然而，尽管这个匿名函数的行为很像用默认情况定义的常规 lambda 结构，但我们可以
传递一个关键字参数来调用这个特殊方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">dlambda</span><span class="o">-</span><span class="n">test</span> <span class="p">:</span><span class="n">something</span><span class="o">-</span><span class="n">special</span><span class="p">)</span>
<span class="n">SPECIAL</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>一个关键特性(后面的章节将会大量利用)是，默认方法和所有特殊方法当然都是在包含
<code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 的词法上下文中调用的。由于 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 与 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 表示法集成得非常紧密，
这使得我们可以将多方法技术引入到创建和扩展词法闭包的领域。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="5.6-recursive-solutions.html" class="btn btn-neutral float-left" title="5.6 递归方案" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../Chapter06/index.html" class="btn btn-neutral float-right" title="第六章：回指(Anaphoric) 宏" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>