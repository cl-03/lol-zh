

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>5.5 递归展开 &mdash; Let Over Lambda 中文文档  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.6 递归方案" href="5.6-recursive-solutions.html" />
    <link rel="prev" title="5.4 使用 macrolet 遍历代码" href="5.4-code-walking-with-macrolet.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第五章：Programs that program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="5.1-lisp-is-not-functional.html">5.1 非函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.2-top-down-programming.html">5.2 自上而下的编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.3-implicit-contexts.html">5.3 隐式上下文</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.4-code-walking-with-macrolet.html">5.4 使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 遍历代码</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.5 递归展开</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.6-recursive-solutions.html">5.6 递归方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.7-dlambda.html">5.7 Dlambda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第五章：Programs that program</a> &raquo;</li>
        
      <li>5.5 递归展开</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Chapter05/5.5-recursive-expansions.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="tex2jax_ignore mathjax_ignore section" id="id1">
<h1>5.5 递归展开<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>在用例子教初学者 lisp 时，在课程中不可避免地会出现一个问题</p>
<blockquote>
<div><p>cadr 是个什么玩意?</p>
</div></blockquote>
<p>这时有两种方法来回答这个问题。第一种方法就是向学生解释 lisp 的列表（list）是由 <code class="docutils literal notranslate"><span class="pre">cons</span></code>
单元组成，每个 <code class="docutils literal notranslate"><span class="pre">cons</span></code> 单元都有两个指针：<code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code>。一旦理解了这个概念，就很容易
展示如何将这些指针的访问器函数（也称为 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code>），这两个函数可以组合成 <code class="docutils literal notranslate"><span class="pre">cadr</span></code>
函数，而 <code class="docutils literal notranslate"><span class="pre">cadr</span></code> 函数会遍历列表然后获取列表中的第二个元素。</p>
<p>第二种方法就是给学生引入 <code class="docutils literal notranslate"><span class="pre">second</span></code> 这个 COMMON LISP 函数，然后完全忽略 <code class="docutils literal notranslate"><span class="pre">cadr</span></code>。而
<code class="docutils literal notranslate"><span class="pre">cadr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">second</span></code> 效果是一样的：获取列表中的第二个元素。不同之处在于 <code class="docutils literal notranslate"><span class="pre">second</span></code> 是根
据它的结果来命名的，而 <code class="docutils literal notranslate"><span class="pre">cadr</span></code> 是根据它的过程来命名的。<code class="docutils literal notranslate"><span class="pre">cadr</span></code> 是显式的定义，而
<code class="docutils literal notranslate"><span class="pre">second</span></code> 是个容易记住的函数名，但它不合需要地模糊了操作的含义。 显式定义通常更好，
因为我们能想到的 <code class="docutils literal notranslate"><span class="pre">cadr</span></code> 函数不仅仅是获取列表的第二个元素。 例如，我们明显可以用
<code class="docutils literal notranslate"><span class="pre">cadr</span></code> 作为获取 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 结构参数解构列表的概念。 <code class="docutils literal notranslate"><span class="pre">cadr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">second</span></code> 在底层执行上是
一样的，但在概念上可以表示不同的操作。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">second</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cadr</span></code> 是完全一样的，都只能应用到列表上，不能应用到其他的序列类型上，
如向量、字符串之类的，即这两个函数的参数类型只能是列表。</p>
</div></blockquote>
<p>对显示定义来说，比哲学偏好更重要的是，<code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 的组合可以表示更多的列表访问操作，
而且比英文词组的访问器更一致。<code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 用处很大，因为可以把他们组合成新的、任意
的函数。例如，<code class="docutils literal notranslate"><span class="pre">(cadadr</span> <span class="pre">x)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(car</span> <span class="pre">(cdr</span> <span class="pre">(car</span> <span class="pre">(cdr</span> <span class="pre">x))))</span></code> 是一样的。COMMON
LISP 要求必须定义长度不大于 4 的 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 的所有组合。 因此，尽管没有函数
<code class="docutils literal notranslate"><span class="pre">second-of-second</span></code> 用于获取列表的第二个元素，然后将其作为列表并获取其第二个元素，
但可以使用 <code class="docutils literal notranslate"><span class="pre">cadadr</span></code> 达到这个效果。</p>
<p>这些预定义的 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 的组合用在函数的 <code class="docutils literal notranslate"><span class="pre">:key</span></code> 访问参数上真的很方便，像 <code class="docutils literal notranslate"><span class="pre">find</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">find</span> <span class="s1">&#39;a</span>
    <span class="s1">&#39;(((a b) (c d)) ((c d) (b a)))</span>
    <span class="p">:</span><span class="n">key</span> <span class="c1">#&#39;cadadr)</span>

<span class="p">((</span><span class="n">C</span> <span class="n">D</span><span class="p">)</span> <span class="p">(</span><span class="n">B</span> <span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<p>使用预定义的 <code class="docutils literal notranslate"><span class="pre">cadadr</span></code> 访问器比构建个等价的英文访问器组合的 lambda 表达式要更精确。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">find</span> <span class="s1">&#39;a</span>
    <span class="s1">&#39;(((a b) (c d)) ((c d) (b a)))</span>
    <span class="p">:</span><span class="n">key</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
           <span class="p">(</span><span class="n">second</span> <span class="p">(</span><span class="n">second</span> <span class="n">e</span><span class="p">))))</span>

<span class="p">((</span><span class="n">C</span> <span class="n">D</span><span class="p">)</span> <span class="p">(</span><span class="n">B</span> <span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<p>COMMON LISP 也提供了函数 <code class="docutils literal notranslate"><span class="pre">nth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">nthcdr</span></code>，他们可以用作通用访问器，比如说，
在不能确切地知道编译时想要获取哪个元素。<code class="docutils literal notranslate"><span class="pre">nth</span></code> 的定义很简单：从列表中取出 n 个 <code class="docutils literal notranslate"><span class="pre">cdrs</span></code>，
然后取一个 car。 所以 <code class="docutils literal notranslate"><span class="pre">(nth</span> <span class="pre">2</span> <span class="pre">list)</span></code> 与 <code class="docutils literal notranslate"><span class="pre">(caddr</span> <span class="pre">list)</span></code>、<code class="docutils literal notranslate"><span class="pre">(third</span> <span class="pre">list)</span></code> 是一样的。
<code class="docutils literal notranslate"><span class="pre">nthcdr</span></code> 也一样，只是它不做最后的 car：<code class="docutils literal notranslate"><span class="pre">(nthcdr</span> <span class="pre">2</span> <span class="pre">list)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(cddr</span> <span class="pre">list)</span></code> 是一样的。</p>
<p>但是，如果 <code class="docutils literal notranslate"><span class="pre">cons</span></code> 结构中的位置不能通过上述模式之一（如 <code class="docutils literal notranslate"><span class="pre">nth</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nthcdr</span></code>）访问，就需要
组合访问器。不得不组合不一致的抽象来完成任务通常表明不完整。 能否为访问列表的域定义
一种域特定语言，以便将这些 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 组合函数、英语访问器以及像 <code class="docutils literal notranslate"><span class="pre">nth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">nthcdr</span></code>
这样的函数结合起来？</p>
<p>既然 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 是基础操作符，我们的语言应该有完全通用的方式组合这两个访问器。因为
有无数种这样的组合，为每个可能的访问器定义函数来继续组合显然是不可行的。 我们真正想要
的是一个可以扩展为高效列表遍历代码的宏。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro cxr% (x tree)
  (if (null x)
    tree
    `(,(cond
          ((eq &#39;a (cadr x)) &#39;car)
          ((eq &#39;d (cadr x)) &#39;cdr)
          (t (error &quot;Non A/D symbol&quot;)))
      ,(if (= 1 (car x))
         `(cxr% ,(cddr x) ,tree)
         `(cxr% ,(cons (- (car x) 1) (cdr x))
                ,tree)))))
</pre></div>
</div>
<p>以 C 开头，后面跟着一个或多个 A 或 D 字符，以 R 结尾，指定列表访问器函数的语法非常直观，
这大致就是我们想要为我们的语言复制的内容。宏 <code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 是这些访问器的双关语，其中一个或多个
A 或 D 字符被替换为 X。 在 <code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 中，第一个参数是个列表，列表中指定这些了 A 和 D。这个
列表是数字和符号 A 或 D 的交替组合。</p>
<p>例如，即使 COMMON LISP 没有提供个英文单词的函数来访问列表的第十一个元素，我们也可以
简单地定义出来：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">eleventh</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">(</span><span class="n">cxr</span><span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="n">a</span> <span class="mi">10</span> <span class="n">d</span><span class="p">)</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>本节的重点是说明递归展开的实际用途。当宏将一个结构展开为一个新的结构时，递归展开就会出现，
该结构也包含所讨论的宏的使用。 与所有递归一样，此过程必须有个基本的终止条件。宏最终会展开
为不包含使用相关宏的结构，然后这个展开就会结束。</p>
<p>下面我们将 <code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 宏的实例宏展开（<code class="docutils literal notranslate"><span class="pre">macroexpand</span></code>）成一个同样使用 <code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 的结构：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(cxr% (1 a 2 d) some-list))</span>

<span class="p">(</span><span class="n">CAR</span> <span class="p">(</span><span class="n">CXR</span><span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="n">D</span><span class="p">)</span> <span class="n">SOME</span><span class="o">-</span><span class="n">LIST</span><span class="p">))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>当我们拷贝这个新的递归结构，然后宏展开它，又会得到一个递归：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(CXR% (2 D) SOME-LIST))</span>

<span class="p">(</span><span class="n">CDR</span> <span class="p">(</span><span class="n">CXR</span><span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="n">D</span><span class="p">)</span> <span class="n">SOME</span><span class="o">-</span><span class="n">LIST</span><span class="p">))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>下面这个递归的结果展示了 <code class="docutils literal notranslate"><span class="pre">xcr%</span></code> 另一种可能的用法：空列表访问器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpnad</span>
    <span class="s1">&#39;(CXR% (1 D) SOME-LIST))</span>

<span class="p">(</span><span class="n">CDR</span> <span class="p">(</span><span class="n">CXR</span><span class="o">%</span> <span class="n">NIL</span> <span class="n">SOME</span><span class="o">-</span><span class="n">LIST</span><span class="p">))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>空列表访问器就是基本终止条件，然后直接展开被访问的列表：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(CXR% NIL SOME-LIST))</span>

<span class="n">SOME</span><span class="o">-</span><span class="n">LIST</span>
<span class="n">T</span>
</pre></div>
</div>
<p>用 CMUCL 的拓展 <code class="docutils literal notranslate"><span class="pre">macroexpand-all</span></code> （一个完成的代码遍历器组件），可以看到
<code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 结构的完整展开：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">walker</span><span class="p">:</span><span class="n">macroexpand</span><span class="o">-</span><span class="nb">all</span>
    <span class="s1">&#39;(cxr% (1 a 2 d) some-list))</span>
<span class="p">(</span><span class="n">CAR</span> <span class="p">(</span><span class="n">CDR</span> <span class="p">(</span><span class="n">CDR</span> <span class="n">SOME</span><span class="o">-</span><span class="n">LIST</span><span class="p">)))</span>
</pre></div>
</div>
<p>多亏了我们出色的 lisp 编译器，就意图和目的而言，<code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 的使用和 <code class="docutils literal notranslate"><span class="pre">caddr</span></code> 与 <code class="docutils literal notranslate"><span class="pre">third</span></code> 一样。</p>
<p>但是，根据命名来看，<code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 还不完善。这只是最终版 <code class="docutils literal notranslate"><span class="pre">cxr</span></code> 的初版。这个版本的第一个问题
就是 A 和 D 的数量只能是整型。因为这个限制，有些 <code class="docutils literal notranslate"><span class="pre">nth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">nthcdr</span></code> 能做的事情我们的宏
却做不到。</p>
<p>我们需要检查将非整数作为 A 或 D 符号的数字前缀的情况。 在这种情况下，我们的代码展开应该
计算所提供的内容，并将此值用作要遍历的 <code class="docutils literal notranslate"><span class="pre">cars</span></code> 或 <code class="docutils literal notranslate"><span class="pre">cdrs</span></code> 的数量。</p>
<p><code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 的第二个问题是，当 A 和 D 的前面的数字特别大时，<code class="docutils literal notranslate"><span class="pre">cxr%</span></code> 会内联所有的 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code>
的组合。对小的数字来说，内联可以提高性能，但通常内联过多的 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 没有意义； 相反，
应该用像 <code class="docutils literal notranslate"><span class="pre">nth</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nthcdr</span></code> 这样的循环函数。</p>
<p>为了解决这两个问题，我们添加了个替代展开。如果 A 或 D 前面的参数不是整型的话，就会调用
新的操作，而且，如果我们不想内联大量的 <code class="docutils literal notranslate"><span class="pre">car</span></code> 或 <code class="docutils literal notranslate"><span class="pre">cdr</span></code>，也可以选择调用新的操作。任选内联
阈值为 10，这个新的操作由 <code class="docutils literal notranslate"><span class="pre">cxr</span></code> 宏提供。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defvar cxr-inline-thresh 10)

(defmacro! cxr (x tree)
  (if (null x)
    tree
    (let ((op (cond
                ((eq &#39;a (cadr x)) &#39;car)
                ((eq &#39;d (cadr x)) &#39;cdr)
                (t (error &quot;Non A/D symbol&quot;)))))
      (if (and (integerp (car x))
               (&lt;= 1 (car x) cxr-inline-thresh))
        (if (= 1 (car x))
          `(,op (cxr ,(cddr x) ,tree))
          `(,op (cxr ,(cons (- (car x) 1) (cdr x))
                     ,tree)))
        `(nlet-tail
          ,g!name ((,g!count ,(car x))
                   (,g!val (cxr ,(cddr x) ,tree)))
          (if (&gt;= 0 ,g!count)
            ,g!val
            ;; Will be a tail:
            (,g!name (- ,g!count 1)
                     (,op ,g!val))))))))
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">cxr</span></code>，我们可以直接根据 <code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 的显示指定来设计 <code class="docutils literal notranslate"><span class="pre">nthcdr</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">nthcdr</span><span class="o">%</span> <span class="p">(</span><span class="n">n</span> <span class="nb">list</span><span class="p">)</span>
  <span class="p">(</span><span class="n">cxr</span> <span class="p">(</span><span class="n">n</span> <span class="n">d</span><span class="p">)</span> <span class="nb">list</span><span class="p">))</span>
</pre></div>
</div>
<p>同样的，<code class="docutils literal notranslate"><span class="pre">nth</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">nth</span><span class="o">%</span> <span class="p">(</span><span class="n">n</span> <span class="nb">list</span><span class="p">)</span>
  <span class="p">(</span><span class="n">cxr</span> <span class="p">(</span><span class="mi">1</span> <span class="n">a</span> <span class="n">n</span> <span class="n">d</span><span class="p">)</span> <span class="nb">list</span><span class="p">))</span>
</pre></div>
</div>
<p>因为编写宏是个迭代的、分层次的过程，我们经常驱使自己使用组合或结合之前实现的宏。
例如，在 <code class="docutils literal notranslate"><span class="pre">cxr</span></code> 的定义中，替代展开用到了上一节中定义的宏：<code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code>。
<code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code> 很方便，因为它可以给迭代构造命名，同时，因为我们只计划将迭代作为
尾调用，就能保证使用它而避免不必要的堆栈消耗。</p>
<p>下面是 <code class="docutils literal notranslate"><span class="pre">xcr</span></code> 在 <code class="docutils literal notranslate"><span class="pre">nthcdr%</span></code> 中的展开：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
  <span class="s1">&#39;(cxr (n d) list))</span>
<span class="p">(</span><span class="n">LET</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">NLET</span><span class="o">-</span><span class="n">TAIL</span> <span class="c1">#:NAME1632</span>
            <span class="p">((</span><span class="c1">#:COUNT1633 N)</span>
              <span class="p">(</span><span class="c1">#:VAL1634 (CXR NIL LIST)))</span>
    <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="mi">0</span> <span class="c1">#:COUNT1633)</span>
      <span class="c1">#:VAL1634</span>
      <span class="p">(</span><span class="c1">#:NAME1632 (- #:COUNT1633 1)</span>
<span class="n">T</span>
</pre></div>
</div>
<p>注意，复杂的宏展开的代码通常是程序员从不会去写的。特别要注意 <code class="docutils literal notranslate"><span class="pre">nil</span> <span class="pre">cxrs</span></code> 的使用
和无意义 <code class="docutils literal notranslate"><span class="pre">let</span></code> 的使用，这两者都留给了进一步的宏展开和编译器来优化。</p>
<p>因为宏可以让用户看到更多的展开，所以显示定义在其他语言中是不可能实现的。例如，
根据 <code class="docutils literal notranslate"><span class="pre">cxr</span></code> 的设计，当 A 和 D 前面的整数小于 <code class="docutils literal notranslate"><span class="pre">cxr-inline-thresh</span></code> 的参数时，
<code class="docutils literal notranslate"><span class="pre">car</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cdr</span></code> 的调用会被内联：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span> <span class="s1">&#39;(cxr (9 d) list))</span>
<span class="p">(</span><span class="n">LET</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">CDR</span> <span class="p">(</span><span class="n">CXR</span> <span class="p">(</span><span class="mi">8</span> <span class="n">D</span><span class="p">)</span> <span class="n">LIST</span><span class="p">)))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>但多亏了 <code class="docutils literal notranslate"><span class="pre">cxr</span></code> 的显示定义，我们可以传递一个值，尽管它本身不是整数，但在计算时将
成为整数。当我们这么做时，我们知道不会有内联，因为这个宏会变成 <code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code> 展开。
计算一个整数最简单的结构就是将那个整数引起来：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span> <span class="s1">&#39;(cxr (&#39;</span><span class="mi">9</span> <span class="n">d</span><span class="p">)</span> <span class="nb">list</span><span class="p">))</span>
<span class="p">(</span><span class="n">LET</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">NLET</span><span class="o">-</span><span class="n">TAIL</span> <span class="c1">#:NAME1638</span>
            <span class="p">((</span><span class="c1">#:COUNT1639 &#39;9)</span>
              <span class="p">(</span><span class="c1">#:VAL1640 (CXR NIL LIST)))</span>
    <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="mi">0</span> <span class="c1">#:COUNT1639)</span>
      <span class="c1">#:VAL1640</span>
      <span class="p">(</span><span class="c1">#:NAME1638 (- #:COUNT1639 1)</span>
<span class="n">T</span>
</pre></div>
</div>
<p>通常我们会发现将宏组合起来很有用：<code class="docutils literal notranslate"><span class="pre">cxr</span></code> 可以展开成之前写的宏 <code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code>。同样的，
有时将宏自身组合起来也很有用，这样就会有递归展开。</p>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="5.6-recursive-solutions.html" class="btn btn-neutral float-right" title="5.6 递归方案" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="5.4-code-walking-with-macrolet.html" class="btn btn-neutral float-left" title="5.4 使用 macrolet 遍历代码" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>