<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.6 Once Only &mdash; Let Over Lambda 中文文档  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3.7 语法的二义性" href="3.7-duality-of-syntax.html" />
    <link rel="prev" title="3.5 异常捕获" href="3.5-unwanted-capture.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第三章：宏基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="3.1-iterative-development.html">3.1 迭代开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.2-domain-specific-languages.html">3.2 领域特定语言</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.3-control-structures.html">3.3 控制结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.4-free-variables.html">3.4 自由变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.5-unwanted-capture.html">3.5 异常捕获</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.6 Once Only</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.7-duality-of-syntax.html">3.7 语法的二义性</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第三章：宏基础</a> &raquo;</li>
      <li>3.6 Once Only</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter03/3.6-once-only.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="once-only">
<h1>3.6 Once Only<a class="headerlink" href="#once-only" title="Permalink to this headline"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>Peter Norvig 是一位出色的程序员和作家。 在解决计算机科学家目前面临的许多最困难的问题之前，需要阅读他关于人工智能的书籍，尤其是《人工智能：一种现代方法》 [AIMA]。 lisp 程序员可能更熟悉 Norvig 的著作《人工智能编程范式：COMMON LISP中的案例研究》。 这本书可能有点过时，但对于认真的 lisp 学生来说仍然是必读的，且这本书包含许多重要的 lisp 见解。 本节专门针对 Peter Norvig，甚至以 PAIP 中描述的宏命名。 在它的最后几页中，隐藏在对序列函数实现的描述中，是</p>
<blockquote>
<div><p>once-only：宏的教程</p>
</div></blockquote>
<p>紧接着是句更有趣的话：</p>
<blockquote>
<div><p>If you can understand how to write and when to use once-only, then you truly understand macros.</p>
</div></blockquote>
<p>现在我们已经知道了，没有人真正了解宏。 理解一个特定的宏，即使是一个和 once-only 一样重要的宏，也不会比理解一个重要的定理让你真正的、更进一步地理解数学。 因为到目前为止它们的可能性似乎是无限的，所以真正理解数学或宏是不可能的。</p>
<p>这里不会给出 Norvig 的 <strong>once-only</strong> 的定义，但它是一个相当复杂的宏，具有一些有趣的属性，之后会稍有不同地实现这些属性。 <strong>once-only</strong> 最初是为已经消失的 lisp 机器编程环境编写的，因为不必要的原因而被排除在 COMMON LISP 之外。</p>
<p><strong>once-only</strong> 背后的思想是在宏展开的周围创建新绑定的代码。 执行宏展开时，这个新的绑定会初始化为宏的参数执行的结果值。 <strong>once-only</strong> 主体中的代码然后可以使用绑定，当然，不会重新执行宏的参数。 作为参数传递给宏的结构仅且总是执行一次。 仅此一次。</p>
<p>Norvig 用 <strong>square</strong> 宏做为 <strong>once-only</strong> 的示例。 <strong>square</strong> 表达式接受一个参数并返回该参数与自身的乘积：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro square (x)
  `(* ,x ,x))
</pre></div>
</div>
<p>当传给 <strong>square</strong> 宏许类型都能正常运行，这些类型可以是大部分变量、数字和其他可以根据需要自由计算多次的结构。 但是一旦有副作用的结构传给这个版本的 <strong>square</strong> 中，那么所有的预想都失效。 当然，行为仍然是确定性的，但可能很难确定。 使用这个特定的宏，传递的参数将被计算两次。 但是因为这些事情很快变得复杂，在一般情况下，所有的预想都没了。 避免这些不必要的副作用变得方便和容易是 once-only 的重点。 注意，如果用的是函数，将自由获得此行为。 在离开人为的教科书示例的范畴后，到这一步，将 <strong>square</strong> 定义为一个函数，最终看起来像这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">square</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">(</span><span class="o">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>由于 lambda 的工作原理，可以用任何结构作为这个 <strong>square</strong> 函数定义的参数。 因为这个参数将只被执行一次，所以我们的想法和副作用概念模型都得到了满足。 在大多数情况下，我们希望写过一次的表达式只被执行一次。 相反，宏的主要功能之一是通过操纵执行的频率和顺序来违反这一假设。 例如，在循环之类的事情中，可能想要多次执行表达式。 甚至也可能希望表达式永远不会被执行，比如说我们想要表达式执行结果以外的东西。</p>
<p><strong>once-only</strong> 可以在宏展开中指定希望只被执行一次的特定参数，且它们的执行顺序是从左到右的，就像 lambda。 以下是如何使用传统的 <strong>once-only</strong> 宏来完成此操作：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro square (x)
  (once-only (x)
    `(* ,x ,x)))
</pre></div>
</div>
<p>当然，如果只想一次执行宏的所有参数，可以使用函数 (lambda)。 稍后会回到这一点，但是因为本书没有 <strong>once-only</strong> 的直接实现，所以我们为宏符号引入了这个功能的替代实现。 尽管在 [PAIP-P853][PRACTICAL-CL-P95] 中有很多有趣的 <strong>once-only</strong> 的实现，但本节介绍了一种与 <strong>defmacro/g!</strong> 组合的新技术。</p>
<p>我们 <strong>once-only</strong> 实现的第一步是创建一些新的谓词和实用函数。 再次独特和简洁之间进行拖鞋，保留另一组符号供自己使用。 所有以字符 O! 开头的符号且其后接一个或多个字符称为 O-bang 符号。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun o!-symbol-p (s)
  (and (symbolp s)
       (&gt; (length (symbol-name s)) 2)
       (string= (symbol-name s)
                &quot;O!&quot;
                :start1 0
                :end1 2)))

(defun o!-symbol-to-g!-symbol (s)
  (symb &quot;G!&quot;
        (subseq (symbol-name s) 2)))
</pre></div>
</div>
<p>定义个区分 O-bang 符号和其他对象的谓词：<strong>o!-symbol-p</strong>。 这个定义几乎与 <strong>g!-symbol-p</strong> 的定义相同。 我们还引入了一个方便的实用函数，将 O-bang 变成 G-bang，其保留 bang 之后的字符：<strong>o!-symbol-to-g!-symbol</strong>。 此实用函数使用 Graham 的实用函数 <strong>symb</strong> 来创建新符号。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro defmacro! (name args &amp;rest body)
  (let* ((os (remove-if-not #&#39;o!-symbol-p args))
         (gs (mapcar #&#39;o!-symbol-to-g!-symbol os)))
    `(defmacro/g! ,name ,args
       `(let ,(mapcar #&#39;list (list ,@gs) (list ,@os))
          ,(progn ,@body)))))
</pre></div>
</div>
<p><strong>defmacro!</strong> 代表我们的宏定义语言的最后一步——增加了个 <strong>once-only</strong> 的特性。 <strong>defmacro!</strong> 结合了上一节的 <strong>defmacro/g!</strong> 。 因为 <strong>defmacro!</strong> 直接展开为 <strong>defmacro/g!</strong> 结构，所以<strong>defmacro!</strong> 将继承自动生成符号行为。 了解所有正在组合的部分对于复杂的组合至关重要。 回顾一下， <strong>defmacro/g!</strong> 查找以 G-bang 开头的符号并自动创建 gensyms。 通过展开为带有 G-bang 符号的结构，<strong>defmacro!</strong> 在实现 <strong>once-only</strong> 时，可以避免重复 gensym 行为。</p>
<p><strong>defmacro!</strong> 给出了一种称为自动 <strong>once-only</strong> 的快捷方式。 使用自动 <strong>once-only</strong> ，我们可以在宏参数中的一个或多个符号前加上 O-bang，使其成为由 <strong>o!-symbol-p</strong> 定义的 O-bang 符号。 当这样做时，<strong>defmacro!</strong> 将知道是在生成的代码中创建一个绑定，该绑定在执行时，将宏参数代码执行的结果传宏。 宏展开可以通过 gensym 访问此绑定。 但是在创建展开时，怎么引用这个 gensym 呢？ 通过调用上面由 <strong>o!-symbol-to-g!-symbol</strong> 定义的等效 G-bang 符号。</p>
<p>该实现依赖于 <strong>defmacro/g!</strong> 的功能。 使用 <strong>o!-symbol-to-g!-symbol</strong> 实用程序，创建新的 G-bang 符号以添加到 <strong>defmacro/g!</strong> 结构。 一旦有了自动生成符号，就很容易实现 <strong>once-only</strong> ，正如 <strong>defmacro!</strong> 定义那样简洁。</p>
<p>暂时回到人为的教科书示例，我们将重新实现 <strong>square</strong> 宏，这次使用 <strong>defmacro!</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! square (o!x)
  `(* ,g!x ,g!x))
</pre></div>
</div>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">macroexpand</span></code> 展开：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(square (incf x)))</span>

<span class="p">(</span><span class="n">LET</span> <span class="p">((</span><span class="c1">#:X1633 (INCF X)))</span>
  <span class="p">(</span><span class="o">*</span> <span class="c1">#:X1633 #:X1633))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>上一节中，我提到我们将所有 G-bang 符号的字符串值传递给 <strong>gensym</strong>。 这使得检查这些结构的展开变得很容易。 尽管像 <strong>#:X1633</strong> 这样的 gensyms 的名称没有什么意义，但如果我们正在编写或调试由 <strong>defmacro!</strong> 定义的 <strong>square</strong> 时，可以直接看到这个符号和宏定义中使用的符号之间的联系：<strong>X</strong>。如果将这些信息保留在 gensyms 的 <strong>print-name</strong> ，就像在 <strong>defmacro/g!</strong> 中的展开那样.</p>
<p>与传统的 <strong>once-only</strong> 相比，除了简洁的用法和更有用的展开输出之外，<strong>defmacro!</strong> 还提供了一项额外的关键功能。 在传统的 <strong>once-only</strong> 中，用于访问创建的词法变量的 gensym 的绑定被赋予与宏展开的参数相同的名称，这会隐藏宏参数，因此宏定义无法访问它。 因为 <strong>defmacro!</strong> 将其分为两种不同类型的符号，G-bang 和 O-bang ，我们可以编写使用这两个值的宏展开。 为了展示这一点，这里是 <strong>square</strong> 宏的另一个定义：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! square (o!x)
  `(progn
     (format t &quot;[~a gave ~a]~%&quot;
                 &#39;,o!x   ,g!x)
     (* ,g!x ,g!x)))
</pre></div>
</div>
<p>可以像以下的方式调用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">defvar</span> <span class="n">x</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">X</span>
<span class="o">*</span> <span class="p">(</span><span class="n">square</span> <span class="p">(</span><span class="n">incf</span> <span class="n">x</span><span class="p">))</span>
<span class="p">[(</span><span class="n">INCF</span> <span class="n">X</span><span class="p">)</span> <span class="n">gave</span> <span class="mi">5</span><span class="p">]</span>
<span class="mi">25</span>
</pre></div>
</div>
<p>注意，上面的 <strong>square</strong> 定义中引用了未引用的 O-bang 符号（<strong>’,o!x</strong>）。 这样做是因为不想再次执行此结构。 <strong>defmacro!</strong> 生成的展开已经执行过了。 我们只是想把传给 <strong>square</strong> 的参数用作他途，这种情况下是某种粗略的调试语句。 然而，即使已经执行过一次，且在这种情况下它是不正确的，如果我们期望的抽象需要它，没有什么能阻止我们再次执行传进来的参数。</p>
<p><strong>defmacro!</strong> 语言可以对宏的参数的执行进行精细、方便的控制。 如果在宏定义中所有表示参数的符号都用 O-bang 前缀，并且只在宏定义中使用相应的 G-bang 符号，这个展开将与 lambda 表达式相同——每个结构执行一次，按照从左到右的顺序。 在参数中没有这些符号，也没有在展开中使用 G-bang 符号，<strong>defmacro!</strong> 就像常规的 <strong>defmacro</strong> 一样。</p>
<p><strong>defmacro!</strong> 在宏的迭代开发过程中最有用。 因为向宏参数添加两个字符以获得 lambda 结构执行是一件简单的事情，并用 gensyms 就像编写它们一样简单，可以立即改变对这些决定的看法。<strong>defmacro!</strong> 感觉像是比  <strong>defmacro</strong> 更贴合 <strong>lambda</strong> 的手套。 正是出于这个原因，迭代开发，我们将使用 <strong>defmacro!</strong> 作为本书其余部分的主要宏定义接口。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! nif (o!expr pos zero neg)
  `(cond ((plusp ,g!expr) ,pos)
         ((zerop ,g!expr) ,zero)
          (t ,neg)))
</pre></div>
</div>
<p>回到 Graham 的 <strong>nif</strong> 宏。 当用 <strong>defmacro!</strong> 更新这个宏时，注意到 <strong>expr</strong> 参数，我们为其创建了一个 gensym 的那个参数，只执行了一次。 这里我们用 <strong>defmacro</strong> 表示该参数被调用 <strong>o!expr</strong> 时只需要执行一次。 这个 <strong>nif</strong> 的实现代表了这个宏演变的最后一步。</p>
<p><strong>defmacro!</strong> 模糊了宏和函数之间的界限。 正是这个特性，在宏参数中传入一些 O-bang 符号和一些常规符号的能力，使得 <strong>defmacro!</strong> 特别有用。 正如反引号会翻转默认引用行为一样，<strong>defmacro!</strong> 可以将宏参数中的求值语义从常规未求值的宏结构，翻转为从左到右的单独求值的 lambda 参数。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3.5-unwanted-capture.html" class="btn btn-neutral float-left" title="3.5 异常捕获" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="3.7-duality-of-syntax.html" class="btn btn-neutral float-right" title="3.7 语法的二义性" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>