.. _lisp_is_not_functional:

==================================
5.1 Lisp 不是函数式编程语言
==================================

:Author: Doug Hoyte
:Translator: Yuqi Liu <yuqi.lyle@outlook.com>

对 Lisp 常见的一种偏见是将其叫做函数式编程语言。但 lisp 不是函数式语言。事实上，lisp 是有史以来最不像函数式的语言。这个误解的根源很有趣，同时也是个很好例子，说明了一个小的用词不当可以产生持久的影响，并在用词不当的原因变得无关紧要之后很长时间内导致混淆。什么是函数式编程语言呢？唯一有意义的定义是::

  函数式编程语言是由函数构成的语言

那么，什么是函数呢？函数是数学中的一个概念，已经存在了几个世纪::

  函数是一个静态的，定义好的从输入到输出的映射关系

在 lisp 中，我们使用 ``defun`` 来定义新函数。例如，下面的函数使用求和将所有数字的集合映射到一个新集合，这个新集合也包括所有数字：

.. code-block::

  (defun adder (x)
     (+ x 1))

显然，我们可以将这段代码应用于任意数字，获得映射后得到的返回值，但 ``adder`` 真的是个函数吗？好吧，令人困惑的是，lisp 认为它是：

.. code-block::

  * (describe #'adder)
  #<Interpreted Function> is a function.

.. note::

  如果你之前没有在 Common Lisp 中见过 ``describe`` 函数的话，现在可以试一下。该函数是返回函数、特殊表格、宏、变量、符号以及闭包的描述。

但是把 ``adder`` 称为函数是 lisp 历史中最根深蒂固的误解之一。``defun`` 和 lambda 表达式实际上创建的是个过程（procedures），或者更确切的说，一个可被调用的实例。这有什么区别呢？过程不一定与值的映射有任何关系，而是可执行的代码段（函数调用），可能是保存的环境变量。当 lisp 程序员用 *函数式风格* 来写代码时，之后就导致过程（procedures）能被认为是数学风格的函数映射，同时可以将过程（procedures）组合在一起来假装成函数映射。

Lisp 之所以经常被误称为函数式编程语言是有历史原因的。信不信由你，有段时间大部分语言甚至都不支持过程（procedures）这一概念，而现代程序员认为在所有的语言中过程是理所当然的。早期的一些语言在可复用的代码中并没有提供给局部变量合适的抽象，程序员们只能通过手动分配寄存器和操作堆栈来实现这中操作。Lisp，至始至终就有过程，似乎比那些语言更具备函数式的特性。

接下来，过程抽象得到应有的重视，并被纳入几乎所有编程语言，随后大家就开始慢慢地遇到障碍，因为他们所实现的过程的性质有限。然后程序员们开始意识到，他们可以从其他的过程中返回过程、把它们嵌入到新的环境中、聚合到一个数据结构中，或者更通用的是，将过程作为任意常规的值。于是就出现了个口号来动员程序员进行下一代的大抽象推进：a society without classes, first-class procedures。与那些将过程降级到次等二级类的语言相比，lisp，这种一直拥有这些一级过程的语言，似乎更具被函数式的特性。

最后，大部分语言为了支持某些糟糕的 *Blub* 语法（如中缀赋值），在表达式和语句之间做了无意义的区分。在 lisp 中，语句都会返回某些值，同时对代码的嵌套和组合也没有任何限制（语法方面）。这是个很简单的问题，答案也显而易见：在一门语言中，对新手友好的语法和真正的灵活性哪个更重要？中缀语法的语言在许多方面降低了其抽象的可能性。幸运的是，大多数现代语言决定给予用户足够的信任，允许他们根据自己的需要来组合表达式。与那些做出这些脑残语法决定的语言相比，lisp 看起来更具备函数式的特性。

在熟悉了这个普遍存在但却被误导的术语之后，程序员们开始意识到，在函数式编程语言和非函数式编程语言之间的争论中使用的函数概念不仅令人困惑，同时也是本末倒置。为了纠正这个错误，程序员和学者们都回到黑板前，回到了函数的数学定义：从输入到输出的映射。如果 lisp 在某种程度上是函数式语言，那么它与Perl 和 Javascript 等现代语言一样。

显然，lisp 过程不是函数。Lisp 过程可以返回非静态值，也就是说，可以使用相同的参数多次调用，每次接收不同的返回值。就像我们前面章节的例子一样，lisp过程可以通过封装变量来存储状态。``rplaca`` 这样的过程可以改变内存或其他地方（如寄存器）中的值。``terpri`` 和 ``format`` 这样的 lisp 过程会产生指向终端或文件的输出（在 ``terpri`` 情况下是换行）。``yes-or-no-p`` 这样的 lisp 过程会从终端中读取输入，然后根据输入返回对应的值。难道这些过程都是静态的、定义好的映射吗？

.. note::

  ``Terpri`` 和 ``rplaca`` 这两个操作符都合理地阐述了 COMMON LISP 操作符糟糕命名的区别

因为 lisp 过程不是数学函数，所以 lisp 也就不是函数式编程语言。事实上，一个强有力的论点是 lisp 比大多数其他语言更不像函数式。大部分语言中，看起来像过程调用的表达式都是被语言的语法强制为过程调用。而在 lisp 中，我们有宏。正如我们所看到的，宏可以隐式地将某些形式的含义从函数调用改变为 lisp 表达式，这种技术在许多方面违反了引用透明性，这在其他语言中是不可能的。

考虑到大多数语言实际上根本不是函数式的，一些语言设计者决定弄清楚在真正的函数式语言中编程是什么样子的。不出所料，编程函数式语言大多是令人讨厌和不切实际的。从输入值到输出值的静态、定义良好的映射几乎不能有效地表示现实世界中的问题。也就是说，函数式编程并非没有优点，许多语言都被设计为利用函数式编程风格。这意味着找到一种方便的方法，将程序的功能部分与(实际上有趣的)非功能部分隔离开来。``Haskell`` 和 ``Ocaml`` 这样的语言就是使用这种隔离作为进行积极优化假设的方法。

但这是 lisp。我们很不函数式并以此为豪。在某种程度上，这种副作用的隔离很有用，lisp 程序员可以并且确实能使用宏来实现它。函数式编程背后真正的目的是将应该发生什么的函数描述与实际发生的机制分离开来。Lisp 肯定不是函数式，但由于宏的存在，没有比 Lisp 更好的实现函数式语言的平台或工具。
