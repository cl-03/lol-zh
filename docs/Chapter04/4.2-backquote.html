<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4.2 Backquote &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="4.3 Reading Strings" href="4.3-reading-strings.html" />
    <link rel="prev" title="4.1 Run-Time at Read-Time" href="4.1-runtime-at-readtime.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第四章：Read 宏</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="4.1-runtime-at-readtime.html">4.1 Run-Time at Read-Time</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.2 Backquote</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.3-reading-strings.html">4.3 Reading Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.4-cl-ppcre.html">4.4 CL-PPCRE</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.5-cyclic-expressions.html">4.5 Cyclic Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.6-reader-security.html">4.6 Reader Security</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第四章：Read 宏</a> &raquo;</li>
      <li>4.2 Backquote</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter04/4.2-backquote.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="backquote">
<h1>4.2 Backquote<a class="headerlink" href="#backquote" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p><em>Backquote</em>, sometimes known as <em>quasiquote</em><a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap4.html#">2</a>, and displayed as `, is a relative new-comer to mainstream lisp programming, and the concept is still almost completely foreign to languages other than lisp.</p>
<p>Backquote has a bizarre history of development in parallel with lisp. It is reported[QUASIQUOTATION] that early on nobody believed that nested backquotes worked right until a sharp programmer realised that they actually did work right—people’s ideas of what was right were wrong. The nested backquote is notoriously difficult to understand. Even Steele, the father of COMMON LISP, complains about it[CLTL2-P530].</p>
<p>In principle, lisp doesn’t need backquote. Anything that can be done with backquote can be done with other list building functions. However, backquote is so useful for macro programming, which in lisp means all programming, that lisp professionals have come to rely on it heavily.</p>
<p>First off, we need to understand regular quotation. In lisp, when we prefix a form with the quote character (’) we are informing lisp that the following form should be treated as raw data, and not code to be evaluated. Rather, quote reads in as code that, when evaluated, returns a form. We sometimes say that quote <em>stops</em> or <em>turns off</em> the evaluation of a form.</p>
<p>Backquote can be used as a substitute for quote in lisp. Unless certain special characters, called <em>unquote</em> characters, appear in a form, backquote stops evaluation in the same way as quote. As the name suggests, these unquote characters reverse the evaluation semantics. We sometimes say that an unquote <em>restarts</em> or <em>turns back on</em> the evaluation of a form.</p>
<p>There are three main types of unquote: regular unquote, splicing unquote, and destructive splicing unquote.</p>
<p>To perform a regular unquote, we use the comma operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (let ((s &#39;hello))
    `(,s world))

(HELLO WORLD)
</pre></div>
</div>
<p>Although the expression we are unquoting is simply a symbol to evaluate, <strong>s</strong>, it can instead be any lisp expression that evaluates to something meaningful for whatever context it appears in the backquote template. Whatever the results are, they are inserted into the resulting list in the car position of where they appear in the backquote template.</p>
<p>In lisp form notation, we can use . to indicate that we want to explicitly put something in the cdr of the list structure we are creating. If we put a list there, the resulting form from the backquote will remain a valid list. But if we put something else there, we will get a new, non-list structure.</p>
<p>We have this ability inside of backquote like everywhere else<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap4.html#">3</a>. Thanks to the design of backquote, we can even unquote things in this position:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (let ((s &#39;(b c d)))
    `(a . ,s))

(A B C D)
</pre></div>
</div>
<p>Inserting lists into the cdr position of a list being created from a backquote template is so common that backquote takes it a step further with splicing unquote. The ., combination above is useful, but is incapable of inserting elements into the middle of a list. For that, we have the splicing unquote operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (let ((s &#39;(b c d)))
    `(a ,@s e))

(A B C D E)
</pre></div>
</div>
<p>Neither ., nor ,&#64; modify the list being spliced in. For instance, after evaluating the backquote in both of the previous forms, <strong>s</strong> will still be bound to the three element list <strong>(B C D)</strong>. Although it is not strictly required to by the standard, the <strong>(B C D)</strong> in the <strong>(A B C D)</strong> form above is allowed to share structure with the spliced-in list, <strong>s</strong>. However, in the list <strong>(A B C D E)</strong>, this list structure is guaranteed to be freshly allocated when the backquote is evaluated since ,&#64; is forbidden to modify the lists being spliced in. Splicing unquote is non-destructive because generally we want to think about backquote as being a re-usable template for creating lists. Destructively modifying the list structure of data that isn’t freshly allocated on every evaluation of the backquote code can have undesirable effects upon future expansions.</p>
<p>However, COMMON LISP also provides a destructive version of splicing unquote which can be used anywhere splicing unquote can. To splice destructively, use ,. instead. Destructive splicing works the same as regular splicing except that the list being spliced in may be modified during the evaluation of the backquote template. As well as being only one character different from regular splicing, this notation is a clever re-use of the . character from the ., cdr position unquoting we looked at above.
To see this in action, here we destructively modify the list pointed to by to-splice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (defvar to-splice &#39;(B C D))

TO-SPLICE
* `(A ,.to-splice E)

(A B C D E)
* to-splice

(B C D E)
</pre></div>
</div>
<p>Destructively modifying lists to be spliced in can be dangerous. Consider the following use of destructive splicing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun dangerous-use-of-bq ()
  `(a ,.&#39;(b c d) e))
</pre></div>
</div>
<p>The first time <strong>dangerous-use-of-bq</strong> is called, the expected answer is returned: <strong>(A B C D E)</strong>. But since it uses destructive splicing and modifies a list that isn’t freshly generated—the quoted list—we can expect various undesirable consequences. In this case, the second time <strong>dangerous-use-of-bq</strong> is evaluated, the <strong>(B C D)</strong> form is now really a <strong>(B C D E)</strong> form, and when backquote tries to destructively splice this list onto the remainder of the backquote template, <strong>(E)</strong>—its own tail—it creates a list containing a <em>cycle</em>. We discuss cycles in more detail in <a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap4.html#sec_5">section 4.5, Cyclic Expressions</a>.</p>
<p>However, there are many cases where destructive splicing is perfectly safe. Don’t let <strong>dangerous-use-of-bq</strong> scare you if you need more efficiency in your backquote forms. There are many operations that create fresh list structure that you are probably planning on throwing out anyways. For instance, splicing the results of a mapcar is so common and safe that the following could probably become a programming idiom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun safer-use-of-bq ()
  `(a
    ,.(mapcar #&#39;identity &#39;(b c d))
    e))
</pre></div>
</div>
<p>But there is a reason it hasn’t. The most common use of backquote is for authoring macros, the part of lisp programming where speed matters least and where clarity matters most. If thinking about the <em>side-effects</em> of your splicing operations distracts you even for a split second while creating and interpreting macros, it is probably not worth the trouble. This book sticks with regular splicing. The most common use of backquote is in macro construction but this is not its only use. Backquote is actually a useful domain specific language for the domain of mashing together lists, one made even more useful given the possibility of destructive splicing.</p>
<p>How does backquote work? Backquote is a read macro. Backquoted forms read in as code that, when evaluated, becomes the desired list. Going back to the example of the previous section on read-time evaluation, we can turn off <em>pretty printing</em>, quote the value of the backquote form, and print it out to see exactly how backquote forms read<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap4.html#">4</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">let</span> <span class="p">(</span><span class="o">*</span><span class="nb">print</span><span class="o">-</span><span class="n">pretty</span><span class="o">*</span><span class="p">)</span> <span class="p">;</span> <span class="n">bind</span> <span class="n">to</span> <span class="n">nil</span>
    <span class="p">(</span><span class="nb">print</span>
      <span class="s1">&#39;`(football-game</span>
          <span class="p">(</span><span class="n">game</span><span class="o">-</span><span class="n">started</span><span class="o">-</span><span class="n">at</span>
            <span class="p">,(</span><span class="n">get</span><span class="o">-</span><span class="n">internal</span><span class="o">-</span><span class="n">real</span><span class="o">-</span><span class="n">time</span><span class="p">))</span>
          <span class="p">(</span><span class="n">coin</span><span class="o">-</span><span class="n">flip</span>
            <span class="p">,(</span><span class="k">if</span> <span class="p">(</span><span class="n">zerop</span> <span class="p">(</span><span class="n">random</span> <span class="mi">2</span><span class="p">))</span>
               <span class="s1">&#39;heads</span>
               <span class="s1">&#39;tails))))</span>
    <span class="n">t</span><span class="p">)</span>

<span class="p">(</span><span class="n">LISP</span><span class="p">::</span><span class="n">BACKQ</span><span class="o">-</span><span class="n">LIST</span>
  <span class="p">(</span><span class="n">QUOTE</span> <span class="n">FOOTBALL</span><span class="o">-</span><span class="n">GAME</span><span class="p">)</span>
  <span class="p">(</span><span class="n">LISP</span><span class="p">::</span><span class="n">BACKQ</span><span class="o">-</span><span class="n">LIST</span>
    <span class="p">(</span><span class="n">QUOTE</span> <span class="n">GAME</span><span class="o">-</span><span class="n">STARTED</span><span class="o">-</span><span class="n">AT</span><span class="p">)</span>
    <span class="p">(</span><span class="n">GET</span><span class="o">-</span><span class="n">INTERNAL</span><span class="o">-</span><span class="n">REAL</span><span class="o">-</span><span class="n">TIME</span><span class="p">))</span>
  <span class="p">(</span><span class="n">LISP</span><span class="p">::</span><span class="n">BACKQ</span><span class="o">-</span><span class="n">LIST</span>
    <span class="p">(</span><span class="n">QUOTE</span> <span class="n">COIN</span><span class="o">-</span><span class="n">FLIP</span><span class="p">)</span>
    <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">ZEROP</span> <span class="p">(</span><span class="n">RANDOM</span> <span class="mi">2</span><span class="p">))</span>
      <span class="p">(</span><span class="n">QUOTE</span> <span class="n">HEADS</span><span class="p">)</span>
      <span class="p">(</span><span class="n">QUOTE</span> <span class="n">TAILS</span><span class="p">))))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>In the above <em>ugly printed</em> form, the function <strong>LISP::BACKQ-LIST</strong> is identical to list, except for its pretty printing behaviour. Notice that the comma operators are gone. COMMON LISP is fairly liberal in what it allows backquote to read in as, particularly for operations where shared structure is permitted.</p>
<p>Backquote also provides many interesting solutions to the amusing <em>non-problem</em> of writing a lisp expression that evaluates to itself. These expressions are commonly called <em>quines</em> after Willard Quine who studied them extensively and who, in fact, coined the term quasiquote—an alternative name for backquote[FOUNDATIONS-P31-FOOTNOTE3]. Here is a fun example of a quine that is attributed to Mike McMahon in [QUASIQUOTATION]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* (let ((let &#39;`(let ((let &#39;,let))
                 ,let)))
    `(let ((let &#39;,let)) ,let))

(LET ((LET &#39;`(LET ((LET &#39;,LET))
               ,LET)))
  `(LET ((LET &#39;,LET)) ,LET))
</pre></div>
</div>
<p>To save you the <em>mental code-walk</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">equal</span> <span class="o">*</span> <span class="o">+</span><span class="p">)</span>

<span class="n">T</span>
</pre></div>
</div>
<p>Exercise: In the following evaluation, why is the backquote expanded into a regular quote? Isn’t it quoted?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="s1">&#39;`q</span>
<span class="s1">&#39;Q</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="4.1-runtime-at-readtime.html" class="btn btn-neutral float-left" title="4.1 Run-Time at Read-Time" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="4.3-reading-strings.html" class="btn btn-neutral float-right" title="4.3 Reading Strings" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>