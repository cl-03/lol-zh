# 3.7 Duality of Syntax

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

lisp 有个重要的概念称为语法二义性。 理解二义性及其重要性是编写宏和本书的基本主题。 二义性有时是设计出来的，有时是意外发现的。 对于非 lisp 语言的程序员来说，二义性语法的现实令人难以置信，以至于无法在本书中进行描述，所以我们现在回避直接定义。 相反，你，本书的读者，会一次又一次地发现它，因为它是慢慢地进行应用来避免震惊到你。 如果在阅读本书过程中感到头痛或其他不适，建议立即执行垃圾回收周期（睡一觉），然后以新鲜和开放的心态返回。

引用透明有时被视为为代码的一种属性，其中表达式都可以插入到任何地方且总是具有相同的含义。 引入句法二义性是有意识地违反引用透明，探索二义性正在收获一种允许这种违反（引用透明）的语言的果实。 其他语言只能用半透明的玻璃板进行构建，但 lisp 可以使用各种烟雾、镜子和棱镜。 这个魔法就是宏，宏的大部分精妙的技巧都是基于句法二义性。

本节描述了一种我们已经讨论过但还没完全探索的一个重要的二义性语法：COMMON LISP 使用相同的语法来访问两种主要类型的变量，即动态变量和词法变量。 本书试图讲解动态和词法作用域的真正威力，以及为什么 COMMON LISP 决定用二义性语法是真么重要。

动态作用域的作用是提供一种方法，可以根据表达式的执行时间而不是定义或编译的位置，将值传给和输出 lisp 表达式。幸运的是，COMMON LISP 为此定义的语法与用于访问词法变量的语法相同，这与动态变量完全相反，因为它们总是引用它们被编译的位置，而与何时发生访问无关。事实上，如果没有声明结构的外部上下文，就无法判断表达式所指的是哪种类型的变量。这种二义性语法违反了引用透明，但不是要避免，lisp 程序员对此表示欢迎，因为就像无法在没有上下文的情况下区分表达式一样，宏也不能。先考虑以下这个想法。首先，先明确为动态变量创建绑定不会创建词法闭包。例如，重新绑定之前声明的变量 **temp-special**：
```
* (let ((temp-special 'whatever))
    (lambda () temp-special))

#<Interpreted Function>
```
尽管上面是一个 let over lambda，但这不是一个词法闭包。 这是在某些动态上下文中对 lambda 宏结构的简单执行，这当然会导致匿名函数。 此函数在应用时将访问当前存在的任何动态环境并获取 **temp-special** 的值。 当 lambda 宏执行时，**temp-special** 到符号的动态绑定，符号 **'whatever** 也存在，但谁在乎呢？ 记住，lambda 结构是常量对象，只是简单的机器代码指针返回器，因此执行此 lambda 结构甚至永远不会访问动态环境。 我们的符号会发生什么？ 在 lisp 完成对 lambda 结构的执行后，会将其从动态环境中删除并丢弃，变成未使用。

一些早期的 lisp 确实支持动态闭包，这意味着在非空动态环境中定义的每个函数都有自己的（可能部分共享）动态绑定堆栈。 其效果类似于 COMMON LISP 的词法作用域，并使用称为*意大利面条堆栈（spaghetti stack）*[SPAGHETTI-STACKS][INTERLISP-TOPS20] 的东西来实现。 这种数据结构不再是堆栈数据结构，而是实际上是一个多路径、垃圾收集的网络。 COMMON LISP 取消了意大利面条堆栈，只提供了词法闭包[MACARONI]。

因此词法变量和动态变量实际上是完全不同的，完完全全的不同概念，它们恰好在 COMMON LISP 代码中语法相同而已。我们到底为什么要这种所谓的二元性语法呢？答案很微妙，只有少数 lisp 程序员有意识地欣赏它，但它是如此基础，值得仔细研究。这种二义性语法允许我们编写一个具有单个通用接口的宏，用于创建在动态和词法上下文中都很有用的扩展。尽管宏的展开的含义在它们的上下文中可能完全不同，即使其内部可能意味着完全不同的东西，我们仍然可以使用相同的宏以及该宏与其他宏的相同组合。换句话说，宏不仅在其宏参数的内容上产生矛盾，在其展开的不同含义上也可能产生矛盾。我们可以使用宏来理解代码转换，而忽略代码的语义含义，这一切都是因为代码只有在调用的地方才有意义——在宏处理期间它没有意义。语法的二元性越多，关联的宏就越强大。本书详细介绍了很多二义性语法优势的示例。动态变量和词汇变量之间的二义性是这种 lispy 哲学的一个轻微（但有用）的例子。一些宏是为具有强大的二义性的特定目的而创建的，有时一个展开式可能会有两个以上的含义。

COMMON LISP 代码中的默认是在特殊变量前后添加星号（*）。 例如，可能将 **temp-special** 变量命名为 __*temp-special*__。 因为这个默认风格几乎就像为动态变量提供另一个命名空间，减少了它们与词法变量的二义性，所以本书并没有完全遵循它。 星号只是默认风格，幸运的是，COMMON LISP 没有强制要求使用。 我们不仅可以将星号从特殊变量名中去掉，而且可以将它们添加到词法变量名中。 可能这只是风格问题。 哪种风格的弊端更小：带有星号的词法变量或没有星号的特殊变量？ 我个人认为这两者中更简洁（不带星号）的弊端更小。 此外，词法和特殊变量的名称可以是 gensyms，这是个超越符号上的打印名称的概念。

因此，如前所述，这本书劫持了通用的星号约定。 本书不用带星号的变量名称表示特殊变量，而是用带星号的变量名称表示标准定义的特殊变量。

我放弃这些耳罩式变量名的最大动机是简单且主观的：我认为它们打起来很麻烦且让代码很难看。 我不会建议你为自己的程序这样做，只是提到我多年来一直不使用耳罩式的变量同时对 COMMON LISP 非常满意。
