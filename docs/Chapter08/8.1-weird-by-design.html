<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8.1 奇怪的设计 &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="8.2 cons 线程代码" href="8.2-cons-threaded-code.html" />
    <link rel="prev" title="第八章：Lisp 与 Forth" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第八章：Lisp 与 Forth</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">8.1 奇怪的设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.2-cons-threaded-code.html">8.2 cons 线程代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.3-duality-of-syntax-defined.html">8.3 语法二元性</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.4-going-forth.html">8.4 开始构建 forth</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.5-going-forther.html">8.5 forth 的拓展</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.6-going-lisp.html">8.6 在 forth 中写 lisp 代码</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第八章：Lisp 与 Forth</a> &raquo;</li>
      <li>8.1 奇怪的设计</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter08/8.1-weird-by-design.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>8.1 奇怪的设计<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>本章是迄今为止我们在本书中看到的许多宏技术的高潮。 使用已开发的宏抽象，我们创建了我最喜欢的编程语言之一的实现：forth。 虽然这个实现体现了 forth 的大部分重要思想，但它非常不同并且很混乱。 尽管本章中的代码有一些有趣的用途，但主要目的是向 lisp 读者教授 forth 元编程的概念和基础知识，并成为讨论本书中心主题的平台——用宏创建和使用二元性语法。</p>
<p>Forth，比除了 lisp 外所有语言都拥有丰富而迷人的历史，我很感激发现它。 出于这个原因，以及其他一切，这一章是献给我的父亲 Brian Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;
的，他向我介绍了 forth 和计算机编程。 本章的部分灵感来自 [THREADING-LISP] 和 Henry Baker [LINEAR-LISP][LINEAR-LISP-AND-FORTH] 的研究。</p>
<p>Forth 是第一个在没有强力的政府、学术或企业赞助的情况下创建和开发的编程语言——或者至少是第一个成功的此类语言。 1968 年左右，Chuck Moore 独立发明了forth，而不是出于大型组织的需求，以解决他自己在天文学、硬件设计等方面的计算需求。 从那时起，forth 已被热情的草根用户社区分发、实现和改进[EVOLUTION-FORTH-HOPL2]。 与麻省理工学院（以及后来的 DARPA）对早期 lisp 和 Common Lisp、IBM 的 FORTRAN 和 AT&amp;T 的 unix 语言 C 的赞助形成对比。</p>
<p>由于这些原因，并且因计算机软件和硬件角色的普遍不同的哲学，所以 forth 是不同的。 甚至比 lisp 还要多，forth 看起来很奇怪。 但是和 lisp 一样，forth 看起来很奇怪是有原因的：它的设计考虑了更多而不是格式。 Forth 在设计上很奇怪，而且这种设计与宏有关。</p>
<p>如今，forth 常见于所谓的嵌入式平台——资源严重受限的计算机。 可以在几乎所有曾经创建的可编程计算机系统上完全实现该语言，这证明了该语言的设计。 Forth 被设计成尽可能容易实现和试验。 事实上，创建 forth 的克隆是如此的微不足道，以至于发明一两种基于堆栈的 forth 语言对于对编程语言设计感兴趣的程序员来说几乎是一种仪式。 PostScript 和 Joy 这些基于堆栈的语言，它们可以追溯到 forth 并做出了有趣的贡献。</p>
<p>重要的 forth 实现决策通常基于正在实现 forth 的计算机的确切资源。 Forth 程序员设计了一组抽象寄存器，这些寄存器要么映射到真实寄存器，要么映射到内存位置，或者可能以完全不同的方式实现。 但是，如果我们在 lisp 上实现 forth，一个潜力无限且限制很少的环境，该怎么做呢？ 不是简单地将 forth 抽象寄存器的任意映射强加到 lisp 代码中，而是尝试退后一步。 如果 Chuck 有一个 lisp 机器会是什么样子？ 与其适应任意机器的功能，无论是真实的还是虚拟的，我们探索了一组最小的抽象寄存器，在 lisp 上实现时针对简单性和功能进行了优化。</p>
<p>但实际上，寻找一组最优的抽象概念是 Chuck 在创建 forth 时所做的，应用了他在很多架构上的数十种不同的 forth 实现经验。 这就是为什么 forth 如此伟大。 与 lisp 一样，forth 代表了语言设计空间中的高局部最大值，并且与 lisp 一样，forth 与其说是门编程语言或标准，不如说是种构建材料和智慧的集合，关于什么有效，什么无效。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defvar</span> <span class="n">forth</span><span class="o">-</span><span class="n">registers</span>
  <span class="s1">&#39;(pstack rstack pc</span>
    <span class="nb">dict</span> <span class="n">compiling</span> <span class="n">dtable</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">forth-registers</span></code>表示 forth 机器的抽象寄存器的符号列表。 当然 lisp 不考虑寄存器和固定数字，而是变量和符号。 在这里开始我们开发 forth 环境看起来可能很奇怪，只有一个变量名列表，但实际上这始终是实现 forth 系统的第一步。 创造 forth 是个巧妙的引导过程，在美丽和聪明方面只有 lisp 才能超越。 以下是对该过程的适度描述。</p>
<p>forth 的特征之一是它直接访问程序使用的堆栈数据结构，既可以将参数传递给子例程，也可以跟踪这些子例程中的执行路径。 Forth 特别有趣，因为与大多数编程语言不同，它将堆栈数据结构的这两种用途分为两个堆栈，这两个堆栈你设置可以玩弄它。 在典型的 C 实现中，函数调用的参数及其所谓的返回地址存储在单个、可变大小的堆栈帧中，用于每个函数调用。 forth，它们是两个不同的堆栈，称为参数堆栈和返回堆栈，分别表示为我们的抽象寄存器 <code class="docutils literal notranslate"><span class="pre">pstack</span></code>和 <code class="docutils literal notranslate"><span class="pre">rstack</span></code>。 我们使用 Common Lisp 的 push 和 pop 宏，这意味着这些堆栈是用 cons 单元链表实现的，而不是大多数使用的数组数据结构。</p>
<p>抽象寄存器 pc 是程序计数器的缩写，一个指向当前正在执行的代码的指针。 我们将很快解释什么是代码以及如何指向它，以及我们的抽象寄存器编译和 dtable。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defstruct</span> <span class="n">forth</span><span class="o">-</span><span class="n">word</span>
  <span class="n">name</span> <span class="n">prev</span> <span class="n">immediate</span> <span class="n">thread</span><span class="p">)</span>
</pre></div>
</div>
<p>另一个构建 forth 模块是其字典概念。  forth 字典是 forth words 的单链表，类似于lisp函数。 words 用 lisp 结构表示。 结构是基于槽的有效数据结构，通常用向量实现。 word 槽是用于在字典中查找单词的符号。 请注意，forth 字典不是按字母顺序存储的，而是按时间顺序存储的。 当添加新单词时，会将新的 words 追加到字典的末尾，以便在遍历字典时首先检查最新定义的 words。 字典的最后一个元素总是存储在抽象寄存器字典中。 为了遍历字典，从 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 开始并跟随单词结构的 prev 指针，prev 指针指向先前定义的 word，如果是最后一个 word 的话，prev 指针指向 nil。</p>
<p>给定 <code class="docutils literal notranslate"><span class="pre">w</span></code>，一个要查找的单词，最后是要检索的字典，根据单词 <code class="docutils literal notranslate"><span class="pre">w</span></code> 是否在字典中找到，<code class="docutils literal notranslate"><span class="pre">forth-lookup</span></code>将返回个 forth 单词结构或 nil。 使用比较函数 <code class="docutils literal notranslate"><span class="pre">eql</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 是因为 —— 与 lisp 不同 —— forth 允许用数字和其他非符号命名单词。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">forth</span><span class="o">-</span><span class="n">lookup</span> <span class="p">(</span><span class="n">w</span> <span class="n">last</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="n">last</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eql</span> <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">word</span><span class="o">-</span><span class="n">name</span> <span class="n">last</span><span class="p">)</span> <span class="n">w</span><span class="p">)</span>
      <span class="n">last</span>
      <span class="p">(</span><span class="n">forth</span> <span class="o">-</span><span class="n">lookup</span>
        <span class="n">w</span> <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">word</span><span class="o">-</span><span class="n">prev</span> <span class="n">last</span><span class="p">)))))</span>
</pre></div>
</div>
<p>forth 词的 immediate 槽是个标志，指示该单词是否是立即的。即时性是 forth 元编程概念，我们将很快深入探讨。现在这里是一个与其 lisp 对应物的粗略类比：立即字就像 lisp 宏，因为它们是在编译时而不是运行时执行的 forth 函数。什么？只有 lisp 应该有宏。虽然 Common Lisp 宏系统确实比任何其他宏系统（包括最佳的 forth）强大得多，但 forth 的扩展能力几乎超过了所有其他语言。与 lisp 一样，这种能力是一种设计理念的结果：如果它对语言实现者来说足够好，那么对于应用程序程序员来说也足够好。像 lisp 一样，forth 并没有真正认识到原始的概念。相反，它提供了一组元基元，可以将它们组合起来以构建你（程序员）想要的语言。与 lisp 一样，与大多数 Blub 语言不同，通过使用宏以新颖的方式扩展语言不仅是可能的，而且是鼓励的。像 lisp 一样，forth 与格式无关，而与强大有关。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="第八章：Lisp 与 Forth" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="8.2-cons-threaded-code.html" class="btn btn-neutral float-right" title="8.2 cons 线程代码" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>