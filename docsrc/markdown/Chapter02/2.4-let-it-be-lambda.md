---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle%40outlook.com)>

---

**Let** 是 Lisp 中特殊的表单，用于创建并初始化相应表单名称(绑定)的环境。这些名称对于 **let** 主体中有效是，且该求值是连续的，并返回最终表单的结果。虽然 **let** 做了什么很明确，但具体是怎么做的却没指明。 **let** 结果与过程是分离的。在某种程度上，**let**​ 需要提供一个数据结构来存储指向值的指针。


正如前面所介绍的那样，cons 的结构适用于存储指针，这点毋庸置疑。同时，还有很多其他的结构可以用来存储指针。在 lisp 中存储指针的最佳方法之一就是使用** let **表格结构。在 **let**结构中，你只需要给指针命名就好，之后 lisp 会计算出怎样最好地存储指针。有时，我们可以通过声明的形式提供额外的信息，用来提高编译器的效率，如下面的代码所示：
```
(defun register-allocated-fixnum ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((acc 0))
    (loop for i from 1 to 100 do
      (incf (the fixnum acc)
            (the fixnum i)))
    acc))
```
例如，在 **register-allocated-fixnum** 中，我们向编译器提供了一些提示，让其可以高效地将 1 到 100 的整数相加。 编译后，此函数将在寄存器中分配数据，完全不需要指针。 尽管我们似乎已经要求 lisp 创建一个无限范围的环境来保存 **acc** 和 **i**，但 lisp 编译器将能够通过仅将值存储在 CPU 寄存器中来优化此函数。 结果可能是以下的机器代码：
```
; 090CEB52:       31C9             XOR ECX, ECX
;       54:       B804000000       MOV EAX, 4
;       59:       EB05             JMP L1
;       5B: L0:   01C1             ADD ECX, EAX
;       5D:       83C004           ADD EAX, 4
;       60: L1:   3D90010000       CMP EAX, 400
;       65:       7EF4             JLE L0
```
注意，地址 **4** 中存储的是 **1**，**400** 中存储的是 **100**，因为在编译后的代码中，**fixnums** 移动了两位。 这与标记有关，这是一种假装某些东西是指针但实际上在其中存储数据的方法。 lisp 编译器的标记方案有一个很好的好处，即不需要发生移位来索引字对齐内存[DESIGN-OF-CMUCL]。 我们将在[第 7 章：宏效率主题](../Chapter07/index.rst)中深入了解 lisp 编译器。


但是，如果 lisp 确定之后可能要引用此环境，则它必须使用比寄存器更短暂的东西。 在环境中存储指针的常见结构是数组。 如果每个环境都有一个数组，并且包含在该环境中的所有变量引用都只是对该数组的引用，那么就有一个具有潜在无限范围的高效环境。


如上所述，**let** 将返回其主体中最后一个条语句执行的结果。 这对很多 lisp 特殊形式和宏来说很常见，因此这种模式通常被称为隐式 **progn**，因为 **progn** 特殊结构设计为除了此之外什么都不做。 有时让 **let** 结构返回最有价值的东西是一个匿名函数，它利用了**let** 结构提供的词法环境。 为了在 lisp 中创建这些函数，就要用到 _lambda_。


Lambda 是一个简单的概念，但因其灵活性和重要性而令人生畏。 lisp 和 scheme 的 lambda 源于 Alonzo Church 的逻辑系统，但已经发展并适应城自己的 lisp 规范。 Lambda 是一种简洁的方法，可以重复地将临时名称（绑定）分配给特定词汇上下文的值，且是 lisp 函数概念的基础。 lisp 函数与 Church 心目中的数学函数描述非常不同。 这是因为 lambda 在几代 lispers 的手中已经发展成为一种强大而实用的工具，扩展它已经远远超出了早期逻辑学家所能预见的范围。


尽管 lisp 程序员对 lambda 表示敬意，但该符号本身并没有什么特别之处。 正如我们将看到的，lambda 只是表达这种变量命名的许多可能方式之一。 特别是，我们将看到宏可以以其他编程语言实际上不可能的方式自定义变量的重命名。 但是在探索了这一点之后，我们将回到 lambda 并发现它非常接近于表达这种命名的最佳符号。 这绝非偶然。 Church 在我们的现代编程环境中可能看起来过时且无关紧要，但他确实在做某事。 他的数学符号，以及它在几代 lisp 专业人士手中的众多改进，已经发展成为一种灵活、通用的工具。


Lambda 非常有用，就像许多 lisp 的功能一样，大多数现代语言都开始将 lisp 的想法导入到自己的系统中。 一些语言设计者觉得 lambda 太冗长，而使用 **fn** 或其他一些缩写。 另一方面，有些人认为 lambda 是个很基本的概念，所以用叫短的名字来掩盖它几乎是异端邪说。 在本书中，虽然我们将描述和探索 lambda 的许多变体，但我们很高兴地称它为 lambda，就像我们之前的几代 lisp 程序员一样。


但是 lisp 的 lambda 是什么？ 首先，与 lisp 中的所有名称一样，lambda 是个符号。 我们可以引用它，比较它，将它存储在列表中。 Lambda 仅在作为列表的第一个元素出现时才具有特殊含义。 当它出现在那里时，该列表被称为 lambda 形式或函数指示符。 但是这种形式不是函数。 这种形式是一个列表数据结构，可以用 **function** 关键词将其转换为函数：
```
* (function '(lambda (x) (+ 1 x)))

#<Interpreted Function>
```
COMMON LISP 使用 **#'**（井号加单引号）读取宏为我们提供了个方便的简写。 为了达到同样的效果，可以使用这个简写，而不是像上面那样编写函数：
```c
* #'(lambda (x) (+ 1 x))

#<Interpreted Function>
```
作为一个很方便的特性，lambda 也被定义为一个宏，它扩展为对上述特殊形式的函数的调用。 COMMON LISP ANSI 标准需要 [ANSI-CL-ISO-COMPATIBILITY] 一个 **lambda** 宏，定义如下：
```
(defmacro lambda (&whole form &rest body)
  (declare (ignore body))
  `#',form)
```
先忽略定义的具体代码。 这个宏只是一种将函数特殊形式自动应用于函数指示符的简单方法。 这个宏允许我们执行函数指示符以创建函数，因为它们被扩展为 **#'** 形式：
```
* (lambda (x) (+ 1 x))

#<Interpreted Function>
```
因为 lambda 宏，几乎没有理由在 lambda 结构前面加上 **#'**。 因为本书不支持 ANSI 之前的 COMMON LISP 环境，所以显而易见是不向下兼容的。 但是对象的格式呢？ Paul Graham 在 ANSI COMMON LISP[GRAHAM-ANSI-CL] 中认为这个宏，连同它的简洁优势，“充其量是一种似是而非的优雅”。 格雷厄姆的反对意见似乎是，由于仍然需要对符号引用的函数进行 **#'**，因此系统似乎是不对称的。 但是，我相信非 **#'** lambda 结构实际上是一种风格上的改进，因为它突出了第二个命名空间规范中存在的不对称性。 对符号使用 **#'** 是为了引用第二个命名空间，而由 lambda 形式创建的函数当然是无名的。


甚至无需调用 **lambda** 宏，就可以用 lambda 结构作为函数调用中的第一个参数。 就像在这个位置找到一个符号且 lisp 假设我们正在引用该符号的**symbol-function** 结构一样，如果找到 lambda 结构，则假设它表示一个匿名函数：
```
* ((lambda (x) (+ 1 x)) 2)

3
```
但注意，正如不能调用函数来动态返回要在常规函数调用中使用的符号一样，也不能调用函数以在函数位置返回 lambda 形式。 对于这两种情况，需要使用 **funcall** 或 **apply**。


lambda 表达式在很大程度上与 C 和其他语言中的函数无关，它的好处是 lisp 编译器通常可以将它们完全优化为不存在。 例如，尽管 **compiler-test** 看起来像是对 **2** 应用了一个递增函数并返回结果，但正常的编译器会知道该函数总是返回 **3**，且会直接返回该数字，该过程中不会调用函数。 这叫做 _lambda 折叠_：
```c
(defun compiler-test ()
  (funcall
    (lambda (x) (+ 1 x))
    2))
```
一个重要的有效观察是编译的 lambda 结构是个常量结构。 这意味着在程序编译后，对该函数的所有引用都只是指向一块机器代码的指针。 该指针可以从函数返回并嵌入到新环境中，所有这些都没有函数创建开销。 编译程序时吸收了开销。 换句话说，返回另一个函数的函数将只是个指针返回函数常量时间：
```
(defun lambda-returner ()
  (lambda (x) (+ 1 x)))
```
这与 **let** 结构形成鲜明对比，后者旨在在运行时创建一个新环境，因此通常不是个恒定的操作，因为词法闭包隐含的垃圾收集开销是无限的。
```
(defun let-over-lambda-returner ()
  (let ((y 1))
    (lambda (x)
      (incf y x))))
```
每次调用 **let-over-lambda-returner** 时，它必须创建一个新环境，将指向 lambda 结构表示的代码的常量指针嵌入到这个新环境中，然后返回结果闭包。 可以用 **time** 来看看这个环境有多小：
```
* (progn
    (compile 'let-over-lambda-returner)
    (time (let-over-lambda-returner)))

; Evaluation took:
;   ...
;   24 bytes consed.
;
#<Closure Over Function>
```
如果你尝试在闭包上调用 **compile**，将得到一个错误消息，指出无法编译在非空词法环境中定义的函数 [CLTL2-P677]。 你不能编译闭包，只能编译创建闭包的函数。 当编译一个创建闭包的函数时，它创建的闭包也将被编译[ON-LISP-P25]。


使用包含上述 lambda 的 let 非常重要，我们将在本章的剩余部分中讨论它的模式和变体。
