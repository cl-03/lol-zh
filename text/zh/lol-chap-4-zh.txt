第四章读宏
4.1运行时读取期
分号的语法糖导致癌症。Alan Perlis吗?
lisp提供直接访问代码不仅被解析成一个反对细胞结构,但它也提供了访问字符程序之前,他们甚至达到这一阶段。虽然常规的宏程序以树的形式,一种特殊类型的宏,称为宏观阅读,作用于原始字符组成程序。
在lisp中,当我们想定义一个non-lisp语法,并吗?t意义使用lisp的读者?这只是阅读lisp。读取宏设备之前,我们使用处理non-lisp语法lisp读者被爪子。lisp的读者的原因是更强大的比其他语言是lisp给你钩控制其行为的方方面面。特别是,lisp允许您扩展读者,所以non-lisp对象实际上是在为lisp对象。正如您构建您的应用程序在lisp之上,扩展宏和函数,lisp程序,并且经常做,渗出到这个尺寸的可扩展性。当这种情况发生时,任何字符的基础语法与lisp阅读器可以读取,这意味着你的语法变成lisp。虽然代码的转换由常规宏只用于lisp代码转变成新的lisp代码,阅读可以创建宏non-lisp代码变成lisp代码。像普通宏,宏读下面用函数实现我们可用lisp环境的全部威力。像宏,提高生产力,因为他们创造更多的程序员使用简洁的领域特定语言,阅读宏提高生产力通过允许表达式是缩写,他们不是吗?t甚至lisp表达式了。还是他们?
如果我们要做解析这些non-lisp领域特定语言写一篇短阅读宏,也许这些non-lisp语言真的是lisp,只是在一个聪明的伪装。如果lisp中可以直接读取XML阅读器(xmi-as-READ-macro), XML,可能在一种扭曲的意义上,其实是lisp。同样,宏可以用来读过正则表达式和SQL查询直接进入lisp,也许这些语言真的是lisp。这个模糊的代码和数据之间的区别,lisp和non-lisp许多有趣的哲学问题的来源,困惑lisp程序员从一开始。
一个基本的阅读与COMMON LISP宏,建于#。读取期eval宏。这个宏可以嵌入对象解读形式你看可以吗?t是连载的,但是可以创建的lisp代码。一个有趣的例子是形式,成为不同的值每次读:
* ?(足球比赛(game-started-at #。(get-internal-real-time))(正确率#。(如果(zerop(2)随机)?头?的尾巴)))
(足球比赛(GAME-STARTED-AT 187)(掷硬币正面))
即使它是相同的表达式,这种形式读入dif台每个时间:
* ?(足球比赛(game-started-at #。(get-internal-real-time))(正确率#。(如果(zerop(随机2))*头?的尾巴)))
(足球比赛(GAME-STARTED-AT 309)(掷硬币反面))
请注意,两种形式#包围。在阅读时评估,而不是当评估形式。完整的列表已经形成后评估,和之后,等价(平等定义的)可以被重新评估最后形式读入和比较它与以前的结果,使用*和+方便变量的REPL !:
* (= * (eval +) T
请注意,因为这些形式实际上是在readtime评估,这不同于使用反,我们将在以下部分看更密切。我们可以评估一个类似的形式,使用反:
* ?(足球比赛(game-started-at (get-internal-real-time))(正确率(如果(zerop(2)随机)?头?的尾巴)))
(足球比赛(GAME-STARTED-AT 791)(掷硬币正面))
? *变量包含的值是评价前面的形式,和+变量包含的形式。
但它将评估不同的结果,当我们重新评估,因为反读的代码进行评估:
* (= * (eval +))
零;除非你吗?非常快和幸运
4.2反
反,有时被称为但是?显示为?,是一个相对新来主流lisp编程,和概念仍几乎完全陌生的语言lisp。
反有一个奇怪的历史发展与lisp。据报道[quastquotarion],在早期没有人相信嵌套反工作直到大幅程序员意识到他们实际上做的工作对吧?人呢?年代的思想是正确的什么是错误的。嵌套反是出了名的难以理解。COMMON LISP的父亲,即使斯蒂尔,抱怨itjctrr2-psso)。
原则上,lisp并吗?t需要反。可以做任何可以用反与其他建筑功能列表。然而,反对于宏观编程是如此有用,在lisp意味着所有编程,lisp专业人员严重依赖它。
首先,我们需要了解常规报价。在lisp,当我们前缀引用字符的形式(?)我们通知lisp,以下表格应被视为原始数据,而不是代码来评估。相反,引用读取代码,在评估时,返回一个形式。我们有时说引用停止或关闭的评价形式。
反可以用作替代引用在lisp中。除非某些特殊字符,叫“角色,出现在一个表单,反停止评估相同的方式报价。顾名思义,这些结束字符扭转评估
? Scheme程序员称之为但是和Common Lisp程序员称之为反。
语义。我们有时会说“重启或回头的评价形式。
有三个主要类型的结束:常规的结束,拼接结束,破坏性的拼接结束。
执行常规的结束,我们使用逗号,接线员:
*(让((s ?你好))*(世界))
(HELLO WORLD)
虽然表情评估我们结束只是一个象征,年代,它可以是任何lisp表达式,评估为任何有意义的上下文它出现在反模板。不管结果是什么,他们在车里被插入到结果列表的位置,他们出现在反模板。
在lisp形式符号,我们可以使用。表明我们想要显式地把东西放在我们创建列表的cdr结构。如果我们把一个列表,由此产生的形式从反仍将是一个有效的列表。但如果我们把东西放在那里,我们将得到一个新的,非列表结构。
我们有这个能力在其他地方一样反�由于反的设计,我们甚至可以结束在这个位置上的东西:
* (let ((s ?(b c d))) ?(a . ,8))
公元前(D)
列表插入的cdr位置列表创建从一个反模板是如此普遍,反则更进一步拼接结束。上面,组合是有用的,但不能将元素插入到中间的一个列表。为此,我们有拼接结束操作符:
3因为反使用标准阅读功能(几乎)其他地方。
* (let ((s ?(b c d))) ?(a ,@s e))
(A BCD EE)
既不是,也不是,@修改被拼接在列表。例如,在前面的两个评估反形式,年代仍将绑定到三个元素列表(B C D)。虽然没有严格要求的标准,(B C D)在上述(A B C D)形式与拼接列表,允许股权结构。然而,在列表中(A B C D E),这个列表结构是保证新鲜时分配反评估以来,@被拼接在禁止修改列表。拼接“非破坏性,因为通常我们想反作为一个可重用模板用于创建列表。狼狈地修改表结构的数据不是吗?t刚分配在每个评估反代码可以在未来的扩张有不良影响。
然而,COMMON LIsP的拼接结束还提供了一个破坏性的版本可以在任何地方使用拼接结束。拼接相消,使用,。代替。破坏性的拼接工作一样定期拼接除了列表被拼接在评估期间可能会修改反模板。作为唯一的角色不同于一般的拼接,这个符号是一个聪明的重用的。性格的。,cdr位置结束我们看着上面。
看到这,这里我们狼狈地修改列表指出衔接:
* (defvar衔接吗? (B C D))
要想拼接*吗?,。要想拼接E)
(BCD EE) *衔接
(公元前D E)
狼狈地修改列表中拼接是危险的。考虑以下使用破坏性拼接:
(defun dangerous-use-of-bq () ? (a。(b c d) e))
dangerous-use-of-bq第一次被调用时,将答案返回:公元前(DE)。但由于它使用破坏性的拼接和修改列表,不是吗?新生成的?引用列表吗?我们可以预见各种不受欢迎的后果。在这种情况下,第二次dangerous-use-of-bq评估,现在(B C D)形式(B C D E)的形式,当反试图破坏地拼接这个列表上的其余部分反模板,(E) ?自己的尾巴吗?它创建了一个列表包含一个循环。我们在4.5节详细讨论周期,循环表达式。
然而,在许多情况下,破坏性的拼接是完全安全的。唐?t让dangerous-use-of-bq吓到你,如果你需要更多的效率反形式。有许多操作,创建新的表结构,你可能打算扔掉。例如,拼接的结果mapcar很常见的和安全的,下面可能会成为一个编程习语:
(defun safer-use-of-bq ()�(, (mapcar # ?身份? e (b c d))))
但这是有原因没有吗? t。最常见的使用反编辑宏,的lisp编程速度的问题至少要明确最重要的地方。如果你思考的副作用拼接操作让您哪怕只有一瞬间在创建和解释宏,它可能是不值得的麻烦。这本书与普通拼接。最常见的使用反宏建设但这并不是它唯一的使用。反引用实际上是
一个有用的领域特定语言混合在一起的域列表,一个更有用的可能性破坏性的拼接。
反引用是如何工作的呢?反引用是一个宏观阅读。反形式读取代码,当评估,所需的列表。回到前一节的例子在读取期评估,我们可以关闭印刷、引用的值反形式,打印出来看看如何反形式读!:
*(让(* print-pretty *);绑定到零(打印>�(足球比赛(game-started-at (get-internal-real-time))(正确率,�如果(zerop(随机2))*正面>反面))))t)
(LISP:: BACKQ-LIST(引用足球比赛)(LISP: BACKQ-LIST(引用GAME-STARTED-AT) (GET-INTERNAL-REAL-TIME)) (LISP: BACKQ-LIST(引用正确率)(如果(ZEROP(随机2))(引用正面)(引用反面))))
在上面的丑陋的印刷形式,LISP函数::BACKQLIST列表是一样的,除了它的漂亮的印刷行为。
我们返回t所以我们不?t从打印看到返回的值。(值)也是常见的。
注意逗号操作符都消失了。COMMON LISP是相当自由的反可以读的,特别是对于操作共享结构是允许的。
反还提供了许多有趣的解决方案写一个有趣的选项的lisp表达式评估本身。这些表达式通常被称为五胞胎后威拉德奎因广泛研究他们,事实上,创造了这个词但是吗?的另一个名字backquotejrounpations-P31-FooTNoTEs]。这里是一个有趣的例子的奎因归因于麦克麦克马洪在[quasiquotation}:
* (let ((let ??(let ((let ??,let)) 籰et))) ?(let ((let ?,let)) ,let))
(让(让? ?(让((让�,让))籐ET))) ?(((让?,让)),让))
拯救你的精神code walk: * (= * +) T
练习:在接下来的评价,为什么反扩展到普通报价?是吗?t引用吗?
一个�
*问
4.3。读取字符串
在lisp,字符串是由双引号(")分隔的字符。尽管字符串可以包含任何字符的字符集lisp语言实现,你可以吗?t直接插入某些字符字符串。如果你想插入字符或\”
清单4.1:SHARP-DOUBLE-QUOTE
(defun | #”读者|(流sub-char numarg)(声明(忽略sub-char numarg))(让(字符)(((上一页(读取字符流)咕咕叫)(咕咕叫(读取字符流)(读取字符流)))(萤石(char = prev # \”) (char =咕咕叫# \ #)))(推prev字符))(强迫(nreverse识字课)?字符串)))(set-dispatch-macro-character # \ # # \“#�#”读者|)字符,您将需要前缀\字符。这就是所谓的转义字符。例如,下面是如何输入一个字符串包含“\字符:
*”包含\“\ \”。“包含\”、\ \”。
这个显然可以工作,但有时打字这些\字符变得单调乏味,而且容易出错。这是lisp,当然,如果我们不?喜欢我们是免费的,甚至鼓励去改变它。在这个精神,这本书提供了一个宏观称为#”,或sharpdouble-quote阅读。这读宏创建字符串包含”和\字符没有调用逃跑了。
Sharp-double-quote�后将立即开始读字符串调用角色:#和“。它将继续阅读,直到它遇到一个字母一个字母两个字符" #,在序列。当它发现这个终止序列,它返回字符串代表之间的所有字符#”和“#。sharp-double-quote读取宏使用用于长字符串,但COMMON LISP释放这个有用的宏
*我们约定的命名的底层函数读取宏象征基于阅读宏?年代的人物,像\ # \动词? ?读者吗?由于CLtL2斯蒂尔。
性格对我们通过移动的长字符串# *读macrojrartyCL-VOTES]。这是一个例子的评价我们的新sharp-double-quote:
* # #和\“包含”。”
“包含\”、\ \”。
注意,当REPL打印字符串,它仍然使用“字符作为分隔符,所以”和\字符仍然逃脱的印刷表示字符串。这些字符串只是阅读如果你逃过了字符手动。
但有时#”不是吗?t不够好。例如,在这个U-language段落你现在正在阅读,我有包含以下字符序列:“#。正因为如此,这一段也?t与#分隔”和“#。因为我讨厌逃避的东西,相信我的话,不是吗?与普通双引号分隔。
我们需要一个读取宏,它允许我们自定义分隔符为每个特定的上下文,我们使用它。这是常有的事,我们需要看看拉里墙?年代Perl语言编程快捷键的设计灵感。Perl是一个美丽、奇妙的设计语言和拥有许多伟大的想法,偷窃的lisp的时机已经成熟。Lisp是,在某种意义上,一个大团,也许雪球,滚在从其他编程语言同化的想法,让他们自己�
# >直接读取宏灵感来自Perl吗?< <操作符。这个操作符允许Perl程序员指定一个字符串的文本作为最后引用字符串分隔符。# >读取字符,直到找到一个换行符,然后读取字符,one-byone,直到遇到一个字符与字符序列发现后立即# >和换行符之前。例如:
* # >结束
甌他最常被引用的例子这是对象,但有无数的例子如FORTRAN格式功能。
清单4.2:SHARP-GREATER-THAN


我可以把任何东西:“\”,#,和> #没有问题。唯一的阅读将终止这个字符串结束
“我可以把任何东西:\ \ \ \ " #,> #没有问题。唯一能终止这个字符串的阅读是……”
4.4 CL-PPCRE
CL-PPCRE {ct-rrorz是一个高性能的正则表达式库写在COMMON LISP。它是由广受尊敬的lisp黑客Edi韦茨。代表世界各地的lisp专业人士从CL-PPCRE受益很多和他的其他软件,本节致力于Edi韦茨。当别人谈话时,Edi编码;代码胜于论点。
PPCRE,对于那些没有?t已经熟悉,代表便携式Perl兼容的正则表达式。CL-PPCRE,就像这本书中的代码,是便携式的,因为它可以运行在任何ANSI-compliant COMMON LISP的环境。CL-PPCRE、也喜欢这本书中的代码是开源和免费的。尽管CL-PPCRE几乎完全兼容Perl,它不同于Perl在几个重要方面。CL-PPCRE提供了一些值得注意的lispy增强正则表达式。有三个重大的方式CL-PPCRE不同于实现Perl的正则表达式。
首先,CL-PPCRE快。非常快。用良好的本地代码编译器编译时,基准测试表明,对于大多数正则表达式CL-PPCRE大约是两倍Perl,往往快得多。non-lisp最快和Perl的正则表达式引擎:一个高度优化引擎写在c,这怎么可能?Perl吧?年代底层实现应该有性能优势写在一个高标准的像lisp语言。
这种误解被称为神话,性能的通用版本如下:低级语言的结果
在更快的代码,因为您可以计划接近硬件。作为复杂系统这本书希望解释,这个神话是错误的。类似的例子CL-PPCRE证明这一点。越是低级语言,它阻止你和你的编译器的效率优化问题。
CL-PPCRE,技术性能提升的原因很简单:COMMON LISP,语言用于实现CL-PPCRE,比C是一个更强大的语言,该语言用于实现Perl。当Perl读入一个正则表达式,它可以执行分析和优化但最终正则表达式将被存储成某种C数据结构的静态正则表达式引擎尝试匹配时使用。但在COMMON Lisp吗?最强大的语言?它本质上是很难把这个正则表达式,将它转换成一个lisp程序,并通过lisp程序优化,本机代码lisp编译器用于构建其他的lisp系统?。因为程序使用一个C编译器编译?t访问C编译器,Perl无法编译正则表达式一直到机器代码。Lisp吗?从C编译模型是在一个不同的类。在COMMON LISP编译的东西在运行时(在任何时候)是可移植的,无缝的,做在同一进程中作为LISP形象,垃圾收集在不再需要时,,由于其增量自然,高效。
第二个主要区别CL-PPCRE和Perl CL-PPCRE不是吗?t绑定到一个基于字符串的正则表达式的符号。CL-PPCRE从字符表示已经被释放,允许我们的编码正则表达式作为lisp形式(有时称为S-erpressions)。由于这种形式是符号我们用于编写lisp程序和宏,我们被允许更多的机会在我们抽象凝聚力。有关详细信息,请参阅CL-PPCREjct-prcrey的文档和代码使用这个正则表达式的符号,也
7 cl-ppcre实际上是更复杂的比这里描述。它有自己的编译函数,通常(除非你构建正则表达式在运行时)确保这是要求你当你的lisp程序被编译。
清单4.3:SEGMENT-READER
(defun segment-reader(流ch n)(如果(n > 0)(让((字符))(((咕咕叫(读取字符流)(读取字符流)))((char = ch咕咕叫))(推咕咕叫字符))(缺点(强迫(nreverse识字课)?字符串)(segment-reader流ch (n - 1))))))
一个设计良好的一个例子,lispy领域特定语言。
当然,CL-PPCRE是伟大的,但为什么我们讨论在一章读宏呢?答案就在第三个和最后一个CL-PPCRE大大不同于Perl。在Perl中,正则表达式语言密切相关。而口齿不清?年代语法的方式适应元编程,Perl吗?语法的方式是适应正则表达式和其他类型的语法的捷径。我们经常使用正则表达式的一部分原因在Perl代码是由于写作的经验如此短暂和无痛。
中添加一个方便程序员接口Perlish风格,阅读宏进来很方便。因为编程读取宏lisp编程,我们开始一个效用函数:segment-reader。给定一个流,分隔符字符,统计,segment-reader将从流读取字符,直到遇到分隔符字符。如果计数大于1,segment-reader将返回一个缺点。汽车的缺点是一个字符串,cdr是递归调用的结果segment-reader给定一个递减计数参数得到下一段�
例如,阅读3段从流t�
8在Common Lisp,当测试如果其他形式缺失的条款是发现错误,如果返回nil。经验丰富的COMMON LISP程序员往往依赖于这种行为,我们在segment-reader基本情况的递归建立一个列表。
The 流 t REPL 对应 于 标准 输入 完成 后
分隔符字符/是这样的:
* (segment-reader t # \ / 3) abc / def ghi /
c" abc " "def " "ghi ")
Perl程序员可能会清楚地看到这是要到哪里去。这个想法是,完整的道歉拉里墙,偷窃两方便的Perl的正则表达式的语法操作符。在Perl中,如果我们想尝试匹配正则表达式一个变量,我们可以写
$my_boolean = ($var =" m/*\w+/);
$ var的内容是否与一个或多个字母数字字符开始。类似地,如果我们想应用一个替换正则表达式,我们也可以使用Perl = ~操作符替换正则表达式应用于改变狗猫的第一次出现在我们的字符串变量$ var:
$var =" s/dog/cat/;
Perl语法的伟大之处是分隔符可以是任意字符,方便程序员。如果我们想使用一个正则表达式或包含/字符替换,我们可以使用一个不同的角色,以避免任何冲突! ?:
$ var = " s | / usr / bin / rsh | / usr / bin / ssh |;
定义一个读取宏复制这两个Perl语法给了我们一个机会来展示一个有趣的宏观技术、双反。这个想法是,有时候,就像match-modeppcre-lambda-form subst-mode-ppcre-lambda-form宏,
在这里。10这可能不是由于Perl;泰克斯吗?年代逐字报价提供类似的东西。
清单4.4:MATCH-MODES # + cl-ppcre (defmacro !match-mode-ppcre-lambda-form (o ! args) * *(λ(?,g ! str) (cl-ppcre:扫描�车,gtargs)�, g ! str)))
# + cl-ppcre (defmacro !subst-mode-ppcre-lambda-form (o ! args) * *(λ(?,g ! str) (cl-ppcre: regex-replace-all�车,gtargs) > ?,gistr�cadr, gtargs))))我们想写代码生成列表。注意,当您通常定义一个宏,使用一个反,你生成一个列表代表代码并返回它的宏观评价拼接成表达式。双反你仍表示代码生成一个列表,但是这段代码将在评估时,本身使用代码由反以返回一个列表。在我们的例子中,这两个宏扩展到代码,这些代码可以评估创建λ有用的应用CL-PPCRE正则表达式的形式。
我们这些宏前缀,和其他一些表情下面,# +阅读宏。这宏观阅读测试我们是否有可用CL-PPCRE ! !之前评估以下表格。如果CL-PPCRE还吗?装船时t可从这本书的源代码,这部分的功能将不可用。
最后,我们可以定义一个阅读器功能整合这些工具然后添加这个函数宏分派表。我们选择使用# ~读宏,因为它是一个很好的模拟Perl = ~我们语法的灵感的源泉。
# ~宏是为了方便阅读。这是如何
N1t测试CL-PPCRE通过搜索关键字的出现象征:CL-PPCRE列表中的存储在* *变量特性。
清单4.5:CL-PPCRE-READER # + cl-ppcre (defun | # ~读者|(流sub-char numarg)(声明(忽略sub-char numarg))(让((mode-char(读取字符流)))(电导率((char = mode-char # \ m) (match-mode-ppcre-lambda-form (segment-reader流(读取字符流)1)))((char = mode-char # \ s)(路径替换-mode-ppcre-lambda-form (segment-reader流(读取字符流)2)))
(t(错误“未知# ~ ~模式”字符)))))
# + cl-ppcre (set-dispatch-macro-character # # # \ \ ~ # ? | # ~读者|)我们可以创建一个正则表达式匹配函数:*�#癿/ abc / # <解释功能>
我们现在可以将这个函数应用到字符串一样正常
函数调用! ?:
* (funcall *“123美国广播公司”)
3 6 # 0 # 0))
*变量绑定到最后一个表达式的值返回的评价在REPL进入。这注定我们的正则表达式函数。
返回的值是cl-ppcre:扫描功能,可以在[ct-prcre找到的文档。如果你是只对字符串匹配,是否感兴趣,第一个返回值不是零意味着它。广义布尔值,以及为什么它们COMMON LIsP的一个重要特性,讨论了进一步在第六章,逐字宏。
我们还可以创建替换正则表达式的功能。Perl和略有区别,我们看到宏替换正则表达式函数不修改他们的论点。他们将返回新的字符串,字符串与原件的复印件替换。另一个区别是,默认情况下,这个读宏替换出现的所有模式而不是字符串中的第一个。在Perl中你需要添加一个全球修饰符正则表达式得到这种行为,但不是在这里:
* (funcall #皊/ abc / def /测试校正测试)“测试def测试def”
所以这是如何工作的呢?# ~什么表情,显然不是lisp表达式,读的吗?表面上看,就好像他们阅读的功能,但这证明并非如此。让吗?年代引用其中一个表格我们可以看到它是什么根据lisp的读者:
* ? #�m | \ wttp: / / |
(λ(#:STR1) (CL-PPCRE:扫描“\ \ wttp: / /”#: STR1))
替换是相似的:* ? #皊/ abc / def /(λ(#:STR2)
(CL-PPCRE: REGEX-REPLACE-ALL“abc”
#:STR2“def”))
他们在λ形式。lisp的读者而言,我们没有?t写一些有趣的non-lisp语言。这是一个函数指示器。因为我们的表情只是列表的第一个元素符号λ,回忆从2.4节,让它成为λ如何使用λ形式函数调用的第一个参数来调用匿名函数:
*(如果(4癿/ * [\ w -。)+美元/“hesw.org”) ? kinda-looks-like-a-domain�没有机会!)
KINDA-LOOKS-LIKE-A-DOMAIN
当我们使用funcall或适用于使用对象读# 7,我们利用ANSIλ宏观但当表单列表中的第一个:一个有用的二元性的语法。如果我们的# 7表达式作为sharp-quotedλ形式我们也读?t能够使用它们的函数表达式的位置?只有函数名和λ形式可以去那里。所以对于这两个任务只需要有一个宏观阅读,这是幸运的,因为它是一个庞大而复杂。利用双语法让我们专注于让正确的扩张,而不是跟踪不同的语法要求。而不是一个有趣的宏,我们有两个。节省精力,使你的语法尽可能相似。
一个常见的问题在使用CL-PPCRE忘了逃避反斜杠在你的正则表达式。看看发生了什么当你这样做:
" * " \ wt y +”
这是一个字符串的长度2。反斜杠去了哪里?双引号认为我们为了逃避而不是写一个文字\字符。我们的# ~读宏
读取字符,并寻找适当的分隔符,这不是一个问题,我们可以写在Perl正则表达式就像我们做什么?没有逃。看到上面的URL的引用正则表达式。
虽然# ?读宏定义在这一节中已经很方便,还有改进的空间和增强。练习:改进它。最明显的第一步是支持正则表达式的修饰符,例如不区分大小写的匹配。如果用Perl语法一样,这将涉及使用unread-char函数,这在阅读中很常见的宏,以避免意外地吃一个字符,其他一些阅读宏可能会期待。
4.5循环表达式
我们谈论lisp程序树的缺点细胞实际上是一个小谎言。很抱歉。Lisp程序实际上是不树而是有向无环图?树可能共享分支。由于评估者也?在意树枝是评估是从哪里来的,没有错与评估代码共享结构。
一个有用的阅读提供宏观# =。我们已经看到lisp可以输出形式# =宏在3.5节连载宏展开时,意外捕获。# =和其合作伙伴# #让你创建自我参照S-expressions。这允许你在有向无环图代表共享分支机构和其他有趣的数据结构很少或根本没有工作。
但最重要的是它允许您连载数据而无需拆卸和重新组装一个高效的内存数据结构的大部分数据是共享的。这里是一个例子,两个lisp列表(不读是不同的对象
eq):
* (defvar不能共享? ((1)(1)))
(C4) (41)
* (eq(汽车不能共享)(cadr不能共享))零
但在接下来的例子中,使用# =序列化数据读取宏,2列出了真的是相同的列表:
* (defvar共享? (# 1 = (1)# 1 #))
(C1) (1)) * (eq(汽车共享)(cadr共享)
T
正如前面提到的,我们可以给共享,没有麻烦的评估者无环表结构:
*(# 1 =列表(列表0)# 1 #
# 1 #)
((0) (0) (0))
如果我们打印最后形成我们评估,我们看到它一样lisp评估者:一个常规列表与三个独立的分支:
列表(列表(列表0)(0)(0)列表)
但是如果我们将* print-circle *特殊变量绑定到nonnil值我们打印出来的时候,我们看到,表达式树并不是一个,而是一个有向无环图:
*(让((* print-circle * t))(打印+ +)
t)
(# 1 =列表(列表0)# 1 # # 1 #)T
作为另一个有趣的例子,在这里吗?年代如何打印无限列表指向cdr的缺点,形成所谓的循环或循环:
*(打印? ?# 1 =(你好。# 1 #))
(你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好
因此,除非你希望发生这样的事,一定要设置* printcircle *当连载循环数据结构:
*(让((* print-circle * t))(打印? ?# 1 =(你好。# 1 #))nil)
# 1 =(你好。# 1 #)零
有一个简单的方法来判断表结构是循环的一部分或包含共享结构?是的,提供cyclic-p谓词使用最明显的发现:算法递归在保持一个哈希表结构更新所有的缺点细胞吗?到目前为止已经遇到了。如果你遇到一个缺点细胞已经存在于你的哈希表,你已经去过那里,因此发现一个周期或共享分支。注意,因为它只在缺点细胞递归,cyclic-p无法发现这样的引用等数据结构的向量。
最后,因为大多数(见[synracticaLty-Recurstve}) lisp编译器禁止你圆形式传递给编译器,执行以下是未定义的,但可能会打破你的编译器通过将编译成一个无限循环:
清单4.6:CYCLIC-P
(defun cyclic-p (1) (cyclic-p-aux 1 (make-hash-table))) (defun cyclic-p-aux(1)(如果(consp 1)软木(gethash 1看到)(progn (setf (gethash 1) t)和(cyclic-p-aux汽车(1)见过)(cyclic-p-aux (cdr 1))))))) (progn (defun哎哟()# 1 = (progn # 1 #))(编译?哎哟))
4.6读者安全
可扩展性,能够让事情发生,不是吗?原先t或预期,几乎总是一件好事。事实上,尽可能鼓励可扩展性使得lisp一样伟大。然而,有些时候,我们会更喜欢让事情尽可能不能扩展的。特别是,我们不?t想让外人自己扩展到我们的系统没有我们的知识或同意。这是被称为被攻击或r00ted。今天,有趣的计算主要是通信和网络。当你完全控制这两个程序交换数据,你显然相信整个系统。但是只要有可能有些不可信方甚至部分控制的一个项目,系统分解完全的信任,就像一个被推翻的卡片。
这些安全问题的最大来源来自什么程序员开玩笑地称为阻抗失配。当你使用你的东西?完全理解,有可能你用错了。有两种方法来打击阻抗不匹配:样式(唐?t使用strcpy (3))
和理解(实际阅读手册页)。Lisp是一个很好的语言编写安全软件,因为比其他任何语言Lisp总是期望是什么。如果你总是按照假设lisp做正确的事情,你就会很少出错。例如,如果您试图写字符串或向量的范围外,明显有问题的情况下,lisp会引发一个异常,立即大声通知你这个问题。事实上,lisp这更比你期望的权利:遇到异常后,您可以选择重新启动您的程序在程序中的另一个位置,保留大部分的状态计算。换句话说,COMMON LISP吗?年代异常系统不?t自动摧毁你的计算?栈在异常发生时:您可能还想使用堆栈。主要是由于空间的限制,除了系统!这本书不是更详细地描述。相反,我建议彼得Seibel吗?年代实用COMMON LISP | practicaL-c]。
但学习的一部分lisp是发现一切都是可扩展的。我们怎么能够限制呢?事实证明,我们在错误的方向思考问题。在所有的计算机安全领域,你可以吗?t考虑国防直到你认为是犯罪。在所有其他领域的编程中,你可以有建设性地得出好的结果,通过构建和使用抽象。在安全,你必须认为具有破坏力。而不是等待,然后修复bug,你必须设法找出错误代码打破。
所以我们攻击是关心什么呢?没有办法攻击程序,除非你以某种方式控制输入程序。当然在我们的网络世界大多数程序几乎是毫无用处的,除非人们可以给他们输入。有许多为移动互联网的数据进行协议! *。我们想做各种各样的事情实在太庞大创建一个通用的
3实际条件系统,因为它是有用的呼吁不仅仅是例外。
?我的nmap-service-probes文件有助于维持Nmap安全扫描仪项目是其中一个最全面、频繁更新数据库的服务。数据交换的标准。最好的,可以做的是提供一个可扩展的框架,允许程序员创建定制协议以适应应用程序。这通常意味着更少的网络开销,更好的传递算法,和更多的可靠性。然而,主要优势在于,当我们设计的协议我们可以减少或消除阻抗失配是如何使安全协议。
数据交换标准的问题是,为了支持标准,禁止应用程序减少可以用什么协议。通常有一些基线行为,必须满足为了让应用程序符合标准。制造安全协议,我们需要确保我们只接受我们肯定可以处理。
lisp交换数据的方法是什么?获取数据到lisp的机制称为lisp的读者,得到它的机制称为lisp打印机。如果你做到这一步到这本书你已经知道足够多的设计和使用lisp协议。当你lisp程序使用这样一个协议。你与lisp,喂养lisp的形式,这往往是最好的方法也与世界上的其他国家。当然你不?t信任世界其他地方所以必须采取预防措施。记住,你必须考虑安全性考虑攻击。COMMON LIsP的设计者考虑攻击读者在设计。早在这一章里,我们描述了#。读宏,让读者执行lisp表达式我们可以编码non-serialisable数据结构。减轻一个明显的攻击lisp读者,COMMON lisp提供* read-eval *。从CLtL2:
绑定* read-eval * nil是有用的阅读时的数据来自一个不可信的来源,如网络或用户提供的数据文件;它阻止了#。从被剥削读取宏的“特洛伊木马”导致任意形式被评估。

#。(ext:运行程序/ bin /不“2 (“e”“/ bin / sh”uj水龙头”“31337”)
以上将开始在端口31337监听连接,将提供unix shell访问任何连接的人。与传统的利用,大量的精力花在试图使他们尽可能轻便可靠,如此他们将成功r00t最经常最大量的目标。通常这是极其困难的。在lisp中读者的攻击,这非常简单。这是我们如何更新我们的shell代码以使便携式CMUCL和SBCL之间:
#。(# + cmu ext:运行程序# + sbcl sb-ext:运行程序/ bin /不“2 (“e”“/ bin / sh”uj水龙头”“31337”)
道德是总是确保你绑定* read-eval *处理任何数据时为零,你哪怕是轻微的不信任。如果你很少使用#。读宏,你可能会明智setq为零,只有让它当你希望使用它。
所以我们可以禁用#。宏很容易阅读。但这是否就足够了?这取决于您的应用程序是什么
一个有效的攻击。对于交互式程序,这可能是足够了。如果我们得到了错误数据我们将听到它尽快和尽可能的大声。然而,对于互联网服务器这可能是不够的。考虑一下这个shell代码:
)或:no-such-package: rewt3d
Lisp通常会抛出一个错误,因为我们试图阅读在一个不平衡的形式或方案,并查找一个符号?t存在。可能我们的整个应用程序会停止。这就是所谓的拒绝服务攻击。一个更微妙和难以调试拒绝服务攻击是通过一个圆形的形式使用# #和# =读宏。如果我们的代码处理这个数据不是吗?t通过这样的形式编写的,结果是一个阻抗失配,有可能的是,一个安全的问题。另一方面,也许我们的应用程序依赖于能够通过循环和共享数据结构。安全需求完全依赖于应用程序的数据。幸运的是,无论你的需求,lisp的读者和打印机是胜任这一任务。
Safe-read-from-string部分回答读者问题的安全。这个函数是可以供生产使用的比大多数其他代码在这本书。建议您仔细考虑您的应用程序的安全需求和适应(甚至重写)这段代码为您的应用程序。Saferead-from-string read-fromstring是一个锁定的版本。它有自己的默认lisp readtable副本。这副本有最有趣的阅读宏删除,包括#调度宏。这意味着向量,向量、gensyms循环引用,#。,所有的休息。Saferead-from-string甚至不会允许关键词或外国包符号。然而,它将允许任何缺点结构,不仅是形成良好的列表。它还允许数字!�和字符串。
15个练习:数字不允许的一个类是什么?清单4.7:SAFE-READ-FROM-STRING
(defvar safe-read-from-string-blacklist
? (# H \ # # \: # \ 1))(让((rt (copy-readtable nil))) (defun safe-reader-error(流closech)(声明(忽略流closech))(错误“safe-read-from-string失败”))
(dolist (c safe-read-from-string-blacklist) (-macro-character c# ?safe-reader-error nil rt))
(defun safe-read-from-string (s koptional失败)(如果(stringp s)(让(rt) (* readtable * * read-eval *)钱德勒绑定(Cerror(λ(条件)(声明(忽略条件))(返回safe-read-from-string失败))))(read-from-string s))))))失败
Safe-read-from-string使用lisp ?抛出的异常系统捕获所有错误lisp read-from-string函数。如果有任何问题在阅读的字符串,包括遇到不平衡的括号或遇到其他阅读宏有黑名单safe-read-from-stringblacklist变量,safe-read-from-string将返回作为第二个参数传递的值,或者零如果没有提供(记住你可能会想读nil)。这是它是如何通常使用! 6;
(让�((g (gensym)) (v (safe-read-from-string user-supplied-string g)))(如果(eq g v) (log-bad-data;注意它如何?年代记录!user-supplied-string)(过程v)))
当然这个版本的safe-read-from-string是非常有限的,为您的应用程序可能需要修改。特别是,您可能会想要关键字符号。使他们很容易:只要绑定列表没有:角色safe-read-from-string-blacklist当你使用safe-readfrom-string和注意,符号可能驻留在多个包(包括关键字包)。即使你删除:字符,我们的包壳上面代码将会受阻,因为我们抓住所有的错误在阅读,包括错误表明不存在包。* Read-eval *总是绑定到零,以防你决定从黑名单中删除#字符。如果你这样做,你可能想要创建一个subblacklist #调度宏(可能是一个大型黑名单)。竖线字符列入黑名单,这样我们吗?t读在古怪的符号。
所以我们可以锁定读者一样紧密我们觉得有必要,事实上我们的应用程序将允许一样紧张。但即使在
16当然如果我们使用它在一个宏,我们将使用defmacro !及其自动gensyms。我们吗?已经确保没有攻击向量通过软件用于读取的形式,如何最小化之间的阻抗失配我们认为lisp的结构形式是它真的可以吗?我们必须确认它与我们期望的。一些数据标准调用这个过程对模式验证,但是lisp称之为destructuring-bind反对延长λ的形式。所有条件比试图听起来更重要是值得他们所代表的简单的概念。我们的想法是,你要确定你的数据的形式,或结构,你期望它对于一些给定的处理。Destructuring-bind为我们检查这个结构,提供一个非常有用的模式语言,包括关键词和可选的参数,和还有奖金,我们得到结构的不同部分。
我可以给一些如何使用的例子destructuring-bind其实没有必要:我们一直使用解构。参数或参数列表后,我们立即插入一个宏的名字时,当我们使用defmacro, defmacro !,或者destructuring-bind叫做延长λ列表突出的事实是更强大的比一个普通的解构进行λ列表。与扩展λ列表我们可以嵌套扩展λ列表变性任意深度的列表结构。保罗•格雷厄姆?在Lisp有着优秀的解构。尤其是看到格雷厄姆?年代。在这些地方,macrojon-tusp-p237),最好是阅读6.7节之后,Pandoric宏。
所以每次你编写一个宏或一个函数,你是谁,从某种意义上说,把这个宏或功能将得到的参数数据,和扩展或定期λ列表模式。在这种情况下,验证的数据似乎很容易。Lisp可以验证我们的数据是结构化的,因为它应该是,如果不是将提高错误条件。如上所述的读者,在处理数据时,我们甚至有点不信任我们应该仔细思考可能的攻击,然后使用lisp吗?强大的例外和宏观系统构建一个验证方案,只允许应用程序所需的最低限度和地图直接到我们的应用程序是如何工作的,减少或消除任何阻抗失配。这个任务CL-PPCRE正则表达式也是不可或缺的。没有其他语言有潜在的安全软件,lisp和这只会随着时间的推移变得更加明显。
