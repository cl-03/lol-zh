# 7.6 排序

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

没有比 lisp 更好的工具来试验效率或实际实现高效程序了。 Lisp 是独一无二的，因为它不仅让我们能够专注于智能算法和设计，还让我们能够利用最先进的机器代码编译器最大限度地利用这些算法和设计。 本节从 lisp 的角度描述了已被广泛研究但仍远未穷尽的计算机科学的一个角落：排序。 大多数人考虑对已解决的问题进行排序，因此可能会惊讶地发现仍有许多重要的未解决问题。


我们知道许多优秀的通用排序算法。像快速排序这样的算法是最常见的，因为它们可以有效地对大量数据进行排序。但是，相反，如果我们希望对许多小批量数据进行排序，那么像快速排序这样的通用排序算法可能会过大。本节是关于这个问题的解决方案，许多人几十年来一直痴迷于这个问题，但它仍然是研究的沃土。对我们来说最重要的是，这个解决方案提供了个展示高级优化技术的机会，这些技术在 lisp 中很简单，但在大多数其他语言中却是如此重要，以至于它们几乎不值得。在本节和下一节中，我们将重新实现 Graham 在 On Lisp 中描述的宏 `sortf`。 Graham 的 `sortf` 旨在说明如何使用广义变量编写宏，而我们的 `sortf` 旨在提高速度。在某些情况下，我们的 `sortf` 将比系统经过一定调整的排序功能实现数量级的改进。


本节献给我的老师和朋友 Alan Paeth，他教会了我，在许多事情中，甚至连排序也很有趣。 我也非常感谢 John Gamble 和他出色的 Perl 程序 Algorithm-Networksort[ALGORITHM-NETWORKSORT]。 该程序用于试验不同的算法并生成本节中出现的 ASCII 图表网络。


排序网络是一种算法，用于不经意地对特定固定大小的数据集进行排序。 也就是说，与大多数算法（如快速排序）不同，排序网络的操作不依赖于它用于排序的特定数据集。 每一步都是在设计网络时决定的。 排序网络是数据与索引对（pair）的简单列表。 这些对（pair）的每一个都对应于应该在比较交换操作中使用的索引。 在按顺序执行所有这些比较交换操作后，元素将按排序顺序排列。


像快速排序这样非常适合大型数据集的算法对于某些类别的排序问题可能会产生无法接受的开销。 首先，快速排序实现通常允许选择自定义比较运算符，以使排序代码更通用。 这意味着每次比较都需要对比较函数进行函数调用，而不是作为内联机器代码实现。 其次，由于快速排序实现如此普遍，当我们知道我们的数据集具有特别小的固定大小时，它们通常无法利用可以进行的优化。 第三，我们通常不想对数据集进行完全排序，而是只对数据集进行排序，以确定某个元素（也许是中间元素）。 不查找完整排序的排序网络有时称为选择网络。


为了阐明排序网络的概念，并说明该主题可能有多么微妙和违反直觉，我们考虑一些最简单的网络：对三个元素进行排序的网络。 大多数程序员都知道，通过三个比较可以轻松地对三个元素进行排序，并且当恰好有三个元素时，通常不会使用快速排序。 很容易说服自己，这些比较交换操作可以按任何顺序执行，结果都是一样的。 但是，有些排序本质上比其他排序效率低，这并不是很明显。
```
(defvar bad-3-sn
  '((0 1) (0 2) (1 2)))
```
```
o--^--^-----o
   |  |
o--v--|--^--o
      |  |
o-----v--v--o
```
网络 `bad-3-sn` 可能是最明显的三元网络实现，但正如其名称所暗示的那样，它并不是最佳的。 ASCII 图表图片有助于可视化 `bad-3-sn` 中基于列表的网络描述所描述的算法。 该算法表示要比较数据集索引 0 和 1 处的元素，如果它们无序，则将它们交换为正确的顺序。 对索引对 (0 2) 执行相同的操作，最后对 (1 2) 执行相同的操作。 在这个过程之后，元素将被排序。 如果我们将这个排序网络实现为代码来对长度为 3 的数组进行排序，称之为 `a`，那么看起来可能是像这样：
```
(progn
  (if (> (aref a 0) (aref a 1))
    (rotatef (aref a 0) (aref a 1)))
  (if (> (aref a 0) (aref a 2))
    (rotatef (aref a 0) (aref a 2)))
  (if (> (aref a 1) (aref a 2))
    (rotatef (aref a 1) (aref a 2))))
```
`bad-3-sn` 结果是正确的，但与 `good-3-sn` 相比效率低下。通过交换前两个比较交换操作的顺序，我们实现了更高效的网络。平均而言，该网络执行的交换操作比 `bad-3-sn` 少。描述这一点的最好方法是使用条件概率，但因为这是一本关于 lisp 的书，而不是排序网络，所以我们会回避这一点。相反，我们通过枚举所有排列然后测量当我们用两个网络解释它们时发生的交换次数来证明 `good-3-sn` 优于 `bad-3-sn`。现在这里有一个直观的解释：如果首先执行网络中的长链接，那么在第一次操作之后，最小或最大元素中的至少一个将处于其正确的最终位置。因此，至少有一个后续的比较交换操作不会执行交换。但是，如果先执行短链接，则这些元素可能都不在其最终位置，并且都需要将来交换。
```
(defvar good-3-sn
  '((0 2) (0 1) (1 2)))
```
```
o--^--^-----o
   |  |
o--|--v--^--o
   |     |
o--v-----v--o
```
```
(defvar tracing-interpret-sn nil)

(defun interpret-sn (data sn)
  (let ((step 0) (swaps 0))
    (dolist (i sn)
      (if tracing -interpret -sn
        (format t "Step ~a: ~a~%" step data))
      (if (> #1=(nth (car i) data)
						 #2=(nth (cadr i) data))
        (progn
					(rotatef #1# #2#)
					(incf swaps)))
      (incf step))
		(values swaps data)))
```
为了探索这种现象，我们实现了一个用于排序网络的解释器，`interpret-sn`。 此解释器将排序网络 `sn` 应用于由列表表示的数据集。 它将返回执行的交换次数作为第一个值，并将生成的排序数据集作为第二个值。 注意这里用 `#=` 和 `##` 自引用读取宏来避免重新键入访问器表单。 如果我们想查看分步排序过程，还要注意我们可以绑定到非空值的跟踪变量的使用。 首先，假设一个已经排序的数据集， 显然 `bad-3-sn` 和 `good-3-sn` 都不执行交换：
```
* (let ((tracing-interpret-sn t))
    (interpret-sn '(1 2 3) bad-3-sn))
Step 0: (1 2 3)
Step 1: (1 2 3)
Step 2: (1 2 3)
0
(1 2 3)
* (let ((tracing-interpret-sn t))
    (interpret-sn '(1 2 3) good-3-sn))
Step 0: (1 2 3)
Step 1: (1 2 3)
Step 2: (1 2 3)
0
(1 2 3)
```
接下来，考虑每个元素都乱序的情况。 同样，两个排序网络执行相同的操作，执行必要的两次交换：
```
* (let ((tracing-interpret-sn t))
    (interpret-sn '(3 1 2) bad-3-sn))
Step 0: (3 1 2)
Step 1: (1 3 2)
Step 2: (1 3 2)
2
(1 2 3)

* (let ((tracing-interpret-sn t))
    (interpret-sn '(3 1 2) good-3-sn))
Step 0: (3 1 2)
Step 1: (2 1 3)
Step 2: (1 2 3)
2
(1 2 3)
```
但是，在这种情况下，`bad-3-sn` 会导致最坏情况——交换三次：
```
* (let ((tracing-interpret-sn t))
    (interpret-sn '(3 2 1) bad-3-sn))
Step 0: (3 2 1)
Step 1: (2 3 1)
Step 2: (1 3 2)
3
(1 2 3)

* (let ((tracing-interpret-sn t))
    (interpret-sn '(3 2 1) good-3-sn))
Step 0: (3 2 1)
Step 1: (1 2 3)
Step 2: (1 2 3)
1
(1 2 3)
```
在上面，`bad-3-sn` 执行了 3 次交换，而最优的 `good-3-sn` 只执行了一次。 不应该存在 `good-3-sn` 表现不佳的对称情况吗？ 事实证明，不，`good-3-sn` 真的更好。 如果你仍然不相信这一点，自行查阅**蒙蒂霍尔问题**，以了解这类问题可能有多么违反直觉。 因此，似乎合理的排序总是尽快将元素交换到正确的位置，以便发生最少的交换。


为了量化 `good-3-sn` 比 `bad-3-sn` 具体要好多少，我们写了一个实用程序 `all-sn-perms`，它生成从 1 到 n 的数字的所有排列。 `all-sn-perms` 使用了很多 lisp 的特性，包括递归地构建连接的临时列表网络，以及使用 Graham 的照应 alambda 宏。 在这里，我们生成数字 1 到 3 的所有 6 个（3 的阶乘）排列：
```
* (all-sn-perms 3)

((1 2 3) (2 1 3) (1 3 2)
 (3 1 2) (2 3 1) (3 2 1))
```
```
(defun all-sn-perms (n)
  (let (perms curr)
		(funcall
			(alambda (left)
				(if left
					(loop for i from 0 to (1- (length left)) do
						(push (nth i left) curr)
						(self (append (subseq left 0 i)
													(subseq left (1+ i))))
						(pop curr))
					(push curr perms)))
				(loop for i from 1 to n collect i))
      perms ))
```
注意，由于 `all-sn-perms` 的编写方式，上述列表彼此共享结构，因此在使用它们来解释排序网络（一种破坏性操作）时，我们应该始终确保对它们的副本进行排序，如 `average-swaps-calc`。 对于可以以这种方式构造的结果的问题，像这样的共享结构通常是一种很好的编程技术，因为它可以减少数据结构所需的总内存。
```
(defun average-swaps-calc (n sn)
	(/ (loop for i in (all-sn-perms n) sum
				(interpret-sn (copy-list i) sn))
     (fact n)))
```
使用 `interpret-sn` 排序网络解释器，我们可以用它为每个可能的排列记录的实际交换数和 `average-swaps-calc`。 这个函数简单地遍历每个排列，将解释器应用于给定的排序网络，对发生的交换求和，然后返回这个和除以可能的排列的数量。 假设每一种排列都是等可能的，那么这个计算就代表了每一种排序发生的平均交换次数。 下面，可以看到 `bad-3-sn` 平均每次排序发生了 1.5 次交换：
```
* (average-swaps-calc 3 bad-3-sn)
3/2
```
平均而言，`good-3-sn` 只有 1.166 次交换：
```
* (average-swaps-calc 3 good-3-sn)
7/6
```
目前为止，我们的排序网络只能对大小为 3 的数据集进行排序。 是否有生成任意大小的排序网络的算法？ 有的，这些算法已经公布有一段时间了。 1968 年，Ken Batcher 将他的巧妙算法 [SN-APPLICATIONS] 描述为由 Donald Knuth 命名的合并交换排序或来自 [TAOCP-VOL3-P111] 的算法 5.2.2M。 Batcher 的算法是 shell 排序和归并排序的一种组合，除了给定一个已知的输入大小，它将进行的比较交换操作完全独立于数据本身确定——这正是我们对网络排序所需要的。 因此，为了创建一个排序网络，我们运行 Batcher 的算法并记录进行了哪些比较交换操作。 稍后我们可以将这些操作内联到这个特定输入大小的函数中。 这个过程与循环展开并不完全不同，除非 lisp 允许我们更进一步。
```
(defun build -batcher -sn (n)
  (let* (network
				(tee (ceiling (log n 2)))
				(p (ash 1 (- tee 1))))
    (loop while (> p 0) do
			(let ((q (ash 1 (- tee 1)))
            (r 0)
						(d p))
				(loop while (> d 0) do
					(loop for i from 0 to (- n d 1) do
          	(if (= (logand i p) r)
							(push (list i (+ i d))
              			network)))
				(setf d (- q p)
							q (ash q -1)
							r p)))
    (setf p (ash p -1)))
(nreverse network)))
```
`build-batcher-sn` 是 Batcher 算法的 lisp 实现，直接转录自 Knuth 的描述。 由于 lisp 对按位整数运算的任意精度支持，此实现不会受到任何人为的大小限制，例如 32 或 64。可以使用 `build-batcher-sn` 轻松构建任意大小的高效排序网络 . 这是一个大小为 3的网络的构造——与上面的 `good-3-sn` 相同：
```
* (build-batcher-sn 3)
((0 2) (0 1) (1 2))
```
下面是大小为 7 的网络结构：
```
* (build-batcher-sn 7)
((0 4) (1 5) (2 6) (0 2) (1 3) (4 6) (2 4)
 (3 5) (0 1) (2 3) (4 5) (1 4) (3 6) (1 2)
 (3 4) (5 6))
```
```
o--^--------^-----^-----------------o
   |        |     |
o--|--^-----|--^--v--------^--^-----o
   |  |     |  |           |  |
o--|--|--^--v--|--^-----^--|--v-----o
   |  |  |     |  |     |  |
o--|--|--|-----v--|--^--v--|--^--^--o
   |  |  |        |  |     |  |  |
o--v--|--|--^-----v--|--^--v--|--v--o
      |  |  |        |  |     |
o-----v--|--|--------v--v-----|--^--o
         |  |                 |  |
o--------v--v-----------------v--v--o
```
Batcher 的网络很好，但众所周知，对于大多数网络规模来说，它的效果并不理想。 虽然已经发现了许多特定规模的更好的网络，但如何找到这些更好的网络，以及它们是否是最优的，这是个重要的未解决问题。 这一研究领域已经通过使用新的人工智能技术有效搜索排序网络问题的超指数空间的进化算法取得了重要进展。 例如，目前已知的大小为 13 的最佳网络是由 Evolving Non-Determinism 算法 [END] 发现的。


此处显示的排序网络的 ASCII 图表表示是由 John Gamble 出色的 Algorithm-Networksort Perl 程序创建的。 注意，图表将一些可以并行执行的链接放在同一垂直列中。 这表明排序网络是至少在专用硬件中可以从比较交换操作中的并行性中受益的算法。 发现如何创建良好的并行排序网络，以及我们可以使它们如何并行，仍然很重要，也是未解决的问题。
```
(defun prune-sn-for-median (elems network)
  (let ((mid (floor elems 2)))
    (nreverse
      (if (evenp elems)
        (prune-sn-for-median-aux
          (reverse network)
          (list (1- mid) mid))
        (prune-sn-for-median-aux
          (reverse network) (list mid))))))

(defun prune-sn-for-median-aux (network contam)
  (if network
		(if (intersection (car network) contam)
    	(cons (car network)
						(prune-sn-for-median-aux
            	(cdr network)
							(remove -duplicates
								(append (car network) contam))))
      (prune-sn-for-median-aux
				(cdr network) contam))))
```
上面我们提到了通用排序函数的一个缺点是它们被硬编码为执行整个排序操作。 如果我们愿意，我们可以对数据集进行排序，使其足以确定一个元素位于其最终位置。 通常，我们感兴趣的元素是中间元素或中值元素。 函数 `prune-sn-for-median` 和 `prune-sn-for-median-aux` 采用了一种适度的、明显的算法，我发现它可以消除许多不必要的比较交换操作，从而构建任意选择网络。
```
o--^--------^-----^-----------------o
   |        |     |
o--|--^-----|--^--v--------^--------o
   |  |     |  |           |
o--|--|--^--v--|--^-----^--|--------o
   |  |  |     |  |     |  |
o--|--|--|-----v--|--^--v--|--^--^--o
   |  |  |        |  |     |  |  |
o--v--|--|--^-----v--|--^--v--|--v--o
      |  |  |        |  |     |
o-----v--|--|--------v--v-----|-----o
         |  |                 |
o--------v--v-----------------v-----o
```
该算法从 Batcher 网络开始，然后向后工作，跟踪受污染的元素 - 不能删除任何现有链接的元素，因为这样做会改变该元素的网络结果。 可以删除连接未受污染元素的任何链接，而不会改变受污染元素的结果。 将受污染的元件连接到未受污染的链接的每个链接都会污染未受污染的元件。 当我们只污染中间元素（或在输入大小相同的情况下污染两个中间元素）时，我们创建了一个中值选择网络。


显示了大小为 7 的算法输出，这是一个修改后的 Batcher 网络，其中两个链接被删除。 运行此网络后，中值元素将位于正确位置，但不保证其他元素排序。 举个例子，这里我们只对列表进行排序，发现 4 是中间元素：
```
* (interpret-sn
    '(4 2 3 7 6 1 5)
    (prune-sn-for-median
      7 (build-batcher-sn 7)))
6
(1 3 2 4 5 7 6)
```
```
(defun prune-sn-for-median-calc (n)
	(loop for i from 2 to n collect
		(let* ((sn (build -batcher -sn i))
    			(snp (prune-sn-for-median i sn)))
			(list i
				(length sn)
				(length snp)))))
```
对于大小为 7 的网络，我们修改后的中值 Batcher 网络执行 12 次比较交换操作，而常规 Batcher 网络执行 14 次操作。 `prune-sn-for-median-calc` 为我们提供了针对不同大小排序网络的此类网络的数据。 它计算大小最大为 n 的 Batcher 网络，并将它们的大小与我们的算法创建的相关中值网络的大小分组。


计算的网络大小最多为 49。 请注意，在最小尺寸下，保存的操作很少（如果有的话）。 但是对于稍微大一点的数字，我们开始节省大约 20% 的比较交换操作。 当我们只关心中位数时，这些网络是不错的选择。 然而，最优中值排序网络的构建也是一个开放的研究领域。 本章开发的修改后的 Batcher 网络很不错，但仍远未达到最佳状态。 Paeth[GRAPHICS-GEMS-P171-175] 发现了目前已知的 9 和 25 尺寸（3x3 和 5x5 内核镜像尺寸）的最佳中值选择网络，并在此处介绍并包含在本书的代码中。 以下是 Paeth 的中值网络的长度：
```
* (length paeth-9-median-sn)
20
* (length paeth-25-median-sn)
99
```
```
* (prune-sn-for-median-calc 49)
((2 1 1) (3 3 3) (4 5 5) (5 9 8) (6 12 12)
 (7 16 14) (8 19 17) (9 26 22) (10 31 29)
 (11 37 31) (12 41 35) (13 48 40) (14 53 47)
 (15 59 49) (16 63 53) (17 74 61) (18 82 72)
 (19 91 75) (20 97 81) (21 107 88) (22 114 98)
 (23 122 100) (24 127 105) (25 138 113) (26 146 124)
 (27 155 127) (28 161 133) (29 171 140) (30 178 150)
 (31 186 152) (32 191 157) (33 207 169) (34 219 185)
 (35 232 190) (36 241 199) (37 255 209) (38 265 223)
 (39 276 226) (40 283 233) (41 298 244) (42 309 259)
 (43 321 263) (44 329 271) (45 342 280) (46 351 293)
 (47 361 295) (48 367 301) (49 383 313))
```
```
(defvar paeth-9-median-sn
  '((0 3) (1 4) (2 5) (0 1) (0 2) (4 5) (3 5) (1 2)
    (3 4) (1 3) (1 6) (4 6) (2 6) (2 3) (4 7) (2 4)
    (3 7) (4 8) (3 8) (3 4)))
```
```
(defvar paeth-25-median-sn
	'((0 1) (3 4) (2 4) (2 3) (6 7) (5 7) (5 6) (9 10)
    (8 10) (8 9) (12 13) (11 13) (11 12) (15 16)
    (14 16) (14 15) (18 19) (17 19) (17 18) (21 22)
    (20 22) (20 21) (23 24) (2 5) (3 6) (0 6) (0 3)
    (4 7) (1 7) (1 4) (11 14) (8 14) (8 11) (12 15)
    (9 15) (9 12) (13 16) (10 16) (10 13) (20 23)
    (17 23) (17 20) (21 24) (18 24) (18 21) (19 22)
    (8 17) (9 18) (0 18) (0 9) (10 19) (1 19) (1 10)
    (11 20) (2 20) (2 11) (12 21) (3 21) (3 12)
    (13 22) (4 22) (4 13) (14 23) (5 23) (5 14)
    (15 24) (6 24) (6 15) (7 16) (7 19) (13 21)
    (15 23) (7 13) (7 15) (1 9) (3 11) (5 17) (11 17)
    (9 17) (4 10) (6 12) (7 14) (4 6) (4 7) (12 14)
    (10 14) (6 7) (10 12) (6 10) (6 17) (12 17)
    (7 17) (7 10) (12 18) (7 12) (10 18) (12 20)
    (10 20) (10 12)))
```
对于大小为 9 的网络，Batcher 的完整排序网络执行 26 次操作。 目前最著名的是弗洛伊德发现的，是执行了 25 次操作。 我们修剪后的 Batcher 网络的中值版本为 22，Paeth 的中值网络为 20。对于大小为 25 的网络，Batcher：138，修剪：113，Paeth：99。所以我们的中值网络似乎与 Paeth 的网络相差 10%，这是目前最知名的 这些大小的中值网络。 正如预期的那样，我们不能修剪 Paeth 网络的任何额外操作：
```
* (length (prune-sn-for-median
            9 paeth-9-median-sn))
20
* (length (prune-sn-for-median
            25 paeth-25-median-sn))
99
```
从理论上讲，这一切都非常有趣。 但在实践中，理论是相当无聊的。 我们开发了所有这些基于列表的排序网络，其中一些使用 Batcher 算法执行完整排序，还有一些使用 Batcher 算法的污染优化来查找中值。 然后，我们为这些网络开发了一个玩具解释器，与真正的分类程序相比，它无疑会表现得非常糟糕。 这与效率有什么关系？ 我们的实验只是产生了理论结果而不是有用的代码吗？ 在大多数语言中，这些实验的结果——我们的排序网络——会以某种高级数据结构表示，并没有多大用处。 但是在 lisp 中，这些网络已经是非常高效的排序程序。 我们只是还没有为它们编写编译器。


练习：调整剪枝算法（及其污染方法），使其产生四分位选择网络。 这些网络不仅确定了中位数，而且还确定了有序元素的高半部分和低半部分的中值元素。
