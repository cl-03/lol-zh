# 4.2 反引用

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

反引号，有时也被叫做 *quasiquote*[2](https://letoverlambda.com/index.cl/guest/chap4.html#)，显示为 **`**（即 Esc 键下面那个键），是主流 lisp 编程相对较新的概念，而且这个概念对于 lisp 外的语言几乎是完全陌生的。

反引号和 lisp 有一段奇异的发展历史。 据报道 [QUASIQUOTATION] 早期没人认为反引号嵌套能正常运行，直到一位敏锐的程序员意识到它们确实正确地运行——人们对正确的概念是错的。 众所周知，反引号嵌套很难理解。 就连 COMMON LISP 之父 Steele 也抱怨它[CLTL2-P530]。

原则上，lisp 不需要反引号。 能用反引号完成的事情都能用其他结构构建功能来完成。 然而，反引号对宏编程非常有用，在 lisp 中意味着所有编程，以至于 lisp 专业人士已经开始严重依赖它。

首先，我们需要了解常规引用。 在 lisp 中，当在一个结构前面加上引号 （**'**） 时，就是告诉 lisp 解释器 将以下结构看作原始数据，而不是要执行的代码。 更确切地说，引号作为代码读入，在执行时会返回一段代码表单。 有时也会说引号*停止或关闭对代码*的执行。

反引号用来代替 lisp 中的引号。 除非某些特殊字符（叫做非引用（**unquote**）字符）出现在代码中，否则反引号会和引号一样不执行代码。 顾名思义，这些非引用字符保留了执行语义。 有时会说非引用是将重启或回到执行。

非引用主要分为三种类型：常规非引用、拼接非引用和破坏性拼接非引用。

要执行常规的非引用，需要用逗号运算符（**,**）：
```
* (let ((s 'hello))
    `(,s world))

(HELLO WORLD)
```
尽管上面代码中取消引用的表达式只是个简单的 **s**变量，但这可以是任意 lisp 表达式，在其出现在反引号模板中的任何上下文，都可以执行计算为有意义的东西。 无论结果是什么，都会插入到出现在反引号模版中结果列表的 *car* 位置。

在 lisp 结构符号中，可以用 **.** 显示地把一些结构放在正在创建的列表结构的 *cdr* 中。 如果在那里放一个列表，则反引号的结果代码仍是一个有效的列表。 但如果在其中放置其他内容，将得到一个新的非列表结构。

在反引号中拥有这种能力，就像在其他地方一样[3](https://letoverlambda.com/index.cl/guest/chap4.html#)。 多亏了反引号的设计，我们甚至可以在这个位置取消引用：
```
* (let ((s '(b c d)))
    `(a . ,s))

(A B C D)
```
在反引号创建的列表的 *cdr* 位置插入列表插入很常见，以至于反引号通过拼接非引用更进一步。上面的 **.,**组合很有用，但无法在列表中间插入元素。 为此，就有拼接非引用运算符：
```
* (let ((s '(b c d)))
    `(a ,@s e))

(A B C D E)
```
**.** 和 **,@** 都不会修改被拼接的列表。例如，在对前面两种结构的反引号进行求值之后，**s** 仍然会绑定到这三个元素列表 **(B C D)** 。 虽然标准没有严格要求，但允许上面 **(A B C D)** 列表中的 **(B C D)** 与拼接列表共享列表 **s**。 然而，在列表 **(A B C D E)** 中，这个列表结构保证在执行反引号时被重新分配，因为禁止修改正在拼接的列表。拼接非引用是非破坏性的，因为通常要考虑反引号用作可重用的创建列表模板。 每次对反引用代码求值时，破坏性地修改不是最新分配的数据的列表结构，这可能会对之后的展开产生不良影响。

然而，COMMON LISP 也提供了个破坏性版本的拼接非引用，可以在拼接非引用能使用的地方使用。 要进行破坏性拼接，使用 **,.** 。 破坏性拼接的工作方式与常规拼接相同，只是在执行反引号模板期间可以修改正在拼接的列表。 除了一个不同于常规拼接的字符之外，这种表示法还巧妙地重用了上面 **.,** cdr 的位置的取消引用。

为了验证这一点，我们在这里破坏性地修改了 **to-splice** 指向的列表：
```
* (defvar to-splice '(B C D))

TO-SPLICE
* `(A ,.to-splice E)

(A B C D E)
* to-splice

(B C D E)
```
破坏性地修改要拼接的列表可能很危险。 想想以下破坏性拼接的使用：
```
(defun dangerous-use-of-bq ()
  `(a ,.'(b c d) e))
```
第一次调用 **dangerous-use-of-bq** 时，返回预期的答案：**(A B C D E)**。 但由于它使用破坏性拼接并修改了一个不是新生成的列表——引用列表——可以预料到各种不良后果。 在这种情况下，第二次执行 **dangerous-use-of-bq** 时，**(B C D)** 列表现在实际上是 **(B C D E)** 列表，并且当反引号试图破坏性地将该列表拼接到反引号模板的其余部分时，**(E)** ——它自己的尾巴——创建了一个包含循环的列表。 我们在[4.5节：循环表达式](./4.5-cyclic-expressions.md)中会详细地讨论循环。

但是，在许多情况下，破坏性拼接是完全安全的。 如果需要提高反引号结构的效率，不要被 **dangerous-use-of-bq** 吓到。 有许多操作可以创建新的列表结构，可能无论如何都要丢弃它们。 例如，拼接 **mapcar** 的结果是如此普遍和安全，以至于以下可能成为编程习惯：
```
(defun safer-use-of-bq ()
  `(a
    ,.(mapcar #'identity '(b c d))
    e))
```
但上面这种格式没有成为编程习惯是有原因的。 反引号最常见的用途是编写宏，这是 lisp 编程中速度最不重要而清晰度最重要的部分。 如果在创建和解释宏时考虑拼接操作的副作用会让你分心，那可能不值得这么麻烦。 这本书坚持常规拼接。 反引号最常见的用途是在宏构造中，但这并不是它唯一的用途。 反引号实际上是一种有用的领域特定语言，用于将列表混在一起的领域，考虑到破坏性拼接的可能性，它变得更加有用。

反引号是如何工作的？ 反引号是一个读取宏。 反引号结构作为代码读入，在执行时成为所需的列表。 回到上一节关于读取时求值的示例，可以关掉美观的打印，引用反引号结构的值，并将其打印出来查看反引号结构确切的读取方式：[4](https://letoverlambda.com/index.cl/guest/chap4.html#):
```
* (let (*print-pretty*) ; bind to nil
    (print
      '`(football-game
          (game-started-at
            ,(get-internal-real-time))
          (coin-flip
            ,(if (zerop (random 2))
               'heads
               'tails))))
    t)

(LISP::BACKQ-LIST
  (QUOTE FOOTBALL-GAME)
  (LISP::BACKQ-LIST
    (QUOTE GAME-STARTED-AT)
    (GET-INTERNAL-REAL-TIME))
  (LISP::BACKQ-LIST
    (QUOTE COIN-FLIP)
    (IF (ZEROP (RANDOM 2))
      (QUOTE HEADS)
      (QUOTE TAILS))))
T
```
在上面这个**打印的很丑（ugly-printed）**的结构中，函数 **LISP::BACKQ-LIST** 与列表相同，除了列表的打印输出比较美观。 注意，逗号运算符已消失。 COMMON LISP 在用反引号读入方面相当自由，特别是对可以共享结构的操作。

反引用还有很多好玩的方法来解决编写一个对自身求值的 lisp 表达式这一有趣的*难题（non-problem）*。 这些表达式在 Willard Quine 对其进行认真的研究之后被普遍称为 *quines*，事实上，Quine 创造了 quasiquote 一词——反引号的替代名称[FOUNDATIONS-P31-FOOTNOTE3]。 一下是个来自[QUASIQUOTATION] 中 Mike McMahon 的有趣 quine 示例：
```
* (let ((let '`(let ((let ',let))
                 ,let)))
    `(let ((let ',let)) ,let))

(LET ((LET '`(LET ((LET ',LET))
               ,LET)))
  `(LET ((LET ',LET)) ,LET))
```
为了让你不需要在心中遍历代码：
```
* (equal * +)

T
```
练习：在下面的代码中，为什么将反引号展开为常规引号？ 不是引用了吗？（译者注，我自己在 sbcl 中执行返回的是 **`Q**，而不是 **'Q**，需要和作者讨论以下）。
```
* '`q
'Q
```
