<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8.6 在 forth 中写 lisp 代码 &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="附录" href="../Appendices/index.html" />
    <link rel="prev" title="8.5 forth 的拓展" href="8.5-going-forther.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第八章：Lisp 与 Forth</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="8.1-weird-by-design.html">8.1 奇怪的设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.2-cons-threaded-code.html">8.2 cons 线程代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.3-duality-of-syntax-defined.html">8.3 语法二元性</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.4-going-forth.html">8.4 开始构建 forth</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.5-going-forther.html">8.5 forth 的拓展</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">8.6 在 forth 中写 lisp 代码</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第八章：Lisp 与 Forth</a> &raquo;</li>
      <li>8.6 在 forth 中写 lisp 代码</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter08/8.6-going-lisp.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="forth-lisp">
<h1>8.6 在 forth 中写 lisp 代码<a class="headerlink" href="#forth-lisp" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>到目前为止，本章已经定义了一个极简的 forth 环境，并从 lispy 的角度展示了一些最重要的 forth 元编程概念。 希望它已经表明，当拥有正确的工具（Common Lisp）时，设计和实现 forth 语言所需的努力是多么的少。 我们可以编写 forth 程序来编写 forth 程序——但我们已经知道了。 这就是一切。 此外，由于 lisp 的宏系统，我们可以编写 lisp 程序来编写 forth 程序。 但是我们可以编写 forth 程序来编写 lisp 程序吗？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">get</span><span class="o">-</span><span class="n">forth</span><span class="o">-</span><span class="n">thread</span> <span class="p">(</span><span class="n">forth</span> <span class="n">word</span><span class="p">)</span>
	<span class="p">(</span><span class="k">with</span><span class="o">-</span><span class="n">pandoric</span> <span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="n">forth</span>
	  <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">word</span><span class="o">-</span><span class="n">thread</span>
   	  <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">lookup</span> <span class="n">word</span> <span class="nb">dict</span><span class="p">))))</span>

<span class="p">(</span><span class="n">defun</span> <span class="nb">print</span><span class="o">-</span><span class="n">forth</span><span class="o">-</span><span class="n">thread</span> <span class="p">(</span><span class="n">forth</span> <span class="n">word</span><span class="p">)</span>
	<span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="o">*</span><span class="nb">print</span><span class="o">-</span><span class="n">circle</span><span class="o">*</span> <span class="n">t</span><span class="p">))</span>
		<span class="p">(</span><span class="nb">print</span> <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="n">forth</span><span class="o">-</span><span class="n">thread</span> <span class="n">forth</span> <span class="n">word</span><span class="p">))</span>
    <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>回想一下，我们的 forth 线程是连接在一起的 cons 单元，这些树的叶子要么是函数（代表原语），要么是原子（代表要压入到参数堆栈的数据）。 因为我们决定让 forth 抽象寄存器可以通过 <code class="docutils literal notranslate"><span class="pre">pandoric</span></code>宏访问，所以编写实用程序来获取和打印 forth 线程很容易。 <code class="docutils literal notranslate"><span class="pre">get-forth-thread</span></code>魔性（pandorically）地打开传递给它的 forth 闭包，然后检索并返回 word 中给出的单词的线程。 <code class="docutils literal notranslate"><span class="pre">print-forth-thread</span></code>打印这个结果线程，其中 <code class="docutils literal notranslate"><span class="pre">*print-circle*</span></code> 绑定到 <code class="docutils literal notranslate"><span class="pre">t</span></code> 以防它包含循环。</p>
<p>为了解释说明，假设已经定义了两个 forth 词：<code class="docutils literal notranslate"><span class="pre">square</span></code>和 <code class="docutils literal notranslate"><span class="pre">square3</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">go</span><span class="o">-</span><span class="n">forth</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span>
    <span class="p">{</span> <span class="n">dup</span> <span class="o">*</span> <span class="p">}</span> <span class="s1">&#39;square name</span>
    <span class="p">{</span> <span class="mi">3</span> <span class="n">square</span> <span class="nb">print</span> <span class="p">}</span> <span class="s1">&#39;square3 name)</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>在编译的 forth 线程中，所有符号和其他单词信息已被删除。 我们所拥有的只是从 forth 的 <code class="docutils literal notranslate"><span class="pre">my-forth</span></code>的字典中提取的一个列表结构：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="nb">print</span><span class="o">-</span><span class="n">forth</span><span class="o">-</span><span class="n">thread</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span> <span class="s1">&#39;square3)</span>
<span class="p">(</span><span class="mi">3</span>
 <span class="p">(</span><span class="c1">#&lt;Interpreted Function&gt;</span>
  <span class="c1">#&lt;Interpreted Function&gt;)</span>
 <span class="c1">#&lt;Interpreted Function&gt;)</span>
<span class="n">T</span>
</pre></div>
</div>
<p>上面的代码没有循环，因此是一个纯 Flub 程序。 如前所述，几乎所有有趣的程序都包含循环。 要创建条件和循环，我们可以使用 forth 原语 <code class="docutils literal notranslate"><span class="pre">branch-if</span></code>，它可以更改 pc 抽象寄存器以指向由正在执行的 forth 线程中的后续单元格中的值指示的某个位置。 我们还能够使用 <code class="docutils literal notranslate"><span class="pre">&gt;r</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r&gt;</span></code> 直接访问返回堆栈来实现尾调用。 与大多数其他语言不同，我们可以直接自定义哪些调用是尾调用——甚至从被调用的单词内部。</p>
<p>但似乎缺少个对 lisp 至关重要的结构：递归。 一个词可以调用自身吗？ 我们看到了如何使用 <code class="docutils literal notranslate"><span class="pre">branch-if</span></code> 跳回到一个词的起始位置 —— 尾递归。 然而，我们真正想做的是通过通用的线程机制让一个词自己调用。 为此，它必须将其线程位置的开头存储为线程中的一个单元格，以便当前位置存储在返回堆栈中，然后它必须将 pc 设置为单词的开头。 然而，到目前为止，还没有一个单词能够使用完全递归，因为在完成编译之前不会命名单词 —— 当搜索字典试图编译递归调用时，我们无法访问它。 幸运的是，可以使用一个简单的技巧来解决这个问题。 在编译递归调用之前，我们可以简单地退出编译模式并命名正在编译的单词。 以下是计算阶乘的完全递归版本的示范定义：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">go</span><span class="o">-</span><span class="n">forth</span> <span class="p">(</span><span class="n">setq</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span> <span class="p">(</span><span class="n">new</span><span class="o">-</span><span class="n">forth</span><span class="p">))</span>
    <span class="p">{</span> <span class="p">[</span> <span class="s1">&#39;fact name ]</span>
			<span class="n">dup</span> <span class="mi">1</span> <span class="o">-</span>
      <span class="n">dup</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="k">if</span> <span class="n">fact</span> <span class="n">then</span>
      <span class="o">*</span> <span class="p">})</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>好了，<code class="docutils literal notranslate"><span class="pre">(fact</span> <span class="pre">5)</span></code>的结果是 120：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">go</span><span class="o">-</span><span class="n">forth</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span>
    <span class="mi">5</span> <span class="n">fact</span> <span class="nb">print</span><span class="p">)</span>
<span class="mi">120</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>练习：有些 forth 实现使用一个单词 <code class="docutils literal notranslate"><span class="pre">recurse</span></code>，它只是查找当前正在编译的单词的线程并将其插入到正在编译的线程中。 这称为匿名递归。 写一个立即字来代替上述实现命名递归的技巧。</p>
<p><code class="docutils literal notranslate"><span class="pre">fact</span></code>的线程比上面的 <code class="docutils literal notranslate"><span class="pre">square3</span></code> 更复杂。 它包含自引用代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="nb">print</span><span class="o">-</span><span class="n">forth</span><span class="o">-</span><span class="n">thread</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span> <span class="s1">&#39;fact)</span>
<span class="c1">#1=(#2=#&lt;Interpreted Function&gt;</span>
    <span class="mi">1</span> <span class="c1">#&lt;Interpreted Function&gt; #2# 1</span>
    <span class="c1">#&lt;Interpreted Function&gt;</span>
    <span class="c1">#&lt;Interpreted Function&gt;</span>
    <span class="c1">#&lt;Interpreted Function&gt;</span>
    <span class="c1">#4=(#&lt;Interpreted Function&gt;</span>
        <span class="c1">#&lt;Interpreted Function&gt;)</span>
    <span class="c1">#1# . #4#)</span>
<span class="n">T</span>
</pre></div>
</div>
<p>在上面，<code class="docutils literal notranslate"><span class="pre">#2#</span></code> 指向的是 <code class="docutils literal notranslate"><span class="pre">dup</span></code>原语并被编译了两次。 <code class="docutils literal notranslate"><span class="pre">#1#</span></code> 指向的是 <code class="docutils literal notranslate"><span class="pre">fact</span></code>线程本身，实现了递归。</p>
<p>这些结构看起来很像用来编写 lisp 程序的 lisp 列表结构，不是吗？ 因为我们了解将执行这些线程的抽象机器，所以可以在简要说明一些限制的情况下将这些线程编译回 lisp 列表结构，该结构可以通过宏插入到表达式中并使用我们的 lisp 编译器进行编译。 这个过程被称为模糊代码，因为我们将编译的程序从统一的、可编程的数据结构（线程）转换为不透明、不可访问的代码块（编译的 Common Lisp 函数）。</p>
<p>当然，我们可以计算或插入宏的 forth 线程和 lisp 列表结构之间存在重大差异。 首先，forth 原语是指向函数的简单指针（此处显示为 <code class="docutils literal notranslate"><span class="pre">#&lt;Interpreted</span> <span class="pre">Function&gt;</span></code>），但需要创建这些函数的 lisp 列表结构。 现在终于到了解释创建的 <code class="docutils literal notranslate"><span class="pre">dtable</span></code>抽象寄存器的时候了。 <code class="docutils literal notranslate"><span class="pre">dtable</span></code>是一个哈希表，它提供了从这些函数到创建它们的列表结构的映射，在创建 forth 时填充。</p>
<p>forth 线程和 lisp 程序之间的一个很大区别是 forth 线程假设它们可以使用返回堆栈——这个概念在像 Common Lisp 这样的 Flub 中并不存在。 我们希望消除对内部解释器代码的需求，而是让 lisp 编译器使用常规的 lisp 控制结构（如函数调用和 <code class="docutils literal notranslate"><span class="pre">tagbody</span></code>/<code class="docutils literal notranslate"><span class="pre">go</span></code> 结构）来处理这个问题。</p>
<p>本章中其余代码的呈现方式与本书中其他大部分代码的不同之处在于，它的实现没有详细描述，而是从高层次的角度描述的。 这是因为实现的机制比较复杂和混乱的，老实说，并不那么有趣。 我只想说我怀疑大多数 lisp 程序员会以类似的方式实现它。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro flubify-aux ()
	`(alambda (c)
			(if c
      	(cond
					((gethash (car c) prim-ht)
          	(assemble-flub
							`(funcall
									,(gethash (car c) prim-ht))
								(self (cdr c))))
           ((gethash (car c) thread-ht)
							(assemble-flub
								`(funcall #&#39;,(car (gethash (car c)
                										thread-ht)))
 								(self (cdr c))))
              ((eq (car c) branch-if)
								(assemble-flub
									`(if (pop pstack)
										 (go ,(gethash (cadr c) go-ht)))
                  (self (cddr c))))
							((consp (car c))
								(flubify forth (car c) prim-ht
                				thread-ht branch-if)
                (self c))
							(t
								(assemble-flub
									`(push &#39;,(car c) pstack)
                  (self (cdr c))))))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">flubify-aux</span></code>是个宏，它展开为一个函数，该函数采用 forth 线程并将其转换为一段 lisp 代码，利用每个非原始单词都被 <code class="docutils literal notranslate"><span class="pre">tagbody</span></code>包围的事实，因此 <code class="docutils literal notranslate"><span class="pre">gensyms</span></code>可以用作 <code class="docutils literal notranslate"><span class="pre">goto</span></code> 的标签。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro assemble-flub (form rest)
	`(if (gethash c go-ht)
			(list* (gethash c go-ht)
      				,form
							,rest)
      (list*  ,form
							,rest)))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">assemble-flub</span></code> 在 <code class="docutils literal notranslate"><span class="pre">flubify-aux</span></code> 中被大量使用作为缩写，它检查哈希表 <code class="docutils literal notranslate"><span class="pre">go-ht</span></code> 以查看在之前的传递中是否找到任何引用当前正在编译的位置的 <code class="docutils literal notranslate"><span class="pre">go</span></code>s。 如果是，它会将之前为其选择的 <code class="docutils literal notranslate"><span class="pre">gensym</span></code> 标签添加到 <code class="docutils literal notranslate"><span class="pre">tagbody</span></code> 结构中。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">flubify</span> <span class="p">(</span><span class="n">forth</span> <span class="n">thread</span> <span class="n">prim</span><span class="o">-</span><span class="n">ht</span>
								<span class="n">thread</span><span class="o">-</span><span class="n">ht</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span><span class="p">)</span>
	<span class="p">(</span><span class="n">unless</span> <span class="c1">#1=(gethash thread thread-ht)</span>
  	<span class="p">(</span><span class="n">setf</span> <span class="c1">#1# (list (gensym)))</span>
		<span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">go</span><span class="o">-</span><span class="n">ht</span> <span class="p">(</span><span class="n">make</span><span class="o">-</span><span class="nb">hash</span><span class="o">-</span><span class="n">table</span><span class="p">)))</span>
			<span class="p">(</span><span class="n">funcall</span>
      	<span class="p">(</span><span class="n">alambda</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
					<span class="p">(</span><span class="n">when</span> <span class="n">c</span>
          	<span class="p">(</span><span class="n">cond</span>
							<span class="p">((</span><span class="n">eq</span> <span class="p">(</span><span class="n">car</span> <span class="n">c</span><span class="p">)</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span><span class="p">)</span>
								<span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">gethash</span> <span class="p">(</span><span class="n">cadr</span> <span class="n">c</span><span class="p">)</span> <span class="n">go</span><span class="o">-</span><span class="n">ht</span><span class="p">)</span>
									<span class="p">(</span><span class="n">gensym</span><span class="p">))</span>
                <span class="p">(</span><span class="bp">self</span> <span class="p">(</span><span class="n">cddr</span> <span class="n">c</span><span class="p">)))</span>
							<span class="p">((</span><span class="n">consp</span> <span class="p">(</span><span class="n">car</span> <span class="n">c</span><span class="p">))</span>
								<span class="p">(</span><span class="n">flubify</span> <span class="n">forth</span> <span class="n">thread</span> <span class="n">prim</span><span class="o">-</span><span class="n">ht</span>
												 <span class="n">thread</span><span class="o">-</span><span class="n">ht</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span><span class="p">)))</span>
          <span class="p">(</span><span class="bp">self</span> <span class="p">(</span><span class="n">cdr</span> <span class="n">c</span><span class="p">))))</span>
			<span class="n">thread</span><span class="p">)</span>
<span class="p">(</span><span class="n">setf</span> <span class="c1">#1# (nconc #1# (funcall</span>
											 <span class="p">(</span><span class="n">flubify</span><span class="o">-</span><span class="n">aux</span><span class="p">)</span> <span class="n">thread</span> <span class="p">))))))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">flubify</span></code>是使用 <code class="docutils literal notranslate"><span class="pre">flubify-aux</span></code>的函数。 第一遍执行时，检查分支 <code class="docutils literal notranslate"><span class="pre">if</span></code> 指令并建立 <code class="docutils literal notranslate"><span class="pre">go-ht</span></code> 哈希表。 它还递归地清除所有连接到当前线程的线程。 事实上，<code class="docutils literal notranslate"><span class="pre">flubify</span></code>实际上可以是双重递归的——只是在展开 <code class="docutils literal notranslate"><span class="pre">flubify-aux</span></code> 的使用之前看不到它。 你看不到它，但 lisp 可以。 如果参照透明度是一块透明的玻璃板，那么我们在这里看到的是一座镜子屋。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun compile-flubified (thread thread -ht)
	`(labels (,@(let (collect)
								 (maphash
                 	(lambda (k v)
										(declare (ignore k))
                    (push
											`(,(car v) ()
												 (tagbody ,@(cdr v)))
											collect))
                  thread-ht)
								(nreverse collect)))
(funcall #&#39;,(car (gethash thread thread-ht)))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">compile-flubified</span></code>采用由 <code class="docutils literal notranslate"><span class="pre">flubify</span></code> 构建的哈希表并将其转换为一个结构，该结构使用标签将这些 flubbed 线程中的每一个绑定到由 <code class="docutils literal notranslate"><span class="pre">gensym</span></code>在函数命名空间中命名的函数中。 在这个范围内，它的展开然后调用原始线程（它也被 flubbed）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">flubify</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="n">shaker</span>
			<span class="p">(</span><span class="n">forth</span> <span class="n">thread</span> <span class="n">ht</span> <span class="n">tmp</span><span class="o">-</span><span class="n">ht</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span> <span class="nb">compile</span><span class="p">)</span>
	<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">gethash</span> <span class="n">thread</span> <span class="n">tmp</span><span class="o">-</span><span class="n">ht</span><span class="p">)</span>
		<span class="p">(</span><span class="k">return</span><span class="o">-</span><span class="kn">from</span> <span class="nn">flubify</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="n">shaker</span><span class="p">)</span>
    <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">gethash</span> <span class="n">thread</span> <span class="n">tmp</span><span class="o">-</span><span class="n">ht</span><span class="p">)</span> <span class="n">t</span><span class="p">))</span>
	<span class="p">(</span><span class="n">cond</span>
		<span class="p">((</span><span class="ow">and</span> <span class="p">(</span><span class="n">consp</span> <span class="n">thread</span><span class="p">)</span> <span class="p">(</span><span class="n">eq</span> <span class="p">(</span><span class="n">car</span> <span class="n">thread</span><span class="p">)</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span><span class="p">))</span>
			<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">cddr</span> <span class="n">thread</span><span class="p">)</span>
      	<span class="p">(</span><span class="n">flubify</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="n">shaker</span>
					<span class="n">forth</span> <span class="p">(</span><span class="n">cddr</span> <span class="n">thread</span><span class="p">)</span> <span class="n">ht</span>
					<span class="n">tmp</span><span class="o">-</span><span class="n">ht</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span> <span class="nb">compile</span><span class="p">)))</span>
		<span class="p">((</span><span class="ow">and</span> <span class="p">(</span><span class="n">consp</span> <span class="n">thread</span><span class="p">)</span> <span class="p">(</span><span class="n">eq</span> <span class="p">(</span><span class="n">car</span> <span class="n">thread</span><span class="p">)</span> <span class="nb">compile</span><span class="p">))</span>
			<span class="p">(</span><span class="n">error</span> <span class="s2">&quot;Can&#39;t convert compiling word to lisp&quot;</span><span class="p">))</span>
    <span class="p">((</span><span class="n">consp</span> <span class="n">thread</span><span class="p">)</span>
			<span class="p">(</span><span class="n">flubify</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="n">shaker</span>
      	<span class="n">forth</span> <span class="p">(</span><span class="n">car</span> <span class="n">thread</span><span class="p">)</span> <span class="n">ht</span> <span class="n">tmp</span><span class="o">-</span><span class="n">ht</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span> <span class="nb">compile</span><span class="p">)</span>
			<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">cdr</span> <span class="n">thread</span><span class="p">)</span>
      	<span class="p">(</span><span class="n">flubify</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="n">shaker</span>
					<span class="n">forth</span> <span class="p">(</span><span class="n">cdr</span> <span class="n">thread</span><span class="p">)</span> <span class="n">ht</span>
					<span class="n">tmp</span><span class="o">-</span><span class="n">ht</span> <span class="n">branch</span><span class="o">-</span><span class="k">if</span> <span class="nb">compile</span><span class="p">)))</span>
    <span class="p">((</span><span class="ow">not</span> <span class="p">(</span><span class="n">gethash</span> <span class="n">thread</span> <span class="n">ht</span><span class="p">))</span>
			<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">functionp</span> <span class="n">thread</span><span class="p">)</span>
      	<span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">gethash</span> <span class="n">thread</span> <span class="n">ht</span><span class="p">)</span>
					<span class="p">(</span><span class="k">with</span><span class="o">-</span><span class="n">pandoric</span> <span class="p">(</span><span class="n">dtable</span><span class="p">)</span> <span class="n">forth</span>
          	<span class="p">(</span><span class="n">gethash</span> <span class="n">thread</span> <span class="n">dtable</span><span class="p">)))))))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">flubify-thread-shaker</span></code>是实际遍历 forth 线程的函数。 它递归地 shake 所有连接的 forth 线程。 这意味着它只隔离了使用 <code class="docutils literal notranslate"><span class="pre">get-forth-thread</span></code> 实用程序执行给定线程所需的相关 forth 线程结构，然后将每个函数转换为相应的 lisp 代码，跳过 <code class="docutils literal notranslate"><span class="pre">if</span></code> 分支并在看到编译时出错。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun forth-to-lisp (forth word)
	(let ((thread (get-forth-thread forth word))
				(shaker-ht (make-hash-table))
				(prim-ht (make-hash-table))
				(thread-ht (make-hash-table))
				(branch-if (get-forth-thread forth &#39;branch-if))
        (compile (get-forth-thread forth &#39;compile)))
	(flubify-thread-shaker
		forth thread shaker-ht
    (make-hash-table) branch-if compile)
	(maphash (lambda (k v)
						(declare (ignore v))
						(setf (gethash k prim-ht) (gensym)))
           shaker -ht)
	(flubify forth thread prim-ht thread-ht branch-if)
  `(let (pstack)
		 (let (,@(let (collect)
     						(maphash
									(lambda (k v)
										(push `(,(gethash k prim-ht)
														(lambda () ,@(butlast v)))
                            collect ))
										shaker-ht)
                  (nreverse collect)))
				,(compile-flubified
        		thread thread-ht)))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">forth-to-lisp</span></code>是本章前面的宏和函数所促进的终极功能。 它采用 <code class="docutils literal notranslate"><span class="pre">new-forth</span></code>创建的forth 环境，查找作为word传递的符号所指示的线程，然后返回相应的lisp代码来执行该线程。 它首先 shake 线程（递归地 shake 所有连接的线程），然后应用 Flubification 过程。 最后，它包装了少量的 lisp 代码，这些代码用常规的 lisp 控制结构实现了内部解释器。</p>
<p>为了说明，回想之前定义的 forth 个单词 <code class="docutils literal notranslate"><span class="pre">square</span></code> 和 <code class="docutils literal notranslate"><span class="pre">square</span></code>。 同样，下面是它们在 <code class="docutils literal notranslate"><span class="pre">my-forth</span></code>环境中的定义方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">go</span><span class="o">-</span><span class="n">forth</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span>
    <span class="p">{</span> <span class="n">dup</span> <span class="o">*</span> <span class="p">}</span> <span class="s1">&#39;square name</span>
    <span class="p">{</span> <span class="mi">3</span> <span class="n">square</span> <span class="nb">print</span> <span class="p">}</span> <span class="s1">&#39;square3 name)</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>下面我们将 <code class="docutils literal notranslate"><span class="pre">square3</span></code> 转换成 lisp 代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">lisp</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span> <span class="s1">&#39;square3)</span>

<span class="p">(</span><span class="n">LET</span> <span class="p">(</span><span class="n">PSTACK</span><span class="p">)</span>
  <span class="p">(</span><span class="n">LET</span> <span class="p">((</span><span class="c1">#:G1814 (LAMBDA () ; dup</span>
                   <span class="p">(</span><span class="n">PUSH</span> <span class="p">(</span><span class="n">CAR</span> <span class="n">PSTACK</span><span class="p">)</span> <span class="n">PSTACK</span><span class="p">)))</span>
        <span class="p">(</span><span class="c1">#:G1815 (LAMBDA () ; *</span>
                   <span class="p">(</span><span class="n">PUSH</span> <span class="p">(</span><span class="o">*</span> <span class="p">(</span><span class="n">POP</span> <span class="n">PSTACK</span><span class="p">)</span>
                            <span class="p">(</span><span class="n">POP</span> <span class="n">PSTACK</span><span class="p">))</span>
                         <span class="n">PSTACK</span><span class="p">)))</span>
        <span class="p">(</span><span class="c1">#:G1816 (LAMBDA () ; print</span>
                   <span class="p">(</span><span class="n">PRINT</span> <span class="p">(</span><span class="n">POP</span> <span class="n">PSTACK</span><span class="p">)))))</span>
    <span class="p">(</span><span class="n">LABELS</span> <span class="p">((</span><span class="c1">#:G1817 () ; square3</span>
               <span class="p">(</span><span class="n">TAGBODY</span>
                 <span class="p">(</span><span class="n">PUSH</span> <span class="s1">&#39;3 PSTACK)</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#&#39;#:G1818)</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1816)))</span>
             <span class="p">(</span><span class="c1">#:G1818 () ; square</span>
               <span class="p">(</span><span class="n">TAGBODY</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1814)</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1815))))</span>
      <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#&#39;#:G1817))))</span>
</pre></div>
</div>
<p>果然，上面是可执行的lisp代码。 如果我们想，可以使用宏在某个地方编译它。 或者我们可以 <code class="docutils literal notranslate"><span class="pre">eval</span></code>它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="nb">eval</span> <span class="o">*</span><span class="p">)</span>
<span class="mi">9</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>为了展示一个带有分支和递归的 forth 线程是如何被混淆的，下面是来自 forth 单词 <code class="docutils literal notranslate"><span class="pre">fact</span></code>编译 成 lisp 代码的一部分：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">lisp</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span> <span class="s1">&#39;fact)</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="n">LABELS</span> <span class="p">((</span><span class="c1">#:G1803 ()							; fact</span>
               <span class="p">(</span><span class="n">TAGBODY</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1797)		; dup</span>
                 <span class="p">(</span><span class="n">PUSH</span> <span class="s1">&#39;1 PSTACK)</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1798)		; -</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1797)		; dup</span>
                 <span class="p">(</span><span class="n">PUSH</span> <span class="s1">&#39;1 PSTACK)</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1799)		; &gt;</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1800)		; not</span>
                 <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">POP</span> <span class="n">PSTACK</span><span class="p">)</span> <span class="p">(</span><span class="n">GO</span> <span class="c1">#:G1804))</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#&#39;#:G1803)  ; fact</span>
                <span class="c1">#:G1804</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1801)    ; nop</span>
                 <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#:G1802)))) ; *</span>
      <span class="p">(</span><span class="n">FUNCALL</span> <span class="c1">#&#39;#:G1803)) ; fact</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>所以我们用forth编写了这个程序，但它现在是lisp。 我们使用了 forth 直接词 <code class="docutils literal notranslate"><span class="pre">if</span></code>和 <code class="docutils literal notranslate"><span class="pre">then</span></code>来编译一个控制递归是否发生的条件控制结构。 代替返回堆栈，lisp 将使用其通用函数调用基础结构为我们实现此递归。</p>
<p>当使用 eval 进行测试时，请记住单词 <code class="docutils literal notranslate"><span class="pre">fact</span></code> 假定堆栈上有一个值，但我们从一个新堆栈开始。 为了测试这个词，我们应该创建一个将值添加到堆栈的包装（wrapper）词。 例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">go</span><span class="o">-</span><span class="n">forth</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span>
    <span class="p">{</span> <span class="mi">5</span> <span class="n">fact</span> <span class="nb">print</span> <span class="p">}</span> <span class="s1">&#39;fact5 name)</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>然后这么执行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="nb">eval</span> <span class="p">(</span><span class="n">forth</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">lisp</span> <span class="n">my</span><span class="o">-</span><span class="n">forth</span> <span class="s1">&#39;fact5))</span>
<span class="mi">120</span>
<span class="n">NIL</span>
</pre></div>
</div>
<p>如前所述，由于 lisp 和forth 之间的差异，我们的 <code class="docutils literal notranslate"><span class="pre">forth-to-lisp</span></code>编译器有一定的局限性。 例如，我们不再提供对返回堆栈的访问，因此任何使用 <code class="docutils literal notranslate"><span class="pre">r&gt;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&gt;r</span></code> 的单词都被禁止。 这包括退出，因此之前的单词倒计时将不起作用。 但是，因为它不使用退出，<code class="docutils literal notranslate"><span class="pre">countdown-for-teh-hax0rz</span></code> 可以正常工作。 因为 lisp 程序无法访问它们的返回堆栈，所以并非所有的控制结构都可以用像 Common Lisp 这样的 Flub 语言来实现。 练习：添加 <code class="docutils literal notranslate"><span class="pre">exit</span></code> 作为一个特殊情况的词，它使用 lisp 块从一个词返回。</p>
<p>另一个限制是 lisp 代码无法编译非 Flub 代码，因此我们无法翻译出 forth 中用来编译的单词，例如 <code class="docutils literal notranslate"><span class="pre">if</span></code>、<code class="docutils literal notranslate"><span class="pre">then</span></code>、<code class="docutils literal notranslate"><span class="pre">begin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">again</span></code>。 当然，请注意，用这些词创建的 forth 线程仍然可以用于编译词，如上与事实一样。 最后一个限制是，在 forth 中，<code class="docutils literal notranslate"><span class="pre">branch-if</span></code>可以跳转到任何线程，即使它是在与当前执行的单词不同的单词中创建的。 在 lisp 中，只能转到 <code class="docutils literal notranslate"><span class="pre">tagbody</span></code>中的其他位置。 Forth 允许非本地分支，但一般的非本地分支不能在像 Common Lisp 这样的 Flubs 中完成。</p>
<p>等一等。 当我们之前在 forth 环境中进行编程时，我们不是只避免了所有这些 Flub 限制吗？ 是的。 宏允许我们将程序与 lisp 相互转换。 多亏了宏，任何东西都可以用 lisp 编程。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="8.5-going-forther.html" class="btn btn-neutral float-left" title="8.5 forth 的拓展" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../Appendices/index.html" class="btn btn-neutral float-right" title="附录" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>