# 4.5 循环表达式

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

所有关于 lisp 程序是 cons 单元树的讨论实际上都是一个小小的谎言。 对此很抱歉。 Lisp 程序实际上不是树，而是有向无环图——可能具有共享分支的树。 由于执行者不关心所执行的分支来自哪里，因此执行具有共享结构的代码并没有错。

一个有用的读取宏是 **#=**。 在[3.5 节：异常捕获](../Chapter03/3.5-unwanted-capture.md)中，我们已经看到了如何在序列化宏展开时使用 **#=** 宏使 lisp 输出表单。**#=** 和它的伙伴 **##** 可以创建自引用的 S 表达式。 这可以让你毫不费力地做一些事情，例如在有向无环图中表示共享分支和其他有趣的数据结构。

但最重要的是，你可以无需拆卸和重组一个高效的内存数据结构序列化数据，其中大部分数据是共享的。 以下是个示例，其中读入的两个 lisp 列表是不同的对象（不相等 **eq**）：
```
* (defvar not-shared '((1) (1)))

((1) (1))
* (eq (car not-shared) (cadr not-shared))

NIL
```
但在以下示例中，用 **#=** 读取宏序列化的数据，这两个列表实际上是同一个列表：
```
* (defvar shared '(#1=(1) #1#))

((1) (1))
* (eq (car shared) (cadr shared))

T
```
正如之前所提到的，我们可以毫不费力地为执行其提供共享的非循环列表结构：
```
* (list
    #1=(list 0)
    #1#
    #1#)

((0) (0) (0))
```
如果打印刚刚执行的最后一个结构，可以看到其执行方式与 lisp 执行器相同：有三个独立分支的普通列表：
```
* +

(LIST (LIST 0) (LIST 0) (LIST 0))
```
但是如果在打印时将 __*print-circle*__ 特殊变量绑定到一个非 **nil** 值，会看到表达式根本不是一棵树，而是一个有向无环图：
```
* (let ((*print-circle* t))
    (print ++)
    t)

(LIST #1=(LIST 0) #1# #1#)
T
```
作为另一个有趣的例子，下面代码展示的是如何通过将 cons 的 cdr 指向自身来打印无限列表，形成所谓的循环或圆：
```
* (print '#1=(hello . #1#))

(HELLO HELLO HELLO HELLO HELLO HELLO HELLO
 HELLO HELLO HELLO HELLO HELLO HELLO HELLO
 HELLO HELLO HELLO HELLO HELLO HELLO HELLO
 ...
```
因此，除非希望发生上面这种情况，否则请确保在序列化循环数据结构时设置 __*print-circle*__ 为 **t**：
```
* (let ((*print-circle* t))
    (print '#1=(hello . #1#))
    nil)

#1=(HELLO . #1#)
NIL
```
```
(defun cyclic-p (l)
  (cyclic-p-aux l (make-hash-table)))

(defun cyclic-p-aux (l seen)
  (if (consp l)
    (or (gethash l seen)
        (progn
          (setf (gethash l seen) t)
          (or (cyclic-p-aux (car l) seen)
              (cyclic-p-aux (cdr l) seen))))))
```
有没有一种简单的方法来判断列表结构的一部分是环的还是包含共享结构？ 有的，**cyclic-p** 谓词用的就是最显然的算法来判断这一点：在结构中递归，使哈希表与迄今为止遇到的所有 cons 单元保持最新。 如果遇到过一个已经存在哈希表中的 cons 单元格，那么就在那里且因此检测到了一个环或一个共享分支。 注意，因为它只在 cons 单元中递归，所以 **cyclic-p** 无法在向量等数据结构中发现此类引用。

最后，因为大多数（参见 [SYNTACTICALLY-RECURSIVE]）lisp 编译器禁止将循环结构传给编译器，执行以下命令是未定义的，但可能会通过将其放入无限编译循环来破坏编译器：
```
(progn
  (defun ouch ()
    #1=(progn #1#))
  (compile 'ouch))
```