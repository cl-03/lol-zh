# 4.3 读取字符串

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

在 lisp 中，字符串由双引号 (**"**) 分隔。虽然字符串可以包含 lisp 实现的字符集中的任何字符，但和其他语言一样，某些特殊字符是不能直接插入的。如果要在字符串中表示引号和反斜杠，需要在其前面加上 `\`。 `\`由被称为转义字符。 例如，以下是包含 **"** 和 `\` 的字符串：
```
* "Contains \" and \\."

"Contains \" and \\."
```
很明显这能顺利执行，但有时输入 `\` 字符会变得乏味且容易出错。 当然，这是 lisp，如果不喜欢某些东西，可以自由地，甚至鼓励去改变它。 本着这种精神，本书提出了一个名为 **#"** 或尖双引号的读取宏。这个读取宏用于创建包含 **"** 和 `\` 字符的字符串，而无需调用转义。
```
(defun |#"-reader| (stream sub-char numarg)
  (declare (ignore sub-char numarg))
  (let (chars)
    (do ((prev (read-char stream) curr)
         (curr (read-char stream) (read-char stream)))
        ((and (char= prev #\") (char= curr #\#)))
      (push prev chars))
    (coerce (nreverse chars) 'string)))

(set-dispatch-macro-character
  #\# #\" #'|#"-reader|)
```
**井双引号**[5](https://letoverlambda.com/index.cl/guest/chap4.html#) 将在其调用字符 **#** 和 **"** 后立即开始读取字符串。它将继续逐个地读取字符，直到再次遇到 **"** 和 **#** 两个字符。 当它找到这个终止序列时，将返回由 **#"** 和 **"#** 之间的所有字符表示的字符串。 井双引号读取宏过去用于位字符串，但 COMMON LISP 通过将位字符串修改为 **#*** 读取宏[EARLY-CL-VOTES]，就释放了这个有用的宏字符。

这是新的井双引号执行示例：
```
* #"Contains " and \."#

"Contains \" and \\."
```
注意，当 REPL 打印字符串时，仍然用 **"** 字符作为分隔符，因此 **"** 和 `\` 字符在字符串的打印表示中仍然被转义。 这些字符串就像手动转义字符一样简单地读入。

但有时 **#"** 不够好。例如，当正在阅读的 U 语言段落中，包含了以下字符 **"#**. 正因为如此，这一段不能用**#"**和**"#**分隔。 而且因为我讨厌逃避事情，所以请相信这不是用常规双引号分隔的。
```
(defun |#>-reader| (stream sub-char numarg)
  (declare (ignore sub-char numarg))
  (let (chars)
    (do ((curr (read-char stream)
               (read-char stream)))
        ((char= #\newline curr))
      (push curr chars))
    (let* ((pattern (nreverse chars))
           (pointer pattern)
           (output))
      (do ((curr (read-char stream)
                 (read-char stream)))
          ((null pointer))
        (push curr output)
        (setf pointer
              (if (char= (car pointer) curr)
                (cdr pointer)
                pattern))
        (if (null pointer)
          (return)))
      (coerce
        (nreverse
          (nthcdr (length pattern) output))
        'string))))

(set-dispatch-macro-character
  #\# #\> #'|#>-reader|)
```
我们需要一个读取宏，可以通过上下文自定义分隔符。 通常情况下，只需从 Larry Wall 的 Perl 语言中寻找编程快捷方式设计的灵感即可。 Perl 是一门美丽的、设计精美的语言，并且拥有许多可以被 lisp 借鉴的好想法。 从某种意义上说，Lisp 是一个大块，也许是一个雪球，不断吸收其他编程语言的思想，使这些思想成为自己的[6](https://letoverlambda.com/index.cl/guest/chap4.html#).

**#>** 读取宏直接受到 Perl 的 **<<** 运算符的启发。 Perl 程序员可以使用这个运算符指定一个文本字符串作为引用字符串结束的分隔符。 **#>** 读取字符直到找到换行符，然后一个接一个地读取字符，直到遇到与紧接在 **#>** 之后和换行符之前找到的字符相同的字符序列。
​
例如：
```
* #>END
I can put anything here: ", \, "#, and ># are
no problem. The only thing that will terminate
the reading of this string is...END

"I can put anything here: \", \\, \"#, and ># are
no problem. The only thing that will terminate
the reading of this string is..."
```
