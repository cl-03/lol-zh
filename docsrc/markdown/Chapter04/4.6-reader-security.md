# 4.6 读取器的安全

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

可扩展性，让原本不打算或预期的事情发生的能力，几乎总是一件好事。 事实上，尽量鼓励可扩展性是 lisp 这么出色的原因。 但是，有时我们希望事物尽可能不可扩展。 特别是，我们不希望外部人员在我们不知情或未经同意的情况下将自己的代码扩展到我们的系统中。 这被称为被黑客入侵或被入侵。 今天，有趣的计算主要是关于通信和网络。 当完全控制两个程序交换数据时，显然是信任整个系统。 但是，一旦某些不受信任的一方有可能甚至部分控制其中一个程序，信任系统就会完全崩溃，就像倒塌的纸牌屋一样。

这些安全问题的最大来源是程序员戏称的*阻抗失配（impedance mismatch）*。每当使用不完全理解的东西时，有可能是用错了。有两种方法可以解决阻抗不匹配问题：样式（不要使用 **strcpy(3)**）和理解（真正阅读手册页）。 Lisp 是编写安全软件的好语言，因为 lisp 比其他语言更能达到。如果你总是遵循 lisp 做正确的假设，那么几乎不会出错。例如，如果尝试在字符串或向量的范围之外写入，这明显是有问题的，lisp 会抛出异常并立即报告该问题。事实上，lisp 做的比预想的更正确：遇到异常后，可以选择在程序的另一个位置重新启动程序，保留大部分计算状态。换句话说，COMMON LISP 的异常系统不会在发生异常时自动销毁计算堆栈：可能仍想使用该堆栈。主要是由于篇幅限制，本书没有详细描述异常系统[13](https://letoverlambda.com/index.cl/guest/chap4.html#)。相反，我推荐 Peter Seibel 的 Practical COMMON LISP[PRACTICAL-CL]。

但学习 lisp 的一部分是发现一切皆可扩展。 到底该如何限制这一点？ 事实证明，这是以错误的方向思考问题。 和所有的计算机安全领域一样，在考虑进攻之前，不能考虑防御。 在其他编程领域，可以建设性地获得不错的结果，即通过构建和使用抽象。 在安全方面，必须进行破坏性思考。 必须试着破坏代码来查找错误，而不是等待然后修复错误。

那么我们关注哪些攻击呢？ 除非以某种方式控制程序的输入，否则无法攻击该程序。 当然，在网络世界中，大多数程序都是毫无用处的，除非人们提供输入。 互联网上有很多用于混洗数据的协议[14](https://letoverlambda.com/index.cl/guest/chap4.html#)。 我们想做的事情种类繁多，无法为数据交换创建通用标准。 做的最好的事情是提供一个可扩展的框架，并允许程序员自定义协议以适应正在创建的应用程序。 通常，这意味着更少的网络开销、更好的传输算法和更高的可靠性。 然而，主要优点是，当我们设计协议时，可以减少或消除阻抗失配，这就是制作安全协议的方法。

数据交换标准的问题在于，为了支持标准，应用程序要被禁止减少协议可以做的事情。 为了使应用程序符合标准，通常要满足一些基线行为。 为了制定安全协议，我们需要能够确保只接受确定可以处理的内容，除此之外一概拒绝。

那么 lisp 交换数据的方式是什么？ 将数据输入 lisp 的机制称为 lisp 读取器，将数据取出的机制称为 lisp 打印机。 如果你已深入本书，那么你已经知道了足够多的知识来设计和使用 lisp 协议。 当编写 lisp 程序时，你就在使用这样的协议。 向 lisp 提供 lisp 结构与 lisp 进行交互，这通常也是与世界其他地方交互的最佳方式。 当然，你不信任世界其他地方，因此必须采取预防措施。 记住，要考虑安全性，就必须考虑攻击。 COMMON LISP 的设计者在设计时考虑了对读取器的攻击。 在本章前面我们描述了 **#.** 读取宏，让读取器执行 lisp 表达式，因此可以编码不可序列化的数据结构。 为了减轻对 lisp 读取器的显示攻击，COMMON LISP 有 __*read-eval*__。以下是从 CLtL2 摘抄下来的：

> _Binding ***read-eval*** to **nil** is useful when reading data that came from an untrusted source, such as a network or a user-supplied data file; it prevents the **#.** read macro from being exploited as a "Trojan Horse" to cause arbitrary forms to be evaluated._

当 ANSI COMMON LISP 委员会在 1989 年 6 月投票决定引入 __*read-eval*__ 时，他们就像攻击者一样思考。攻击者会有什么样的特洛伊木马？从安全软件作者的角度来看，正确的答案是你能想到的最糟糕的答案——或者更糟。要始终攻击者想要完全控制你的系统。传统上，这意味着特洛伊木马应该是一种称为 shell 代码的东西。通常是一段精心设计的机器代码，其作用类似于为攻击者提供一个 unix shell 以进一步攻击受害者。编写此 shell 代码确实是种艺术形式，尤其是因为此类攻击通常利用的不寻常漏洞。例如，大多数 shell 代码不能包含空字节，因为对 C 风格的字符串，这些字节会终止字符串，从而阻止包含更多的 shell 代码。下面是一个 lisp shell 代码示例，假设受害者正在运行 CMUCL 并安装了 Hobbit 的原始 *netcat (nc)* [NETCAT] 程序：
```
#.(ext:run-program
    "/bin/nc" '("-e" "/bin/sh" "-l" "-p" "31337"))
```
上面代码会监听 31337 端口上的连接，并将为任何连接的人提供 unix shell 访问权限。 对于传统的渗透，需要花费大量精力来尝试使其尽可能便携和可靠，这样才能多次成功攻击大多数目标。 这通常来说很困难。 在 lisp 读取器攻击中，这很容易。 以下是我们如何更新 shell 代码使其在 CMUCL 和 SBCL 之间可移植：
```
#.(#+cmu ext:run-program
   #+sbcl sb-ext:run-program
    "/bin/nc" '("-e" "/bin/sh" "-l" "-p" "31337"))
```
所以道德底线是在处理所有略微不信任的数据时，始终保证将 __*read-eval*__ 绑定到 **nil**。 如果你很少使用 **#.** 读取宏，明智的选择是将 **#.** 设为 **nil** 且仅在需要使用时启用。

所以能很简单就禁用 **#.** 读取宏。 但这够了吗？ 这取决于应用程序以及什么被认为是有效的攻击。 对于交互式程序，这可能就足够了。 如果我们得到坏数据，会尽快且大声地听到它。 然而，对于互联网服务器来说，这可能还不够。 想一下这个 shell 代码：
```
)
```
或是这个：
```
no-such-package:rewt3d
```
Lisp 通常会抛出异常，因为我们试图以不匹配的格式读取或在不存在的包中查找符号。 这很可能导致整个应用程序停止运行。 这被称为拒绝服务攻击。 更微妙和更难调试的拒绝服务攻击是使用 **##** 和 **#=** 读取宏传递循环结构。 如果我们处理这些数据的代码没有考虑到这种形式，那么结果就是阻抗不匹配，且很可能是个安全问题。 另一方面，也许应用程序会依赖于能够传递循环和共享数据结构。 数据安全的需求完全取决于应用程序。 幸运的是，无论有什么要求，lisp 读取器和打印机都能胜任。
```
(defvar safe-read-from-string-blacklist
  '(#\# #\: #\|))

(let ((rt (copy-readtable nil)))
  (defun safe-reader-error (stream closech)
    (declare (ignore stream closech))
    (error "safe-read-from-string failure"))

  (dolist (c safe-read-from-string-blacklist)
    (set-macro-character
      c #'safe-reader-error nil rt))

  (defun safe-read-from-string (s &optional fail)
    (if (stringp s)
      (let ((*readtable* rt) *read-eval*)
        (handler-bind
          ((error (lambda (condition)
                    (declare (ignore condition))
                    (return-from
                      safe-read-from-string fail))))
          (read-from-string s)))
      fail)))
```
**safe-read-from-string** 是对读取器安全问题的部分回答。 与本书中的大多数代码相比，该函数不太适合生产使用。 建议仔细思考应用程序的安全要求，并为应用程序调整（甚至重写）此代码。 **safe-read-from-string** 是 **read-from-string** 的一个很锁定的版本。 它有默认的 lisp *readtable* 的副本。 此副本已删除大部分有趣的读取宏，包括 **#** 调度宏。 这意味着向量、位向量、gensyms、循环引用、**#.** 和所有其他的都没有了。 **safe-read-from-string** 甚至不允许关键字或外来包符号。 但是，它不仅允许格式良好的列表，还允许 cons 结构。同时还允许数字[15](https://letoverlambda.com/index.cl/guest/chap4.html#)和字符串。

**safe-read-from-string** 使用 lisp 的异常系统来捕获所有由 lisp **read-from-string** 函数抛出的异常。 如果从字符串中读取有任何问题，包括遇到不匹配的括号或遇到在 **safe-read-from-string-blacklist** 变量中列入黑名单的其他读取宏，则 **safe-read-from-string** 将返回第二个参数的值，如果没有第二个参数，则为 **nil**（记住，你可能希望读取 **nil**）。 以下是经典的用法[16](https://letoverlambda.com/index.cl/guest/chap4.html#)：
```
(let* ((g (gensym))
       (v (safe-read-from-string
            user-supplied-string g)))
  (if (eq g v)
    (log-bad-data ; careful how it's logged!
      user-supplied-string)
    (process v)))
```
当然，这个版本的安全读取字符串非常有限，可能需要修改应用程序。 特别是，可能需要关键字符号。 启用它们很容易：当使用 **safe-read-from-string** 时，只需将不带 **:** 字符的列表绑定到 **safe-read-from-string-blacklist** 并注意符号可能驻留在多个包中（包括 **keyword** 包） 。即使删除 **:** 字符，上面的 shell 代码包也会被阻止，因为我们会在读取过程中捕获所有异常，包括表示包不存在的错误。 如果决定从黑名单中删除 **#** 字符，将 __*Read-eval*__ 始终绑定为 **nil**。 这样做后，可能想为 **#** 调度宏创建一个子黑名单（可能是一个大的黑名单）。 竖线字符被列入黑名单，这样就不会读到古怪的符号。

因此，可以在觉得必要的时候尽可能严格地锁定读取器，事实上，就像应用程序允许的那样严格。但是，即使在通过用于读取表单的软件确定不存在攻击向量之后，如何才能最大限度地减少我们认为的 lisp 表单的结构与实际可能的结构之间的阻抗不匹配？我们必须验证它是否符合预期。一些数据标准将此过程称为针对模式的验证，但 lisp 将其称为针对扩展的 lambda 形式的 **destructuring-bind**。所有这些术语听起来都比其所代表的简单概念更重要。其思想是，希望确保数据的形式或结构符合给定处理的要求。 **destructuring-bind** 检查这个结构，提供了一种非常有用的模式语言，其中包括关键字和可选参数，还有一个好处是可以在进行过程中命名结构的不同部分。

我可以举一些例子来说明如何使用 **destructuring-bind**，但实际上没有必要：我们一直在使用解构。 当我们使用 **defmacro**、**defmacro!** 或 **destructuring-bind** 时，我们在宏名称之后立即插入的参数或参数列表称为扩展 lambda 列表，以强调它比对普通 lambda 列表执行的解构更强大的事实。 使用扩展 lambda 列表，可以嵌套扩展 lambda 列表以解构任意深度的列表结构。 Paul Graham 的 On Lisp 对解构有很好的处理。 尤其是 **with-places** 宏[ON-LISP-P237]，最好在阅读[6.7 节：潘多拉宏](../Chapter06/6.7-pandoric-macros.md) 之后再去看看 **with-places** 宏。

因此，每次编写宏或函数时，在某种意义上，都将宏或函数将接收的参数视为数据，并将扩展或常规 lambda 列表视为模式。 有鉴于此，数据验证似乎很容易。 Lisp 可以验证数据是否按照应有的结构进行了构建，如果不是，则会引发错误情况。 和上面的读取器一样，在处理不太信任的数据时，应该非常仔细地考虑可能的攻击，然后用 lisp 强大的异常和宏系统来构建一个验证方案，只允许应用程序的最低要求，并直接映射到应用程序如何工作，减少或消除任何阻抗失配。 CL-PPCRE 正则表达式对于这项任务也是必不可少的。 没有其他语言具有 lisp 所具备的安全软件潜力，且随着时间的推移，这一点只会变得更加明显。
