<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.3 控制结构 &mdash; Let Over Lambda 中文文档  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3.4 自由变量" href="3.4-free-variables.html" />
    <link rel="prev" title="3.2 领域特定语言" href="3.2-domain-specific-languages.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第三章：宏基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="3.1-iterative-development.html">3.1 迭代开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.2-domain-specific-languages.html">3.2 领域特定语言</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.3 控制结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.4-free-variables.html">3.4 自由变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.5-unwanted-capture.html">3.5 异常捕获</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.6-once-only.html">3.6 Once Only</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.7-duality-of-syntax.html">3.7 Duality of Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第三章：宏基础</a> &raquo;</li>
      <li>3.3 控制结构</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter03/3.3-control-structures.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>3.3 控制结构<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>虽然这本书的重点是 COMMON LISP，但它也是为 Scheme 编程语言编写的，同时也是关于 Scheme 编程语言的。 Scheme 是一门很棒的语言，尽管缺少 lisp 程序员习以为常的特性，但它仍然为专业 lisp 程序员提供了足够灵活的核心，可以按需扩展<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">2</a>。 同样，Scheme 程序员严重依赖的一些 COMMON LISP 没有专门解决的特性。 但是，除了少数例外，每种语言提供的功能之间的比较是没有意义的。 两种语言之间的鸿沟可以且经常被弥合。 用来连接两种语言的桥梁当然是——宏。</p>
<p>Scheme 的 <strong>let</strong> 结构 在某一方面比 COMMON LISP 对应的结构要更强大。 Scheme 的 let 结构支持一种<em>命名的 let（named let）</em> 。在 Scheme 中，可以在 let 结构的绑定列表之前插入一个符号，Scheme 将在 <strong>let</strong> 主体<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">3</a>周围绑定一个由提供的符号命名的函数。 此函数接受 <strong>let</strong> 绑定中提供的值的新参数，提供了一种非常方便的方式来表示循环。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro nlet (n letargs &amp;rest body)
  `(labels ((,n ,(mapcar #&#39;car letargs)
              ,@body))
     (,n ,@(mapcar #&#39;cadr letargs))))
</pre></div>
</div>
<p>幸运的是，我们可以用 <strong>nlet</strong> 宏在 Scheme 和 COMMON LISP 之间架起一座桥梁。 <strong>Nlet</strong> 通过模拟 Scheme 的命名然后以 Scheme 风格进行编码。 在 <strong>nlet-fact</strong> 中，<strong>nlet</strong> 用于通过使用命名的 let 来定义阶乘函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">nlet</span><span class="o">-</span><span class="n">fact</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">(</span><span class="n">nlet</span> <span class="n">fact</span> <span class="p">((</span><span class="n">n</span> <span class="n">n</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">zerop</span> <span class="n">n</span><span class="p">)</span>
      <span class="mi">1</span>
      <span class="p">(</span><span class="o">*</span> <span class="n">n</span> <span class="p">(</span><span class="n">fact</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span> <span class="mi">1</span><span class="p">))))))</span>
</pre></div>
</div>
<p>因为 <strong>nlet</strong> 是我们的第一个宏，先放慢一下脚步，深入分析一下。 有时为了理解一个宏，展开一个宏<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">4</a>的使用示例会有所帮助。 为此，向 <strong>macroexpand</strong> 函数提供一个表示此宏调用的列表。 注意，<strong>macroexpand</strong> 只会展开其符号位于列表第一个元素中的宏，并且不会展开嵌套的宏调用<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">5</a>。 在下文中，我们直接从 <strong>nlet-fact</strong> 复制一个 <strong>nlet</strong> 调用，引用它，并将它传给 <strong>macroexpand</strong> 宏：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(nlet fact ((n n))</span>
       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">zerop</span> <span class="n">n</span><span class="p">)</span>
         <span class="mi">1</span>
         <span class="p">(</span><span class="o">*</span> <span class="n">n</span> <span class="p">(</span><span class="n">fact</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span> <span class="mi">1</span><span class="p">))))))</span>

<span class="p">(</span><span class="n">LABELS</span> <span class="p">((</span><span class="n">FACT</span> <span class="p">(</span><span class="n">N</span><span class="p">)</span>
           <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">ZEROP</span> <span class="n">N</span><span class="p">)</span>
             <span class="mi">1</span>
             <span class="p">(</span><span class="o">*</span> <span class="n">N</span> <span class="p">(</span><span class="n">FACT</span> <span class="p">(</span><span class="o">-</span> <span class="n">N</span> <span class="mi">1</span><span class="p">))))))</span>
  <span class="p">(</span><span class="n">FACT</span> <span class="n">N</span><span class="p">))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>上面的展开中使用 <strong>labels</strong> 特殊结构在给定的主体周围绑定一个函数。 该函数根据命名 let 结构中使用的符号命名。 它将与 <strong>nlet</strong> 绑定的值作为参数，这里只有 <strong>n</strong>。 由于这个函数可以是递归的，所以 <strong>nlet</strong> 实现了一个有用的迭代构造。</p>
<p>尽管简单的宏可能只是填充反引号模板，但大多数复杂的宏至少会使用 lisp 的扩展列表处理功能。 <strong>Mapcar</strong> 将函数应用于列表中的每个元素并返回结果值列表，在宏中尤其常见。 令人注意的是，<strong>mapcar</strong> 也经常出现在常规的 lisp 代码中。 Lisp 已被调整为尽量处理列表。 在各种 lisp 编程中，包括宏构造，拼接、合并、归约、映射和过滤列表。 唯一的区别是在编写宏时，输出随后被传递给编译器或解释器。 在 lisp 中编写宏实际上与编写常规 lisp 的过程相同。</p>
<p>但是说 <strong>nlet</strong> 是一种新的控制结构是什么意思呢？ 控制结构只是描述一些不遵循函数行为构造的一种奇特方式。 函数将从左到右计算执行每个参数，将结果绑定到环境中，并执行由某种 <strong>lambda</strong> 结构指定的机器代码。 由于 <strong>nlet</strong> 不直接计算执行参数，而是将参数拼接到 lisp 代码中，我们改变了 <strong>nlet</strong> 结构的计算执行流程，从而创建了一个新的控制结构。</p>
<p>通过这个宽泛的定义，几乎所有的宏——至少有趣的宏——都定义了新的控制结构。 当别人说“只在函数不做的时候使用宏”时，他们的意思是对于任何不想计算某些参数的定义，或者想无序地计算它们，或者不止一次，你需要使用宏。 函数，无论编写得多么巧妙，都无法正常工作。</p>
<p><strong>nlet</strong> 宏演示了 COMMON LISP 是为宏编写者设计的一种方式。 在诸如 <strong>let</strong> 之类的绑定结构中，如果没有随变量名一起指定值，则将变量绑定为 nil 是种默认操作。 换句话说， <strong>(let ((a)) a)</strong> 返回的结果为 nil。 在 Scheme 中，一种对宏编写器不太友好的语言，在迭代此类绑定时必须将这种情况作为特殊情况进行检查，因为 <strong>(car nil)</strong> 和 <strong>(cdr nil)</strong> 会引发类型错误。 在 COMMON LISP 中，<strong>(car nil)</strong>、<strong>(cdr nil)</strong>，以及 <strong>(car (cdr nil))</strong> 和 <strong>(cadr nil)</strong> 定义为返回 <strong>nil</strong>，即使空的 let 变量约定被使用了，<strong>nlet</strong> 中的第二个 <strong>mapcar</strong> 也能正常运行。 此 COMMON LISP 功能来自 Interlisp[INTERLISP]。</p>
<p>我们的 <strong>nlet</strong> 宏与 Scheme 的命名 let 有个微妙的差异。 在这种情况下，宏的接口是可以接受的，但展开可能不是。 在跨多个级别进行编程时很常见，我们代码的理想模型很容易与现实略有不同。 在 Scheme 中，命名 let 的尾调用保证不会占用额外的堆栈空间，因为根据标准，Scheme 需要进行这种特定的优化。 然而，在 COMMON LISP 中情况并非如此，因此在 COMMON LISP 版本的 <strong>nlet</strong> 中可能会发生堆栈溢出，而在 Scheme 中的命名 let 中不会发生这种情况。 在<a class="reference internal" href="../Chapter05/5.4-code-walking-with-macrolet.html"><span class="doc std std-doc">5.4 节：使用 Macrolet 进行代码遍历</span></a>中，我们将看到如何编写具有相同接口但可能更有效的扩展的 <strong>nlet</strong> 版本<a class="reference external" href="https://letoverlambda.com/index.cl/guest/chap3.html#">7</a>。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3.2-domain-specific-languages.html" class="btn btn-neutral float-left" title="3.2 领域特定语言" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="3.4-free-variables.html" class="btn btn-neutral float-right" title="3.4 自由变量" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>