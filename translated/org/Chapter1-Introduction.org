* 介绍
   :PROPERTIES:
   :CUSTOM_ID: introduction
   :END:

** 宏（Macros）
    :PROPERTIES:
    :CUSTOM_ID: sec_1
    :END:

/Lisp 的宗旨在编程语言中占据了某种局部最优的位置。 ---lisp创造者，约翰·麦卡锡(John McCarthy)最谦逊的话/


本书主要内容是用 lisp 来编写 /宏（Macros）/。与绝大多数编程书不同的是，本书是通过一系列的教程和例子，让你尽可能快速有效地编写复杂的宏，而不是粗略的浏览下宏。掌握宏是从中级 lisp 程序员晋身为 lisp 专家的最后一步。

宏是 lisp 作为编程语言最大的特性，同时也是与其他任意语言相比最大的优势。通过宏，你可以轻而易举地实现其他语言不能实现的功能。这是因为宏可以将 lisp 转换成其他的编程语言并转换回来，经验丰富的宏程序员会发现，其他所有的语言只不过是 lisp 的冰山一角。这点很重要。Lisp 特殊之处在于它实际上是处于较高的层次进行编程。当大多数语言在发明并制定语法和语义规则时，lisp 却是通用的、可塑的。用 lisp，你来指定这些规则。

与其他编程语言相比，lisp 拥有更加深厚、久远的历史。在我们这个短暂存在的领域中，有一些最优秀、最聪明的计算机科学家努力地让 lisp 成为有史以来最强大、最通用的编程语言。Lisp 还拥有许多简洁的标准，多种优秀的开源实现，以及比任何其他编程语言都更方便的宏。本书虽然是用 /COMMON LISP^{[ANSI-CL][CLTL2]}/ 来举例，但其中很多思想是能够轻易地移植到其他的 lisp 语言上，如 /Scheme^{[R5RS]}/。也就是说，如果你想编写宏，希望本书能让你确信：COMMON LISP 才是正确的选择。虽然不同类型的 lisp 在其他方面都很出色，但是对于宏专家来说，COMMON LISP 才是是值得选择的。

COMMON LISP 的设计者在设计 /正确/ 的编程语言方面做得很出色。特别是在考虑过实现的质量后，COMMON LISP 是目前程序员的最佳编程环境，几乎没有保留。身为程序员，你几乎可以用 COMMON LISP 以原有的方式来进行编程。虽然设计者和实现者确实是以正确的方式实现了它，但仍有人觉得他们忘了告诉我们为什么 COMMON LISP 是正确的。对很多外行人来说，COMMON LISP 看起来就像个巨大而又拥有奇怪特性集合，因此不使用 COMMON LISP，转而使用一种更令人满意的语言 —— 他们永远也体验不到宏的真正威力。虽然这不是本书的主要目的，但是本书可以作为使用 COMMON LISP 这种充满魔力的语言的许多最佳特性的指南。大多数语言的设计都是为了易于实现；而 COMMON LISP 被设计为功能强大的编程语言。我真的希望 COMMON LISP 的创始人能够喜欢这本书，因为这是一本最全也最易于理解的描写 COMMON LISP 高级宏特性的书，而它只不过是宏主题中一滴快乐的水而已。

宏的历史几乎和 lisp 本身一样悠久，这并非偶然。lisp 是 Timothy Hart 在1963年发明的。然而，大多数 lisp 程序员并没有发挥宏的全部功能，并且，并不是所有的 lisp 程序员都会使用宏。经验丰富的lisper 对此十分不解。既然宏如此强大，为什么大家都不用宏呢？诚然，最聪明、最坚定的程序员最终都会选择 lisp 宏，但很少有人在刚开始编程时就接触宏。要理解宏为何如此强大，需要理解 lisp 具有其他语言所没有的特性。它首先需要理解其他功能较弱的语言。遗憾的是，大多数程序员在掌握了一些其他语言之后就失去了学习动力，因此也就永远无法理解宏是什么或如何利用宏。但是任何语言的顶尖程序员总是被迫学习某种编写程序的方法：宏。由于 lisp 是编写宏的最佳语言，所以最聪明、最坚定同时又好奇的程序员最后总会用 lisp。

尽管顶尖的程序员是占少数的，但随着编程人员的增长，顶尖程序员的数量也会增多。编程界很少见到一些强大的宏，理解的就更少了，但是这种情况这在发生改变。由于通过宏可以实现生产力的倍增，所以无论世界是否准备好了，宏的时代即将到来。本书旨在为不可避免的未来——宏的世界——做一个基本的准备。准备好吧。

通常来说，只有在必要时才用宏。这是因为宏难以理解，同时也包含了一些小 bug，如果你将宏看作函数，那你在使用宏上会有很大的限制。但这并不是 lisp 宏缺陷，而是宏的一般特性。与任何技术一样，工具越强大，就越容易滥用。并且，就编程构造而言，lisp 宏是最强大的工具。

有趣的是，学习 lisp 的宏类似于学习 C 语言的指针。大多数初学 C 语言的程序员都能很快掌握这门语言的大概。函数、类型、变量、算术表达式：从小学数学到更简单的编程语言，所有这些都与初学者以前的智力相关。但是大多数 C 语言的新手碰到指针时就遇到了瓶颈。

对老练的 C 程序员来说，指针是他们的第二天性，他们中的大部分人认为要想正确地使用 C 语言，就必须完全理解指针。由于指针是如此基础，大部分老练的 C 程序员会建议不要限制指针在格式上或学习方面的使用。尽管如此，许多 C 新手觉得没必要费劲来学指针，因此他们就避免用指针，导致了一种 /所有的语言都套用 FORTRAN 思想/ 的现象，从而忽视了语言的其他重要的特性。这种弊病不是多糟糕的编程风格，而是对语言特性的忽视。一旦完全理解了这些特性，正确的样式就很容易了。本书的副主题(适用于任何编程语言)是，在编程中，不需要刻意去追求的格式。只有在比较难懂的地方，才需要注意格式[fn:1]。

与 C 指针一样，宏也是 lisp 的特性，但人们不怎么理解宏，关于如何正确使用宏的智慧非常分散和理想化。如果在考虑宏时，你发现自己依赖于格言风格，比如

/宏改变了 lisp 的语法。/

/程序中宏像解析树一样工作/

/只有在函数无法实现时才用宏。/

当你使用宏时，你可能缺乏大局观，而这正是本文所要讲解的。

除了 Paul Graham 的 /On Lisp/^{[ON-LISP]} 之外，几乎没有比较好的介绍宏的资料或教程。每个对宏感兴趣的人都应该认真地阅读 /On Lisp/ 这本书。 /On Lisp/ 及 Graham 其他著作对本书的创作有很重要的启发。得益于 Paul Graham 和其他 lisp 程序员，强大的宏在程序员之间得到了广泛的讨论，不幸的是，宏仍然被广泛误解。即便是通过稍微熟读 /On Lisp/ 就能获得宏的编程技巧，但是很少有程序员能够将宏和实际编程问题联系起来。由于 /On Lisp/ 介绍的是不同类型的宏，所以本书将会介绍如何使用它们。

编写宏是一个反思和迭代的过程。所有复杂的宏都来自相对简单的宏，通常需要经过一系列的改进测试周期。更重要的是，知道在哪里应用宏是直接从编写宏中获得的技能。当写程序的时候，作为一个有思想的人，不管你是否意识到，你都在遵循某个系统或某个过程。每个程序员都有一个关于编程工具如何工作的概念模型，而代码的创建就是这个概念模型的直接逻辑结果。一旦某个聪明的程序员开始把编程作为一个逻辑过程来考虑，下一步就是让这个过程从自动化中获益。毕竟，程序员接受的培训就是这样的：自动化流程。

理解宏的关键一步是要认识到：没有仔细的规划和大量的工作，任何程序的主体都会存在冗余的模式和僵硬的抽象的问题。这种情况在大型软件项目中经常可以见到，要么是有重复的代码，或者是不必要的复杂代码，这是因为编写的人无法获得正确的抽象。对宏的高效使用就是需要识别这些模式和抽象，然后编写 /代码来帮你编码/。 仅仅知道如何编写宏是不够的；lisp 大神还需要知道为什么要编写这个宏。

初学 lisp 的 C 程序员常常误以为宏的主要目的是提高运行时代码的效率[fn:2]。虽然宏在这方面确实很有效，但到目前为止，宏最通用的是让编写应用程序的工作更容易。由于大多数程序中的大部分模式存在冗余复制，而且它们进行完全的抽象，因此适当设计的宏可以在新的表达层次上进行编程。当其他语言比较僵硬的、特定的，lisp 却是可变的、通用的。

本书不是用来 lisp 入门的，这些话题和材料的对象是非 lisp 的专业程序员以及对宏感兴趣并已经准备好好学习 lisp 的特殊的中级 lisp 学生。假设他们了解 lisp 的基础到中级方面的知识，但对闭包和宏没有有深入的理解。

这也不是本偏理论书，所有的例子都都是一些可运行且很有用的代码，这些代码在今后的编程中很有帮助。这本书介绍的使用先进的编程技术来提高你的编程水平。与其他许多故意使用简单编程风格以提高可访问性的编程书籍相反，本书认为，教授编程的最佳方法是充分利用该语言。虽然本文中的许多代码示例使用了 COMMON LISP 的晦涩特性，但是这些正是这些特性的正确用法。更确切地说，如果你有读过并理解了(fn: 3)[[https://letoverlambda.com/textmode.cl/guest/chap2.html][2章,闭包]]和[[https://letoverlambda.com/textmode.cl/guest/chap3.html][第三章、宏观基础]]，对于这本书的目的，你可以认为自己在经历理解 lisp 的过渡期。

lisp 的部分特性需要你自己来探索，而且本书不会剥夺这个探索的乐趣。值得注意的是，本书的进度比一般的书都要快，比你之前的要快的多。要理解本书中的一些代码，你可能需要参考其他 COMMON LISP 教程资料。介绍了基础知识之后，本书将直接跳到一些当今对宏最为先进的研究，其中大部分都是围绕着一个较大的、未被探索的灰色知识领域展开的。与所有高级宏编程一样，本书重点关注在宏的 /组合/。这个话题有点吓人了，很少(如果有的话)有程序员能够真正的了解它。宏的组合代表了当今编程语言中最广泛和最丰富的研究领域。学术界已经从类型、对象和 prolog 风格的逻辑中发掘了很多有趣的结果，但是宏编程仍然是一个巨大的黑洞。没人真正知道这背后到底有什么。我们所知道的是，这点不会错的，那就是宏是复杂和可怕的，但目前似乎是有无限的潜力。与其他太多的编程思想不同，宏既不是炮制无用理论出版物的学术概念，也不是空洞的企业软件术语。宏是黑客最好的朋友。宏让你的程序更智能，而不是更困难。大多数懂点宏的程序员决定，他们再也不想在没有宏的情况下编程了。

虽然大部分的 lisp 书都是为了使 lisp 更受欢迎而编写的，但是我完全不关心 lisp 是否一天比一天更受欢迎。Lisp 是不会消失的。如果我能在我余下的编程生涯中继续用 lisp 作为 /秘密武器/ 的话，我将非常高兴。如果非要说本书有个目的，那就是激发对宏的学习和研究，就像我所受到 /On Lisp/ 的启发一样。我希望这本书的读者也能受到启发，那么到那时我可能会享受到更好的有关 lisp 宏工具或是更有趣的 lisp 宏的书籍。

始终对 lisp 的强大功能保持警惕之心，

一位谦逊的作者，

Doug Hoyte

** U 语言
    :PROPERTIES:
    :CUSTOM_ID: sec_2
    :END:

由于讨论宏就像讨论讨论本身，所以我们需要非常清楚地知道本书需要阐述的观点。我现在所写的东西，就像传达给你们读到的和解释到的一样，本身就是一个值得形式化和分析的表达系统。

没有人比 /《数理逻辑基础》/^{[FOUNDATIONS]} 的作者 Haskell Curry 更能理解这一点。由于 Curry 不仅试图将思想正式化，并且还试图表达想法，他发现有必要将作家和读者之间交流语言抽象成这个概念。他称之为 U 语言。

/每一项调查，包括现在的，都必须用语言从一个人传达给另一个人。我们刚开始研究时，最好注意这一明显的事实，给所使用的语言起个名字，并说明它的一些特点。我们将使用的语言称为u语言。[……]如果不是因为一门语言比大多数其他语言与我们的工作关系更密切，就没有必要引起注意。/

在这本书中，我们将介绍一些重要的新概念或者说是要点，否则没必要用 /斜体/ 标明出来了。当引用程序中的特殊格式、函数、宏和其他标识符时，无论是相关的还是无关的，我们都将使用 *粗体* （注意，有些单词有多种含义，例如 COMMON LISP 中 *lambda* 宏与 lambda 概念， *let* 一个特殊的格式与一个名为 *let* 的 *let* 格式列表）。

EXAMPLE-PROGRAM-LISTING

#+BEGIN_EXAMPLE
  (defun example-program-listing ()
    '(this is
       (a (program
            (listing)))))
#+END_EXAMPLE

在这本书中，将以 /程序清单/ 的形式介绍了一些新的代码。为重用而设计的代码，或作为适当实现的示例，如函数 *example-program-listing* 的定义中所示。但有时我们希望演示一些代码的使用，或者只是想讨论一些表达式的属性，而不脱离书面文本[fn:4]。在这些情况下，代码或代码的示例使用将如下所示:

#+BEGIN_EXAMPLE
  (this is
    (demonstration code))
#+END_EXAMPLE

许多编程的书都使用大量孤立的、人为的例子来阐明一个观点，却忘记了将其与现实联系起来。本书的示例都尽量简单些与直接些，以便阐述目前正在解释的大局编程思想。有些文章试图用可爱、古怪的标识符名称或肤浅的类比来掩饰自己的无聊。我们的例子只是用来阐述思想。也就是说，这本书尽量不把自己(或任何事情)写得太过严肃。本文中有些有趣的地方，只不过是需要你去寻找它。

由于 lisp 的交互性，计算一个简单表达式的结果往往可以得到比同等情况下的U语言的更多的信息。在这种情况下，这是我们将如何展示一个常见的 LISP 读入、计算、输出、循环（简称为 /REPL/ ）：

#+BEGIN_EXAMPLE
  * (this is
      (the expression
        (to evaluate)))

  THIS-IS-THE-RESULT
#+END_EXAMPLE

注意我们输入的文本是小写的，而 lisp 返回的文本是大写的。这是 COMMON LISP 的一个特性，它允许我们轻松地浏览 REPL 打印输出，并让我们知道哪个是我们的输入，哪个是 REPL 的输出。更切确地说，这个特性允许我们快速浏览任何包含符号的 lisp 表单（在任何文件或屏幕上），并能马上知道 lisp 解释器是否已经处理过它。还要注意星号（ *** )表示一个提示符。这个字符是合理，因为它不能与一个对称的字符混淆，因为它的高像素计数，使它在浏览一个 REPL 会话时很明显。

编写复杂的 lisp 宏是个 /交迭/ 过程。没有人会坐下来，用其他语言程序常见的漫不经心的风格，敲下一个长达一页的宏。这一部分原因是 lisp 代码每页包含的信息比大多数其他语言都要多，还有一部分原因是 lisp 技术鼓励程序员开发他们的程序：根据应用程序的需要，通过一系列的增强，从而改进代码。

这本书从 lisp 更抽象的概念到期构造细节区分了 lisp 的类型，像 COMMON LISP 和 Scheme。另一个就是着重的区分了lisp 和非 lisp 语言。有时我们需要讨论一些非 lisp 语言，为了尽可能少地树敌，我们尽量不去专门挑其他语言的毛病。为此，我们采用以下不同寻常的定义:

/没有 lisp 宏的语言就是 /Blub/。/

U-language 单词 Blub 来自 Paul Graham 的一篇文章， /Beating the Averages/^{[BEATING-AVGS]}，其中 Blub 是一种假设语言，用来强调 lisp 不同于其他语言：lisp 是不同的。Blub 的特征是有的是中缀语法、有的是烦人的类型系统以及不完善的对象系统，但他们共同的特征是缺少 lisp 宏。Blub 术语对我们很有用，因为有时理解高级宏技术的最简单方法是考虑为什么这种技术在 Blub 中是不可能的。Blub 术语的目的并非是特意取笑非 lisp 语言[fn:5]

ITERATIVE-PROCESS-EXAMPLE

#+BEGIN_EXAMPLE
  (defun example-function% () ; first try
    t)

  (defun example-function%% () ; second try
    t)

  (defun example-function () ; got it!
    t)
#+END_EXAMPLE

为了说明宏创建的迭代过程，本书采用了这样一种约定：在定义不完整或在其他方面有待改进的函数和宏的名称后加上个百分号（%）。在确定没有 % 字符的最终版本之前，多次修订可能导致名称末尾出现多个 % 字符。

宏在 Curry 的术语中被定义为 /元编程/。元程序是一种程序，其唯一目的是使程序员能够更好地编写程序。虽然元编程在所有编程语言中都得到了不同程度的采用，但是没有一种语言像 lisp 那样完全采用它。程序员在其他的语言中不需要以这种方式编写代码来运用元编程技术。这就是为什么 lisp 程序对非 lisp 程序员看起来 /怪异/ 的原因：lisp代码的表达方式是元编程需求的直接结果。正如本书所描述的，lisp 的这种设计——用lisp本身编写元程序——正是lisp所具有的惊人的生产力优势。但是，因为我们使用 lisp 来编写元程序，所以必须记住元编程不同于U语言。我们可以从不同的角度讨论元语言，包括其他元语言，但是只有一种U语言。Curry 也明确表达了他的体系:

/我们可以不断地用任意数量的级别形成语言的层次结构。但是，无论有多少层次，U语言都是最高层次的：如果有两个层次，那就是元语言；如果有三个层次，那就是元-元语言；等等。因此，必须区分U语言和元语言。/

当然，这是一本关于lisp的书，然而 lisp 的逻辑系统与 Curry 所描述的逻辑系统区别很大，因此我们很少采用 Curry 的体系。但直到今天，Curry 对逻辑和元编程的贡献仍然激励着我们。不仅因为他对符号引用的深刻见解，同时也因为他优美的措辞和可行的U语言。

** Lisp 实用程序
    :PROPERTIES:
    :CUSTOM_ID: sec_3
    :END:

/On Lisp/ 是一本你要么懂要么不懂的书。你要么喜欢它，要么讨厌它。从它的标题开始， /On Lisp/ 是关于创建分层的编程抽象。在创建了这些抽象之后，我们可以自由地创建更多的编程抽象，这些抽象是在早期抽象的基础上逐层进行的。

在任意有价值的语言中，语言的大部分功能都是用语言本身实现的；Blub 语言通常有大量用 Blub 编写的标准库。即使是实现者也不希望使用目标语言编程，你可能也一样。

但是，即使与其他语言的标准库相比，lisp 也是不同的。从某种意义上来说，其他语言由原语组成的，而 lisp 由元原语组成。一旦宏被标准化，就像在 COMMON LISP 中一样，语言的其余部分就不必以来其他的原语 /启动/。虽然大多数语言试图提供一组足够灵活的原语，但 lisp 提供了一个元编程系统，随意什么类型的原语都可以。另一种思路是 lisp 完全抛弃了原语的概念。在 lisp 中，元编程系统不会受制于任何所谓的原语。实际上，这些用于构建语言的宏编程技术有可能继续应用到用户程序中。即使是最高级用户编写的应用程序也仍然是 lisp 语言层上的宏层，通过不断迭代增长。

从这个角度来看，语言中存在原语是一个问题。只要有原语存在，系统的设计中就有存在屏障和非正交性。当然，这是并不是没道理的。大多数程序员都可以将单个机器代码指令作为 C 或 lisp 编译器要处理的基本类型。但是 lisp 用户想要控制几乎所有的东西。对于给定给程序员的控件，没有任何语言像 lisp 这样完整。

采纳 /On Lisp/ 的建议，你正在读的书本身就是设计为 onion 上的另一层。同样的，程序是建立在其他程序之上的，而这本书是就是建立在 /On Lisp/ 上。Graham 书的中心主题是：当精心设计的 /实用程序/ 结合在一起时，带来的优势比各个部件加在一起的优势还要大（译注：1 + 1 > 2 的概念）。本节描述所描述的实用程序均来自 /On Lisp/ 和其他的地方。

MKSTR-SYMB

#+BEGIN_EXAMPLE
  (defun mkstr (&rest args)
    (with-output-to-string (s)
      (dolist (a args) (princ a s))))

  (defun symb (&rest args)
    (values (intern (apply #'mkstr args))))
#+END_EXAMPLE

*mkstr* 依赖于一般的创建符号的函数 *Symb* 。由于符号可以被任意字符串引用，并且以编程方式创建符号非常有用，所以 *symb* 是宏编程的一个基本实用程序，同时也在本书中被大量使用。

GROUP

#+BEGIN_EXAMPLE
  (defun group (source n)
    (if (zerop n) (error "zero length"))
    (labels ((rec (source acc)
               (let ((rest (nthcdr n source)))
                 (if (consp rest)
                     (rec rest (cons
                                 (subseq source 0 n)
                                 acc))
                     (nreverse
                       (cons source acc))))))
      (if source (rec source nil) nil)))
#+END_EXAMPLE

*Group* 是另一个在编写宏时常用到的实用程序。其中一部分原因是需要镜像对参数进行分组的操作符，如 COMMON LISP 的 *setf* 和 *psetf* ，另一部分原因是分组通常是构造相关数据的最佳方法。由于我们经常使用这个功能，所以尽可能使抽象一般化是有意义的。Graham 的 *group* 将根据给定的分组数量进行分组，该数量由参数 *n* 指定。在像 *setf* 这样的情况下，参数都是成对的，所以 *n* 就为2。

FLATTEN

#+BEGIN_EXAMPLE
  (defun flatten (x)
    (labels ((rec (x acc)
               (cond ((null x) acc)
                     ((atom x) (cons x acc))
                     (t (rec
                          (car x)
                          (rec (cdr x) acc))))))
      (rec x nil)))
#+END_EXAMPLE

*Flatten* 是 /On Lisp/ 中最重要的实用程序之一。给定一个任意嵌套的列表结构， *flatten* 将返回一个包含通过该列表结构可以访问的所有原子的新列表。如果我们将列表结构看作一棵树， *flatten* 就是返回树中所有叶子的列表。如果那棵树表示 lisp 代码，通过检查表达式中是否存在某些对象， *flatten* 就是某种 /代码的遍历/ 的实现，这是本书中反复出现的主题。

FACT-AND-CHOOSE

#+BEGIN_EXAMPLE
  (defun fact (x)
    (if (= x 0)
      1
      (* x (fact (- x 1)))))

  (defun choose (n r)
    (/ (fact n)
       (fact (- n r))
       (fact r)))
#+END_EXAMPLE

显然， *Fact* 和 *choose* 这两个函数分别实现了阶乘和二项式系数。

** 许可证
    :PROPERTIES:
    :CUSTOM_ID: sec_4
    :END:

由于我认为本书中所介绍的代码背后的概念和物理观察或数学证明一样，即使我想，我也不认为我能拥有它们。因此，你基本上可以任意地修改本文中的代码。以下是和代码一起发布的非常自由的许可证：

#+BEGIN_EXAMPLE
  ;; This is the source code for the book
  ;; _Let_Over_Lambda_ by Doug Hoyte.
  ;; This code is (C) 2002-2008, Doug Hoyte.
  ;;
  ;; You are free to use, modify, and re-distribute
  ;; this code however you want, except that any
  ;; modifications must be clearly indicated before
  ;; re-distribution. There is no warranty,
  ;; expressed nor implied.
  ;;
  ;; Attribution of this code to me, Doug Hoyte, is
  ;; appreciated but not necessary. If you find the
  ;; code useful, or would like documentation,
  ;; please consider buying the book!
#+END_EXAMPLE

本文版权所属 (C) 2008 Doug Hoyte

** 致谢
    :PROPERTIES:
    :CUSTOM_ID: sec_5
    :END:

感谢 Brian Hoyte, Nancy Holmes, Rosalie Holmes, Ian, Alex 以及我的家人; 同时感谢 syke, madness, fyodor, cyb0rg/asm, theclone, blackheart, d00tz, rt, magma, nummish, zhivago, defrost; 谢 Mike Conroy, Sylvia Russell, Alan Paeth, Rob McArthur, Sylvie Desjardins, John McCarthy, Paul Graham, Donald Knuth, Leo Brodie, Bruce Schneier, Richard Stallman, Edi Weitz, Peter Norvig, Peter Seibel, Christian Queinnec, Keith Bostic, John Gamble; 感谢 COMMON LISP 的设计及开发者，尤其是 Guy Steele, Richard Gabriel 和 Kent Pitman 以及 CMUCL/SBCL, CLISP, OpenBSD, GNU/Linux 的开发和维护人员.

特别感谢 Ian Hoyte 设计的封面以及 Leo Brodie 设计的卡通背面。

本书献给所有爱编程的人。

除特别声明外，一切版权均属于 (C) Doug Hoyte

** Footnotes
[fn:1] 由此可以推断，有时要用不理解的东西，惟一的方法就是复制在其他地方看到的格式。
[fn:2] C 程序员之所以会犯这个错误，是因为他们习惯了“宏系统”，而这个“宏系统”对其他方面没什么好处.
[fn:3] 当然，不一定同意。
[fn:4] 这是一个与正文相关但简单地分开地脚注。
[fn:5] 会比价有趣