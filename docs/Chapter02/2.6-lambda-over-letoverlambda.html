<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2.6 Lambda Over Let Over Lambda &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="2.7 Let Over Lambda Over Let Over Lambda" href="2.7-letoverlambda-over-letoverlambda.html" />
    <link rel="prev" title="2.5 Let Over Lambda" href="2.5-let-over-lambda.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第二章：闭包</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="2.1-closure-oriented-programming.html">2.1 面向闭包编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.2-environments-and-extent.html">2.2 Environment and Extent</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.3-lexical-and-dynamic-scope.html">2.3 词法作用域与动态作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.4-let-it-be-lambda.html">2.4 Let It Be Lambda</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.5-let-over-lambda.html">2.5 Let Over Lambda</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.6 Lambda Over Let Over Lambda</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.7-letoverlambda-over-letoverlambda.html">2.7 Let Over Lambda Over Let Over Lambda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第二章：闭包</a> &raquo;</li>
      <li>2.6 Lambda Over Let Over Lambda</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter02/2.6-lambda-over-letoverlambda.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="lambda-over-let-over-lambda">
<h1>2.6 Lambda Over Let Over Lambda<a class="headerlink" href="#lambda-over-let-over-lambda" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>In some object systems there is a sharp distinction between objects, collections of procedures with associated state, and classes, the data structures used to create objects. This distinction doesn’t exist with closures. We saw examples of forms you can evaluate to create closures, most of them following the pattern let over lambda, but how can our program create these objects as needed?</p>
<p>The answer is profoundly simple. If we can evaluate them in the REPL, we can evaluate them inside a function too. What if we create a function whose sole purpose is to evaluate a let over lambda and return the result? Because we use <strong>lambda</strong> to represent functions, it would look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">counter</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="n">incf</span> <span class="n">counter</span><span class="p">))))</span>
</pre></div>
</div>
<p>When the <em>lambda over let over lambda</em> is invoked, a new closure containing a counter binding will be created and returned. Remember that <strong>lambda</strong> expressions are constants: mere pointers to machine code. This expression is a simple bit of code that creates new environments to close over the inner <strong>lambda</strong> expression (which is itself a constant, compiled form), just as we were doing at the REPL.</p>
<p>With object systems, a piece of code that creates objects is called a class. But lambda over let over lambda is subtly different than the classes of many languages. While most languages require classes to be named, this pattern avoids naming altogether. Lambda over let over lambda forms can be called <em>anonymous classes</em>.</p>
<p>Although anonymous classes are often useful, we usually do name classes. The easiest way to give them names is to recognise that such classes are regular functions. How do we normally name functions? With the <strong>defun</strong> form, of course. After naming, the above anonymous class becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defun counter-class ()
  (let ((counter 0))
    (lambda () (incf counter))))
</pre></div>
</div>
<p>Where did the first <strong>lambda</strong> go? <strong>Defun</strong> supplies an <em>implicit lambda</em> around the forms in its body. When you write regular functions with <strong>defun</strong> they are still lambda forms underneath but this fact is hidden beneath the surface of the <strong>defun</strong> syntax.</p>
<p>Unfortunately, most lisp programming books don’t provide realistic examples of closure usage, leaving readers with the inaccurate impression that closures are only good for toy examples like counters. Nothing could be further from the truth. Closures are the building blocks of lisp. Environments, the functions defined inside those environments, and macros like <strong>defun</strong> that make using them convenient, are all that are needed for modelling any problem. This book aims to stop beginning lisp programmers used to object-based languages from acting upon their gut instinct of reaching for systems like CLOS. While CLOS does have certain things to offer the professional lisp programmer, do not use it when a lambda will suffice.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">block</span><span class="o">-</span><span class="n">scanner</span> <span class="p">(</span><span class="n">trigger</span><span class="o">-</span><span class="n">string</span><span class="p">)</span>
  <span class="p">(</span><span class="n">let</span><span class="o">*</span> <span class="p">((</span><span class="n">trig</span> <span class="p">(</span><span class="n">coerce</span> <span class="n">trigger</span><span class="o">-</span><span class="n">string</span> <span class="s1">&#39;list))</span>
         <span class="p">(</span><span class="n">curr</span> <span class="n">trig</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">string</span><span class="p">)</span>
      <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">data</span> <span class="p">(</span><span class="n">coerce</span> <span class="n">data</span><span class="o">-</span><span class="n">string</span> <span class="s1">&#39;list)))</span>
        <span class="p">(</span><span class="n">dolist</span> <span class="p">(</span><span class="n">c</span> <span class="n">data</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if</span> <span class="n">curr</span>
            <span class="p">(</span><span class="n">setq</span> <span class="n">curr</span>
                  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">char</span><span class="o">=</span> <span class="p">(</span><span class="n">car</span> <span class="n">curr</span><span class="p">)</span> <span class="n">c</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">cdr</span> <span class="n">curr</span><span class="p">)</span> <span class="p">;</span> <span class="nb">next</span> <span class="n">char</span>
                    <span class="n">trig</span><span class="p">))))</span>   <span class="p">;</span> <span class="n">start</span> <span class="n">over</span>
        <span class="p">(</span><span class="ow">not</span> <span class="n">curr</span><span class="p">)))))</span> <span class="p">;</span> <span class="k">return</span> <span class="n">t</span> <span class="k">if</span> <span class="n">found</span>
</pre></div>
</div>
<p>In order to motivate the use of closures, a realistic example is presented: <strong>block-scanner</strong>. The problem <strong>block-scanner</strong> solves is that for some forms of data transfer the data is delivered in groups (blocks) of uncertain sizes. These sizes are generally convenient for the underlying system but not for the application programmer, often being determined by things like operating system buffers, hard drive blocks, or network packets. Scanning a stream of data for a specific sequence requires more than just scanning each block as it comes in with a regular, stateless procedure. We need to keep state between the scanning of each block because it is possible that the sequence we are scanning for will be split between two (or more) blocks.</p>
<p>The most straightforward, natural way to implement this stored state in modern languages is with a closure. An initial sketch of a closure-based block scanner is given as <strong>block-scanner</strong>. Like all lisp development, creating closures is an iterative process. We might start off with code given in <strong>block-scanner</strong> and decide to improve its efficiency by avoiding coercion of strings to lists, or possibly improve the information gathered by counting the number of occurrences of the sequence.</p>
<p>Although <strong>block-scanner</strong> is an initial implementation waiting to be improved, it is still a good demonstration of the use of lambda over let over lambda. Here is a demonstration of its use, pretending to be some sort of communications tap watching out for a specific black-listed word, <em>jihad</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">defvar</span> <span class="n">scanner</span>
    <span class="p">(</span><span class="n">block</span><span class="o">-</span><span class="n">scanner</span> <span class="s2">&quot;jihad&quot;</span><span class="p">))</span>

<span class="n">SCANNER</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="n">scanner</span> <span class="s2">&quot;We will start &quot;</span><span class="p">)</span>

<span class="n">NIL</span>
<span class="c1"># (funcall scanner &quot;the ji&quot;)</span>

<span class="n">NIL</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="n">scanner</span> <span class="s2">&quot;had tomorrow.&quot;</span><span class="p">)</span>

<span class="n">T</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="2.5-let-over-lambda.html" class="btn btn-neutral float-left" title="2.5 Let Over Lambda" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="2.7-letoverlambda-over-letoverlambda.html" class="btn btn-neutral float-right" title="2.7 Let Over Lambda Over Let Over Lambda" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>