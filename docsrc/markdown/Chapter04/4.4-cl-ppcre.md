# 4.4 CL-PPCRE

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

CL-PPCRE[CL-PPCRE]是一个基于COMMON LISP编写的高性能正则表达式库。 是由备受尊崇的 lisp 黑客 Edi Weitz 创建的。 替所有从 CL-PPCRE 和 Edi Weitz 的其他软件中受益匪浅的 lisp 专业人士，本节献给 Edi Weitz。 当其他人在争论时，Edi 在编码； 代码比争论更有说服力。

PPCRE，对于那些还不熟悉的人来说，全称是 Portable Perl Compatible Regular Expressions。 CL-PPCRE 与本书中的代码一样，是可移植的，因为它可以在任何符合 ANSI 的 COMMON LISP 环境中运行。 CL-PPCRE 和本书中的代码一样，是开源的并且免费提供。 尽管 CL-PPCRE 与 Perl 几乎完美兼容，但它在一些重要方面与 Perl 不同。 CL-PPCRE 为正则表达式提供了几个值得注意的 lispy 增强。 CL-PPCRE 与 Perl 中正则表达式的实现有三种实质性的不同。

首先，CL-PPCRE 速度很快。 真的很快。 当使用正常的本机代码编译器进行编译时，基准测试表明对于大多数正则表达式，CL-PPCRE 的速度大约是 Perl 的两倍，通常要快得多。 然而 Perl 拥有最快的非 lisp 正则表达式引擎之一：一个用 C 编写的高度优化的引擎。这怎么可能？ Perl 的底层实现肯定比用 lisp 等高级语言编写的任何东西都具有性能优势。

这种误解被称为性能神话，一般版本如下：低级语言导致代码更快，因为可以更接近硬件进行编程。 正如本书希望解释的那样，对于复杂的系统，这个神话是错误的。 像 CL-PPCRE 这样的例子就证明了这一点。 语言越低级，就越会阻止程序员和其编译器进行真正重要的效率优化。

使用 CL-PPCRE，性能提升的技术原因很简单：用于实现 CL-PPCRE 的语言 COMMON LISP 比用于实现 Perl 的语言 C 更强大。当 Perl 读入正则表达式时，它可以执行分析和优化，但最终正则表达式将存储到某种 C 数据结构中，供静态正则表达式引擎在尝试匹配时使用。但是在强大的语言 COMMON LISP 中，将这个正则表达式转换成一个 lisp 程序，然后将该 lisp 程序传递给优化的、原生代码的 lisp 编译器，用于构建余下的 lisp 系统[7](https://letoverlambda.com/index.cl/guest/chap4.html#)部分，基本上不再困难。 因为用 C 编译器编译的程序无法访问 C 编译器，所以 Perl 无法将正则表达式一直编译为机器代码。 Lisp 的编译模型与 C 完全不同。在 COMMON LISP 中，在运行时（在任何时候）编译东西是可移植的、无缝的、在与 lisp 镜像相同的过程中完成、在不再需要时收集垃圾，并且由于其增量性质，效率很高。

CL-PPCRE 和 Perl 之间的第二个主要区别是 CL-PPCRE 不依赖于正则表达式的基于字符串的表示法。 CL-PPCRE 已从字符表示中解放出来，并允许我们将正则表达式编码为 lisp 表达式（有时称为 S 表达式）。 由于这些表达式正是用来编写 lisp 程序和宏的符号，因此我们在抽象中获得了更多凝聚力的机会。 请参阅 CL-PPCRE[CL-PPCRE] 的文档和代码以获取有关使用此正则表达式表示法的详细信息，以及精心设计的 lispy 域特定语言的示例。

当然，CL-PPCRE 很棒，但为什么要在关于读取宏的章节中讨论它呢？ 答案是 CL-PPCRE 与 Perl 第三个不同点，也是最后一个不同点。 在 Perl 中，正则表达式与语言密切相关。 虽然 lisp 的语法是适应元编程的方式，但 Perl 的语法是适应正则表达式和其他类型的语法快捷方式的方式。 在 Perl 代码中频繁地使用正则表达式的部分原因是因为编写它们的体验很简短和轻松。

要以 Perlish 风格添加方便的程序员的接口，读取宏就会很方便。 因为编写读取宏就是编写 lisp，所以从一个实用函数开始：**segment-reader**。 给定一个流、一个分隔符和一个计数，**segment-reader** 将从流中读取字符，直到遇到分隔符。 如果计数大于 1，**segment-reader** 将返回一个 cons。 这个 cons 的 car 是个字符串，而 cdr 是在给定递减小计数参数的情况下递归调用 **segment-reader** 的结果，以获取下一个字符片段[8](https://letoverlambda.com/index.cl/guest/chap4.html#).
```
(defun segment-reader (stream ch n)
  (if (> n 0)
    (let ((chars))
      (do ((curr (read-char stream)
                 (read-char stream)))
          ((char= ch curr))
        (push curr chars))
      (cons (coerce (nreverse chars) 'string)
            (segment-reader stream ch (- n 1))))))
```
例如，从流 **t**[9](https://letoverlambda.com/index.cl/guest/chap4.html#) 中读取带有 **/** 分隔符的 3 个字符段，如下所示：
```
* (segment-reader t #\/ 3)
abc/def/ghi/

("abc" "def" "ghi")
```
Perl 程序员可能会知道这到底是怎么回事。 向拉里沃尔完全道歉，这个想法盗用两个方便的 Perl 正则表达式运算符的语法。 在 Perl 中，如果要将正则表达式与变量匹配，可以这样写
```
$my_boolean = ($var =~ m/^\w+/);
```
上面代码是检查 **$var** 的内容是否以一个或多个字母数字字符开头。 类似地，如果要用替换正则表达式，也可以使用 Perl **=~** 运算符将替换正则表达式用在字符串变量 **$var** 上，以下代码是将第一次在 **$var**中出现的 **dog** 替换为 **cat**：
```
$var =~ s/dog/cat/;
```
Perl 语法的伟大之处在于分隔符可以是任何方便使用的字符。 如果想使用正则表达式或包含 / 字符的替换，我们可以使用不同的字符来避免冲突[10](https://letoverlambda.com/index.cl/guest/chap4.html#)：
```
$var =~ s|/usr/bin/rsh|/usr/bin/ssh|;
```
```
#+cl-ppcre
(defmacro! match-mode-ppcre-lambda-form (o!args)
 ``(lambda (,',g!str)
     (cl-ppcre:scan
       ,(car ,g!args)
       ,',g!str)))

#+cl-ppcre
(defmacro! subst-mode-ppcre-lambda-form (o!args)
 ``(lambda (,',g!str)
     (cl-ppcre:regex-replace-all
       ,(car ,g!args)
       ,',g!str
       ,(cadr ,g!args))))
```
定义一个读取宏来复制这两种 Perl 语法，就有机会展示一种有趣的宏技术，即双反引号。 这个想法是，有时，就像在 **match-mode-ppcre-lambda-form** 和 **subst-mode-ppcre-lambda-form** 宏中一样，我们想要编写生成列表的代码。 注意，通常在定义宏并使用单个反引号时，正在生成一个表示代码的列表并将其从宏中返回，以便将其拼接到表达式中进行执行。 使用双反引号，仍然会生成一个表示代码的列表，但此代码在执行时将使用反引号构建的代码以返回一个列表。 在我们的例子中，这两个宏展开为代码，可以用这些代码来创建对应用 CL-PPCRE 正则表达式有帮助的 lambda 结构。

我们在这些宏和下面的一些其他表达式前面加上 **#+** 读取宏。 在执行以下代码之前，此读取宏会测试是否有可用的 CL-PPCRE[11](https://letoverlambda.com/index.cl/guest/chap4.html#)。 如果从本书加载源代码时 CL-PPCRE 不可用，则本节的功能将不可用。
```
#+cl-ppcre
(defun |#~-reader| (stream sub-char numarg)
  (declare (ignore sub-char numarg))
  (let ((mode-char (read-char stream)))
    (cond
      ((char= mode-char #\m)
         (match-mode-ppcre-lambda-form
           (segment-reader stream
                           (read-char stream)
                           1)))
      ((char= mode-char #\s)
         (subst-mode-ppcre-lambda-form
           (segment-reader stream
                           (read-char stream)
                           2)))
      (t (error "Unknown #~~ mode character")))))

#+cl-ppcre
(set-dispatch-macro-character #\# #\~ #'|#~-reader|)
```
最后，可以定义一个读取器函数来将这些实用程序组合在一起，然后将此函数添加到宏调度表中。 选择用 **#~** 读取宏是因为它很好地模拟了Perl 的 **=~**，这是语法灵感的来源。

**#~** 读取宏旨在方便。 以下是如何创建正则表达式匹配函数：
```
* #~m/abc/

#<Interpreted Function>
```
现在可以像调用普通函数一样将此函数应用于字符串[12](https://letoverlambda.com/index.cl/guest/chap4.html#)：
```
* (funcall * "123abc")

3
6
#()
#()
```
返回的值来自 **cl-ppcre:scan** 函数，其文档可在 [CL-PPCRE] 中找到。 如果只对字符串是否匹配感兴趣，则返回的第一个值不是 nil 的结果则表明匹配成功。 广义布尔值，以及为什么它们是 COMMON LISP 的一个重要特性，将在[第 6 章：回指宏中进一步讨论](../Chapter06/index.rst)。

我们还可以创建替换正则表达式函数。 Perl 和 read 宏之间的细微差别是替换正则表达式函数不会修改参数。 它们将返回新字符串，这些字符串是原始字符串的副本，并进行了替换。 另一个区别是，默认情况下，这个 read 宏会替换所有匹配的模式，而不仅仅是第一个匹配的字符串。 在 Perl 中，需要在正则表达式中添加一个全局修饰符来获得这种行为，但这里不是：
```
* (funcall #~s/abc/def/ "Testing abc testing abc")

"Testing def testing def"
```
那么这是如何工作的呢？ **#~** 表达式（显然不是 lisp 表达式）读入是什么？ 表面上看，似乎是作为函数读入的，但实际并非如此。 让我们引用其中一种结构，以便可以根据 lisp 读取器来看看是什么：
```
* '#~m|\w+tp://|

(LAMBDA (#:STR1)
  (CL-PPCRE:SCAN "\\w+tp://" #:STR1))
```
替换也类似：
```
* '#~s/abc/def/

(LAMBDA (#:STR2)
  (CL-PPCRE:REGEX-REPLACE-ALL
    "abc"
    #:STR2
    "def"))
```
它们以 lambda 结构读入。 所以就 lisp 读取器而言，我们毕竟不是用一些有趣的非 lisp 语言编写的。 这是一个函数指示符。 由于表达式只是个列表，该列表的第一个符号是 lambda，回想以下 2.4 节：Let It Be Lambda 中如何在函数调用的第一个参数中使用 lambda 结构来调用匿名函数：
```
* (if (#~m/^[\w-.]+$/ "hcsw.org")
    'kinda-looks-like-a-domain
    'no-chance!)

KINDA-LOOKS-LIKE-A-DOMAIN
```
当使用 **funcall** 或 **apply** 来调用由 **#~** 读入的对象时，就用了 ANSI **lambda** 宏，但当表达式为第一个参数时则不使用：这是一种有用的二义性语法。 如果 **#~** 表达式读入为井引号的 lambda 表达式，将无法在表达式的函数位置使用它们——只有函数名和 lambda 表达式可以到那里。 所以对于这两个任务，只需要一个读取宏，这是幸运的，因为它是一个庞大而复杂的宏。 利用二义性语法让我们专注于得到正确的展开，而不是跟踪不同的语法要求。 我们得到了两个，而不是一个有趣的宏。 为了节省精力，尽可能保持语法一致。

使用 CL-PPCRE 时的一个常见问题是忘记在正则表达式中转义反斜杠。 看看这样做时会发生什么：
```
* "\w+"

"w+"
```
这是一个长度为 2 的字符串。反斜杠去哪儿了？ 双引号认为我们的意思是转义 **w** 字符而不是写一个文字 `\` 字符。 对于 **#~** 读取宏，只读取字符并查找适当的分隔符，这不是问题，可以像在 Perl 中一样编写正则表达式——无需转义。 请参阅上面 URL 正则表达式的引用。

虽然本节定义的 **#~** 读取宏已经很方便了，但仍有改进和增强的空间。 练习：改进它。 第一步明显就是支持正则表达式修饰符，例如匹配中不区分大小写。 如果使用与 Perl 相同的语法完成，这会用到函数 **unread-char**，这在读取宏中很常见，以避免意外吞掉其他读取宏可能期望的字符。
