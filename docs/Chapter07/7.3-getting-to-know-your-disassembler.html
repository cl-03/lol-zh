<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7.3 了解反汇编 &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="7.4 指针作用域" href="7.4-pointer-scope.html" />
    <link rel="prev" title="7.2 Macros Make Lisp Fast" href="7.2-macros-make-lisp-fast.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第七章：宏的效率</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="7.1-lisp-is-fast.html">7.1 Lisp Is Fast</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.2-macros-make-lisp-fast.html">7.2 Macros Make Lisp Fast</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">7.3 了解反汇编</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.4-pointer-scope.html">7.4 指针作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.5-tlists-and-cons-pools.html">7.5 Tlist 和 cons 池</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.6-sorting-networks.html">7.6 排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.7-writing-and-benchmarking-compilers.html">7.7 编写基准测试</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 的变迁</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第七章：宏的效率</a> &raquo;</li>
      <li>7.3 了解反汇编</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter07/7.3-getting-to-know-your-disassembler.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>7.3 了解反汇编<a class="headerlink" href="#id1" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>如果不检查处理器为不同的 lisp 结构执行的原始指令，就很难真正了解在 lisp 中那些代码
的开销昂贵。就像在编写宏时，查看它们的展开通常很有帮助，有时查看lisp 程序编译后
的展开（通常是汇编指令）也很有用。因为 lisp 编译器可以并且经常被认为是宏扩展器，
它们生成的机器码，从某种奇怪的意义上说，本身就是 lisp 代码。因为 lisp 与其说是一
种语言，不如说是一种创建语言的构建材料和结构，lisp 是用来定义和编译一种恰好与
处理器指令集相同的语言。</p>
<p>COMMON LISP 提供了一个名为 <code class="docutils literal notranslate"><span class="pre">disassemble</span></code> 的函数来查看已编译的展开。
<code class="docutils literal notranslate"><span class="pre">disassemble</span></code> 类似于 <a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.9152">USEFUL-LISP-ALGOS2</a> 中描述的CMUCL宏扩展
<code class="docutils literal notranslate"><span class="pre">macroexpand-all</span></code> 。给 <code class="docutils literal notranslate"><span class="pre">disassembler</span></code> 函数或存在的 <code class="docutils literal notranslate"><span class="pre">symbol-function</span></code>
绑定，我们可以查看在调用函数时要执行的原始机器码指令。</p>
<p>问题是这些原始的机器代码指令看起来一点也不像 lisp。这些指令对于某些非常随意
的机器来说，通常是奇怪的、微小的步骤，而不是 lisp 舒服的嵌套括号。查看编译后
的 lisp 代码展开就像用放大镜阅读海报一样。可以看到喜欢的任何部分的细节，但
仅凭这一点来解释整体情况是困难的，甚至是不可能的。更糟糕的是，当查看这种
细节级别的代码时，有时不可能查看任何一段机器码并确定编译器为什么把它放在
那里。</p>
<p>不幸的是，没人知道超过 <code class="docutils literal notranslate"><span class="pre">compile</span></code> 函数的 lisp 的最好实现。毫无疑问，有很多宏
展开来完整这个代码，其中一些是板上钉钉的事，因此它可能可以标准化，但最好的
使用硬件资源（如 CPU 周期和内存）的方法仍然是（可能一直都是）个非常热门的
研究课题。比编译器设计的改进更难跟踪的是硬件的不断改进。最初有意义的优化可
能变得不相关甚至完全不正确。我们不需要找太多的例子来说明不断变化的世界是如
何影响效率假设的。</p>
<p>科学家们过去避免在需要良好表现的代码中使用浮点计算，而是选择基于机器字的定点
计算。这是因为计算机没有专门的浮点硬件，所以被迫使用处理器的整数指令来模拟它。
因为处理器并没有为此进行真正的优化，浮点运算总是比定点运算慢得多。然而，随着
时间的推移，硬件开始出现专门的浮点协同处理器，这些处理器被设计来以光速般的
速度执行这些浮点运算。几乎在一夜之间，科学家们从假设固定点运算总是比浮点运算
快得多，到不得不在做出决定之前对他们的硬件进行调查和基准测试。硬件的发展改变
了浮点数的性能现实。不久之后，计算机开始配备 2 个、4 个或更多的浮点协同处理器，
科学家们发现，如果他们能够让浮点指令的流水线充满，浮点运算通常可以比定点运算
表现得更好。许多出于性能原因而选择固定点的程序 —— 在大约 10 年的时间框架内
—— 从选择正确的实现到选择错误的实现。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro dis (args &amp;rest body)
  `(disassemble
     (compile nil
       (lambda ,(mapcar (lambda (a)
                          (if (consp a)
                            (cadr a)
                            a))
                        args)
          (declare
            ,@(mapcar
                #`(type ,(car a1) ,(cadr a1))
                (remove-if-not #&#39;consp args)))
          ,@body))))
</pre></div>
</div>
<p>在开发宏时，同样有用的是看 <code class="docutils literal notranslate"><span class="pre">macroexpand</span></code> 和 <code class="docutils literal notranslate"><span class="pre">macroexpand-all</span></code> 的输出，这有
助于查看 <code class="docutils literal notranslate"><span class="pre">disassembler</span></code> 的输出，不仅了解实现功能，而且确保给 lisp 所需的所有
信息来生成有效的展开。 <code class="docutils literal notranslate"><span class="pre">dis</span></code> 是个令在反汇编输出中检查部分 lisp 代码变得很容易的
宏。它的第一个参数是一个符号列表或一个类型和符号列表。想知道 <code class="docutils literal notranslate"><span class="pre">dis</span></code> 是怎么工作
的，直接展开。这里是 <code class="docutils literal notranslate"><span class="pre">dis</span></code> 展开为一个简单的二进制加法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(dis (a b) (+ a b)))</span>
<span class="p">(</span><span class="n">DISASSEMBLE</span>
  <span class="p">(</span><span class="n">COMPILE</span> <span class="n">NIL</span>
    <span class="p">(</span><span class="n">LAMBDA</span> <span class="p">(</span><span class="n">A</span> <span class="n">B</span><span class="p">)</span>
      <span class="p">(</span><span class="n">DECLARE</span><span class="p">)</span>
      <span class="p">(</span><span class="o">+</span> <span class="n">A</span> <span class="n">B</span><span class="p">))))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>为什么其中会有个空的 <code class="docutils literal notranslate"><span class="pre">declare</span></code> 结构呢？它是一个占位符，<code class="docutils literal notranslate"><span class="pre">dis</span></code> 可以插入类型声明，
当像下面那样在参数中指定它们:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
    <span class="s1">&#39;(dis ((fixnum a) (integer b))</span>
<span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span><span class="p">)))</span>
<span class="p">(</span><span class="n">DISASSEMBLE</span>
  <span class="p">(</span><span class="n">COMPILE</span> <span class="n">NIL</span>
    <span class="p">(</span><span class="n">LAMBDA</span> <span class="p">(</span><span class="n">A</span> <span class="n">B</span><span class="p">)</span>
      <span class="p">(</span><span class="n">DECLARE</span> <span class="p">(</span><span class="n">TYPE</span> <span class="n">FIXNUM</span> <span class="n">A</span><span class="p">)</span>
              <span class="p">(</span><span class="n">TYPE</span> <span class="n">INTEGER</span> <span class="n">B</span><span class="p">))</span>
      <span class="p">(</span><span class="o">+</span> <span class="n">A</span> <span class="n">B</span><span class="p">))))</span>
<span class="n">T</span>
</pre></div>
</div>
<p>因为 <code class="docutils literal notranslate"><span class="pre">dis</span></code> 展开成一个（封装的）lambda 结构，所以它的工作方式与 lambda 非常相似。
只要你想的话，可以添加额外的声明，并且返回值很重要（因为 lambda 结构提供了一个
隐式的 progn）。加载了本书的代码后，试着在你的 lisp 环境中输入下面的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dis</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span>

</pre></div>
</div>
<p>机器码应该相当短，但这是因为调用了一个预编译函数 —— 这个函数足够的智能来提供
所有花哨的 lisp 数字特性，如类型感染、有理数简化等，从而隐藏了大部分的复杂性。
这被称为 <em>间接（ indirection ）</em> ，在反汇编器的输出中可能相当明显:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="c1">#x1000148 ; GENERIC-+</span>
</pre></div>
</div>
<p>用三个参数试试看：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dis</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>练习：通用加法函数有多少层间接呢？ <code class="docutils literal notranslate"><span class="pre">(&lt;=</span> <span class="pre">0</span> <span class="pre">N)</span></code> 中的参数 N 又有多少层呢?</p>
<p>现在尝试锁定其中一个变量的类型。将其与前面没有声明类型的示例进行比较：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dis</span> <span class="p">((</span><span class="n">fixnum</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>某些 <code class="docutils literal notranslate"><span class="pre">OBJECT-NOT-FIXNUM-ERROR</span></code> 现在应该很明显了。Lisp 编译了一些
额外的代码来做这种类型检查，同时间接控制泛型的加法函数，因为 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的
类型在编译时是未知的，因此可能需要 lisp 的所有花哨的数值行为，比如
感染。</p>
<p>这不是获得高效代码的方法。事实上，这段代码的效率甚至可能比前一段
代码略低。为了编写高效代码，需要用到一个称为 <em>内联（ inlining ）</em> 的
进程。对于一些特殊的操作，当有足够的类型信息时，lisp 编译器知道如何
避免间接或直接向正在编译的函数中添加机器代码来执行所需的操作。
下面的通用加法函数中不应该有间接：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dis</span> <span class="p">((</span><span class="n">fixnum</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">fixnum</span> <span class="n">b</span><span class="p">))</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>这种内联过程可能会导致比使用间接方法的机器代码更多的机器代码。
这是因为泛型加法函数中实现的一些（但不是全部）功能被复制到了
编译的函数中。虽然看起来更长，但在某些情况下，由于更少的间接，
该代码将执行效率更高。</p>
<p>但是这种混乱的机器码仍比 C 实现的效率低得多。在编译还是有各种
参数计数、类型和溢出检查，以至于与开销相比，这么多的额外开销
比实际添加的成本仍要低。如果在循环中使用这个函数，这种开销可能
就不能接受了。</p>
<p>对于像 C 这样的语言，可以在任何地方指定类型，而在任何地方都不
强制执行安全性，所以代码总是高效的，但也不安全，编写起来总是
很麻烦。在大多数动态 Blub 语言中，不需要指定类型，并在任何地方
都强制执行安全性，因此代码总是安全的，不烦人，但也不会高效。
对于大多数强大的静态 Blub 语言，可以在任何地方指定类型，并在
任何地方强制执行安全性，因此代码总是高效和安全的，但很烦人。
Lisp 给了你选择。因为 lisp 默认为安全模式，lisp 程序通常看起来比
C 程序慢一些，但几乎总是更安全。因为 lisp 为程序员提供了一个优秀
的类型声明系统和实现，并且有很优秀的编译器，所以 lisp 程序几乎总
是和动态 Blub 程序一样安全，而且通常要快得多。最重要的是，lisp
有宏，所以如果有什么烦人的东西，好吧，改变它！</p>
<p>让我们继续，并让 lisp 让我们的加法更高效。回想一下， <code class="docutils literal notranslate"><span class="pre">#f</span></code> 是高速、
低安全声明读宏的缩写。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dis</span> <span class="p">((</span><span class="n">fixnum</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">fixnum</span> <span class="n">b</span><span class="p">))</span>
  <span class="c1">#f</span>
  <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>这次机器指令码应该比之前的短一点。类型检查和参数计数检查应该删除了。
但这仍然不是我们想要的单一指令、混乱、危险的 fixnum 加法。为了深入
了解正在发生的事情，我们应该检查编译器注释。注释是编译器所做的观察，
它本质上是说：“你看起来像是在尝试做一些高效的事情，而且你已经快完
成了，但我需要澄清一下你的意图。这里有个小窍门让你更清楚……”</p>
<p>编译注释是无价的信息来源。当试图创建高效的 lisp 代码时，应该仔细阅读
并考虑它们。Lisp 编译器使用类型推断系统来发现代码的复杂属性，即使是
程序员也可能没有考虑到这些属性。在上面的例子中，编译器应该会给我们
这样的提示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="n">Note</span><span class="p">:</span> <span class="n">Doing</span> <span class="n">signed</span> <span class="n">word</span> <span class="n">to</span> <span class="n">integer</span> <span class="n">coercion</span>
<span class="p">;</span>       <span class="p">(</span><span class="n">cost</span> <span class="mi">20</span><span class="p">)</span> <span class="n">to</span> <span class="s2">&quot;&lt;return value&gt;&quot;</span><span class="o">.</span>

</pre></div>
</div>
<p>Lisp 不会做任何愚蠢的事情，比如忽略 fixnum 溢出，除非明确要求它这样做。
因此，为了让 lisp 不小心给出了个可能不是很安全的函数，我们需要避免带符号
的单词 （fixnum）到整数 （bignum）的检查和强制。我们需要告诉 lisp，
溢出是可以接受的，是的，我们真的想安静地返回一个 fixnum：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dis</span> <span class="p">((</span><span class="n">fixnum</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">fixnum</span> <span class="n">b</span><span class="p">))</span>
  <span class="c1">#f</span>
  <span class="p">(</span><span class="n">the</span> <span class="n">fixnum</span> <span class="p">(</span><span class="o">+</span> <span class="n">a</span> <span class="n">b</span><span class="p">)))</span>
</pre></div>
</div>
<p>现在已经燃起来了。这大致相当于一个 C 的 fixnum 加法函数：一些机器指令
将两个寄存器相加，然后将控制权返回给调用者。虽然反汇编程序可以为 lisp
效率的所有领域提供许多见解，但它会教你两项主要的技能。第一个技巧在
本节中主要介绍：如何使用声明来获得有效的数值行为，特别是在循环内部。
第二个问题是如何有效地使用数组/向量数据结构。这将在 <a class="reference internal" href="7.4-pointer-scope.html"><span class="doc std std-doc">7.4 指针作用域</span></a>
中讨论。</p>
<p>就像技术进步将浮点运算的效率现实从应该避免的东西变成了应该利用的
东西一样，lisp 编译器技术的进步 —— 结合 COMMON LISP 的正确类型
和安全声明系统 —— 正在改变我们对效率的看法。有了这些工具，以及软件
系统日益增长的复杂性需求，问题就从如何使 lisp 像低级语言一样高效变成
了如何使其他语言像 lisp 一样高效。当然，答案是在 lisp 中用宏实现它们。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="7.2-macros-make-lisp-fast.html" class="btn btn-neutral float-left" title="7.2 Macros Make Lisp Fast" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="7.4-pointer-scope.html" class="btn btn-neutral float-right" title="7.4 指针作用域" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>