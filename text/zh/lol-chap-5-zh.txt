五章项目的程序
5.1 Lisp不是功能
最常见的一种定性错误的lisp函数式编程语言。Lisp不是功能。事实上它可以辩称,lisp是有史以来最少的函数式语言。这种误解有趣的根,是一个很好的例子,一个小用词不当会产生长期的影响,最终导致混乱背后的原因误称过去很长时间之后变成无关紧要。函数式语言是什么?唯一的定义是有意义的
函数式语言是一种编程语言的功能。
一个函数是什么?函数是数学的概念,和我们几个世纪以来:
一个函数是一个静态的、定义良好的映射输入值和输出值。
好像我们用lisp defun定义新的函数。例如,下面是一个函数,使用求和所有数字的集合映射到一组新的,还包括所有的数字:(defun加法器(x) (1 + x))
显然我们可以应用这个对象任意数量和映射结果的返回值,但是加法器是一个函数呢?令人困惑的是,lisp告诉我们,它是!
*�(描述# ?加法器)# <解释函数>是一个函数。
但调用这个对象的函数是一个lisp deepest-rooted名不副实的历史。defun和λ形式创建程序或者,更准确的是,funcallable实例[埃莫)。为什么的区别?程序不?t一定与映射值,而是部分代码,可能与存储环境,可以执行(funcalled)。当lisp程序员写在某种风格叫做功能风格,然后生成的程序可以被认为和组合在一起假装math-style功能性映射。
lisp的原因是经常错误地描述为一个函数式语言与历史。信不信由你,但当大多数语言都曾经是一个时间吗?t甚至支持过程的概念,现代程序员在任何语言理所当然。没有早期语言?t为本地提供合适的抽象命名参数的可重用的代码,程序员不得不手动分配寄存器和操作栈来实现这一行为。Lisp语言,程序,似乎比这些语言功能。
接下来,一旦程序抽象得到应得的重视和纳入几乎所有编程语言中,人们开始慢慢的由于遇到障碍
Tf你?t已经见过ComMON Lisp描述函数,现在就试试吧。描述一个函数,一种特殊形式,宏观,一个变量,一个象征,一个闭包。他们已经实现了有限的自然过程。程序员开始意识到,他们希望能够返回程序与其他程序,将它们嵌入在新环境中,他们总在数据结构,而且,一般来说,对待他们一样老常规值。一个口号涌现的推动下一个抽象动员程序员:一个社会没有阶级,一流的程序。相比语言降级程序劣质二等,lisp,一种语言,有这些一流的过程,似乎更多的功能。
最后,许多语言使一个毫无意义的区分表达式和语句,通常支持一些可怕的哭像中缀赋值语法。在lisp,一切都回报什么吗?也没有(语法)限制您可以嵌套或结合。它与一个显而易见的答案是:一个简单的问题在一种语言,更重要的是newbie-friendly语法或真正的灵活性?任何语言使用中缀语法在很多方面降低其抽象的可能性。幸运的是大多数现代编程语言决定信任用户足以让他们把表情大多在他们认为合适的地方。相比这些脑死亡的语法做决定的语言,lisp似乎更多的功能。
后适应这无处不在的但却被引入歧途的术语,程序员开始意识到函数的概念,已经使用的功能性和非功能性编程语言辩论不仅令人困惑,但实际上从根本上向后。要修正这个问题,程序员和学者都回到绘图板,返回一个函数的数学定义:从输入值映射到输出值。如果以任何方式lisp是一种函数式语言,它只是尽可能多的现代语言如Perl和Javascript。
显然lisp程序不是函数。Lisp程序可以返回非静态值,你可以叫他们多次使用相同的参数和接收不同的返回值
?除了(值),返回什么。但即使这是强迫为零,所以可以用在表达式。
时间。从先前的章节在我们的例子中,lisp程序可以存储状态通过关闭/变量。程序就像rplaca可以改变值在内存中或其他地方(如寄存器)。Lisp程序terpri和格式创建输出terpri(换行)指向终端或文件?。Lisp程序像yes-or-no-p可以从终端读取输入和返回值取决于用户输入。这些程序是静态的、定义良好的映射?
因为lisp程序不是数学函数,lisp函数式语言。事实上,一个有力的论点可以lisp函数比其他语言更少。在大多数语言中,表情看起来像过程调用执行的过程调用语法的语言。在lisp,我们宏。当我们吗?已经看到,宏可以在不知不觉中改变某些形式的意义从函数调用到任意lisp表达式,这一技术能够违反参照透明度在许多方面,简单不?可能在其他语言。
后考虑到大多数语言事实上没有功能,一些语言设计者决定找出一个函数式语言编程。如你所愿,编程函数式语言主要是恼人的和不切实际的。几乎没有实际问题可以有效地表示为静态的,明确的映射输入值和输出值。也就是说,函数式编程并非没有道理,许多语言设计利用函数式的编程风格。这就意味着找到一个方便的方式的隔离程序的功能部分(实际上是有趣的)非功能部分。语言,像Haskell和Ocaml使用这种隔离做出积极优化假设的一种手段。
但这是lisp。我们吗?非功能性,非常自豪。在某种程度上,这种隔离的副作用是有用的,用宏lisp程序员可以实现它。函数式编程背后的真正目的是分离的
3 terpri rplaca ?都有合理worst-named COMMON LISP操作符的区别。
功能描述的应该发生什么它如何发生的机制。Lisp绝对不是功能,但因为宏,没有更好的平台或材料实现比Lisp函数式语言。
5.2自顶向下的编程
你不能教初学者自上而下的编程,因为他们不?不知道结束了。
C.A.R. ?霍尔
在3.2节中,领域特定语言当我们第一次看着领域特定语言,我们创建了一个简单的宏,时间单位。这个宏可以让我们方便地指定时间与直观,各单位之平衡的语法:
*(单位时间内1 d) 86400
时间单位是一个方便的领域特定语言,因为程序员不是吗?t需要记住,例如,每天有多少秒。单位时间内实现用一个简单的宏,它使用一个case语句作为潜在的心脏扩张。
一个重要的宏观设计原则是自上而下的编程。当设计一个lisp宏,你首先要从抽象。你想写程序,使用宏之前你写宏观本身。有些矛盾的是,你需要知道如何编程的语言之前,您可以编写一个简洁的定义/实现语言。
如此严重的宏观建设的第一步总是写用例的宏,虽然没有办法可以测试或使用它们。如果在新的语言编写的程序足够全面,一个好主意的需要来实现语言的编译器或解释器。
宏考虑到我们的时间单位,有没有一种方法我们可以撞了另一个层面的规范和创建一种语言用于创建这些单位方便宏?unitof-time是一个宏,所以我们需要一个宏定义宏……
停!这是结束。
我们不开始考虑实施一种语言,而是问自己我们想使用这门语言。答案是,我们想要一种简单的方式来定义这些单位转换的帮手。在以下示例用例中,我们希望能够采取一种单位,一次,一个基本单位,秒,这里代表年代,和一组对一个单位,这个单位的转换因子基本单位:
(defunits % s m 60 h 3600 d 86400
1/1000的女士
我们1/1000000)
Defunits %可以扩展到代码定义了一个宏观的时间单位我们在3.2节中写道,领域特定语言,允许我们将任意时间单位秒。它可以更好吗?
这是点在设计头脑风暴,创新停止在大多数编程语言。我们刚刚创建的乘数的值不同的单元映射到代码,允许我们把单位在我们方便。但是专业lisp程序员承认,这种映射是程序本身可以通过手段来增强我们定期加强lisp程序。
当我们进入许多不同的单位可能有助于指定单位的其他单位。让吗?年代要求因素用来繁殖单位也可以与价值相对于另一个单位列表,如下所示:
(defunits % %时间米60 h(60米)d(24小时)
女士(1/1000)
us (1/1000 ms))
这个链接的单位只是感觉自然。分钟指定用我们的基本单位,秒,小时的分钟,天的小时。实现这个宏以迭代方式我们首先实现解放的行为与defunits之前与defunits % % %和明年实现链接添加适当的错误检查和解决我们的最终版本,defunits。
注意,这种新语言可以提供的不仅仅是一个方便的语法添加新类型的单位。这种语言还允许我们延迟的影响排在我们的计算和lisp还允许使用尽可能多的精确算法。例如,弗隆相当于一英里的确切定义,所以如果我们编码使用链接,而不是这样,说,一个度量近似,我们可以得到更准确的结果或,或许更重要的是,与其他计算结果尽可能一致的使用英里。因为我们可以添加最精确的转换因子我们发现和唐?t打扰自己做任何转换,这个宏会让我们建立转换例程的表达水平在其他语言中不可能的。
使用我们的自动gensym行为在8.5节中描述的,不必要的捕获、defunitsy %,相当容易编写。格雷厄姆?年代symb函数让我们生成的新名字转换宏。例如,如果时间是象征单位的类型提供了新的转换宏将时间单位。Defunits %是由原来的单位时间的定义,在3.2节中定义,领域特定语言,它周围defmacro !和一个反,每次更换零件需要重新生成宏调用。
清单5.1:DEFUNITS-1
(defmacro !defunits %(数量基本单位布雷斯特单位)吗? (defmacro (symb ?单位数量)(,g !瓦尔,g !联合国)? (*,gival�, g !联合国((?),基本单位)1)籃(mapcar(λ(x) * C ?汽车x))、(cadr x)))(集团单位2))))))
Defunits %使用嵌套反?构造出了名的难以理解。编程与反几乎是像代码中的一个维度的意义。在其他语言中,给定编程语句语义通常有非常简单的评价。你知道每一个代码将运行,因为每一个代码被迫同时运行:运行时。但在lisp通过嵌套反我们可以向上和向下的阶梯报价。我们每一个反写需要我们一步阶梯:我们的代码是一个列表,我们以后可能会或可能不会评估。但在原始列表,每一个逗号遇到需要我们放弃报价梯和实际执行代码从梯子上的[crr12-pe67适当的步骤。
这是一个简单的算法来确定当任何的代码在一个lisp形式将被评估。简单表达式的从根开始,遇到反后,标记一个报价。遇到每一个逗号,记下一个报价。如下斯蒂尔notesjciri2-pss0],这种级别的报价可能是一个挑战。这个困难,需要跟踪当前报价深度,使使用反觉得另一个维度添加到常规的编程。在其他语言中你可以走北、南、东和西,但lisp也给你的选择。
Defunits %是一个很好的第一步,但仍然不?t实现链接。现在,宏实现这种语言主要是一个简单的替换。实现我们的链接行为需要更复杂的程序逻辑。简单的置换赢了?因为部分宏观依赖t工作
清单5.2:DEFUNITS-CHAINING-1

链)))))
宏观经济的其他部分,所以当我们构建我们的扩张,我们需要过程宏观完全提供的形式,不仅考虑它的各个部分我们可以拼接。
记住宏只是函数,我们创建一个效用函数使用的宏定义,defunitschaining %。此实用工具函数接受一个单位,指定的符号像S, M,或H,单位规格的列表。我们单位规格都有一个数字,这是解释为意义基本单元,如(60米),或者一个列表和一个间接到另一个单位在一个链,像(H(60米))。
这个效用函数是递归的。为了找到乘数基本单位,我们把每一个步骤与另一个调用链中的效用函数链的其余部分。当调用堆栈风回来,我们得到乘数用于给定单元的值转化为基本单位。例如,当我们吗?重新构建乘数几个小时,我们发现一个小时有60分钟。我们递归,一分钟有60秒。我们再次递归,发现秒连锁的终结吗?分钟直接指定的基本单位。绕组从递归,我们评估(60 * 60(* 1)),3600:3600秒一个小时。
清单5.3:DEFUNITS-2
(defmacro !普克defunits % %(数量基本单位单位)? (defmacro (symb ?单位数量)(,g !val, g !联合国)? (*,gival(情况下,gtun((基本单位)1)籃(mapcar(λ(x) * ((Ccar x))�(defunits-chaining %(车x){缺点?{基本单位1)(集团单位2)))))(集团单位2))))))
这个效用函数定义,制定每个单元的乘数defunits4%只需要一个简单的修改,我们在defunits % 4%完成。而不是拼接价值直接从单位规范,我们通过每个单元和整个单位规范defunits-chainingy实用程序。如上所述,此函数递归工作所需的乘数将每个单元转化为基本单位。这个乘数defunits % %可以拼接成一个case语句的值,就像defunits %。
到目前为止,这些宏是不完整的。defunits{宏没有?t支持链接。Defunits % %支持链接但缺乏错误检查。专业宏观作家总是负责处理可能出现的任何错误条件。案件涉及无限循环,或者其他难以调试REPL,尤其重要。
defunits % %的问题实际上是一个属性的语言我们设计:可以写程序包含周期。例如:
(defunits时间年代m(1/60小时)h(60米))
为了提供适当的调试输出,我们需要加强我们的实现。我们的最终版本,defunits,
清单5.4:DEFUNITS

链)))))(defmacro !普克defunits(数量基本单位单位)吗? (defmacro (symb ?单位数量)(,g !val, g !联合国)* (*,gival�, g !联合国((基本单位)1)籃(mapcar(λ(x) *(((汽车x)), (defunits-chaining(汽车x)(缺点*{基本单位(1)(2)单位组)nil)))(集团单位2))))))

允许链接和还提供了有用的调试输出应该语言的用户指定一个计划,这样的循环依赖。它可以这样做,因为它使用defunits-chaining defunits-chaining的一个改良版本吗?维护一个列表的所有单位,曾被访问。这样,如果我们再次访问单位通过链接,我们可以抛出一个错误,简明地描述问题:
* (defunits时间s m(1/60小时)h(60米))
误差函数DEFUNITS-CHAINING: M取决于H取决于M
defunits宏defunits4% %是一样的除了它通过一个额外的参数nil defunits-chaining列表的最后代表单位的历史吗?已经访问了。如果一个新单位是寻找我们?已经参观了它,发现一个周期。我们可以用这个单位的历史访问宏的向用户显示一个有用的消息,很有可能自己,不小心写周期。
所以defunits是特定于域的语言进入单位的转换例程。实际上它是特定于一个比这更好的领域;有许多可能的方式,就不可能完成。因为很难创造语言在哭,很容易在lisp, lisp程序员通常不?别试图填满一个域。相反,他们只是让越来越多的特定于域的语言问题,直到最终目标就变得微不足道了。
一个例子使用defunits长度单元。以防你有没有想过,1970年采用国际海里缩短了理解,至少在英国水兵,1/76th:
*(/(长度单元1理解)Cunit-of-distance 1 old-brit-fathom))
清单5.5:长度单元
(defunits距离1000公里厘米1/100毫米(1/10厘米)毫米(1/1000毫米)院子9144/10000;定义在1956英尺(1/3的院子里)
1/12英寸(脚)
英里(1760码)
弗隆(1/8英里)
理解(2场);定义在1929海里1852电缆(1/10海里)
old-brit-nautical-mile;在1970年下降(6080/3院子)old-brit-cable (1/10 old-brit海里)old-brit-fathom old-brit-cable (1/100)

也就是75/76 / 2厘米:
*(强迫(长度单元old-brit-fathom 1/76)浮动)
0.024384
5.3隐式上下文
宏可以利用一种称为隐式的技术背景。在代码中使用频繁,或绝对必须简洁而没有任何周围的簿记的繁琐,我们有时会选择隐式添加lisp代码部分的一个表达式,所以我们不?t必须写它每次我们使用一个抽象。我们吗?ve之前谈了隐式上下文和它应该清楚,即使不是编程宏lisp编程的一个基本组成部分:让和λ形式有一个隐式progn因为他们评估,在序列中,形式在他们的身体和返回的最后结果。Defun形式,这样你就增加了一个隐式λ?t需要使用lambda形式命名的功能。
本节描述code-walking宏观的推导和建筑使用后在这本书中,树叶*。像平,这个宏检查一块lisp代码,考虑树,然后进行一些修改,并返回一个新的树。原始表达式的列表结构并不修改:扁平和树叶都反对新结构。两者的区别是,当平的目的是消除嵌套列表,返回一个平面列表不是吗?t真的lisp代码,树叶保存的形状表达但改变特定原子的值。
让吗?从一个简单的草图开始。树叶%是一个函数,递归树提供的表达式,缺点一个新的
4也看到COMMON LisP函数路径替换。
清单5.6:TREE-LEAVES-1
(defun树叶%(树结果)(如果树(如果(listp树)(缺点(树叶%(汽车树)结果)(树叶% (cdr树)结果)))))表结构相同的形状�当它发现一个原子,而原子它返回的值的返回结果参数:
* (tree-leavess ? (2 (t (nil。b)))叶)
(叶(NIL叶(叶子。叶)))
所以树叶%返回一个新的树与所有原子转化为我们提供的象征,叶子。注意到原子零在汽车缺点电池是没有改变的,就像它是吗?t改变当它驻留在cdr位置(代表一个空列表)。
当然,改变每一个元素是很没用的。我们真正想要的是一种选择特定的原子和选择性转换应用到他们的新原子插入新表结构,原子离开我们是吗?没有不感兴趣。在lisp,最直接的方法写一个可定制的效用函数是允许插件,用户可以使用自定义代码来控制效用?年代的行为。排序函数包含在COMMON LISP是一个这样的例子。在这里,小于函数内部排序:
排序��(6 1243896 7)# ? <)
>一个空的其他条款如果形式返回nil,也是空列表。
清单5.7:PREDICATE-SPLITTER
(defun predicate-splitter (orderp splitp)(λ(b)(让((s (funcall splitp a))) Cif (eq (funcall splitp b)) (funcall orderp b)))))
(123456789).
这个概念的一个函数来控制行为是特别方便,因为我们可以创建匿名函数适合于手头的任务。或者,当我们需要更多的力量,我们可以创建函数,为我们创建这些匿名函数。这就是所谓的函数组成。虽然函数组合不是那么有趣的宏观成分�它仍然是一个非常有用的技术,所有专业lisp程序员必须掌握。
一个简单的函数组合的例子是predicatesplitter。这个函数存在两个谓词组合成一个单一的,新谓词。第一个谓词有两个参数,用于排序的元素。第二个谓词以一个参数,确定一个元素在元素的特殊类你想把你的谓词。例如,在以下我们用predicate-splitter来创建一个新的谓词,小于完全一样,除了这一事实比奇数偶数是少:
* (7 (5 124389 6 7)(predicate-splitter # ?< # ? evenp))
(246813579).
甒脑出血是为什么只函数组合得到几个段落,宏观成分得到这本书。
清单5.8:TREE-LEAVES-2
测试结果(defun树叶% %(树)(如果树(如果(listp树)
(缺点(tree-leaves4%树(汽车)测试结果)(tree-leaves4%树(cdr)测试结果))
(如果(funcall测试树)(funcall结果树)
树))))
所以我们如何用函数作为插件控制treeleaves %是如何运作的吗?在树叶的更新版本%,treeleaves4 /,我们添加两种不同的插件功能,一个控制树叶改变和一个指定如何将一个老叶子到新的一页,分别称为测试和结果。
我们可以用树叶% %通过这两个lambda表达式,这两个必须带一个参数,x。在这种情况下,我们想要一个新的树:我们与相同的列表结构树的论点之一,除了所有的偶数都变成偶数象征:
* (tree-leavesh %(1 2 3 4 5 6)))(λ(x)(和(numberp x) (evenp x)))(λ(x) >偶数))
;注:定义变量X,但从未使用过。
(1)偶数(3偶数(5个偶数)))
似乎除了lisp工作正确地提请大家注意这样一个事实,我们不?t利用我们的第二个变量x的插件功能。当我们不?t使用一个变量通常是代码中的一个问题的一个标志。即使它是经过深思熟虑的,就像在这里,
编译器赞赏信息变量应该被忽略。通常我们会使用这个变量,但在某些情况下,像这样,我们真的不想。它吗?年代太糟糕了,我们对这个函数需要一个参数吗?毕竟我们吗?再保险就忽视了这一观点。这种情况经常出现在编写宏设计灵活。的解决方案是向编译器忽略变量x是可以接受的。因为它没有?t伤害声明一个变量可忽略的,仍然使用它呢?,我们不妨声明x变量是可忽略的:
* (tree-leavesh(1 2 3 4 5 6)))(λ(x)(声明(可忽略的x)) ((numberp x) (evenp x)))(λ(x)(声明(可忽略的x)) >偶数))
(1)偶数(3偶数(5个偶数)))
这是本教程中获得有趣的地方。似乎treeleaves % %将工作对我们好。我们可以改变任何树中的叶子提供插件的功能验证叶是否应该改变,它应该改变什么。在编程语言中除了lisp,这将改进工具停止的地方。但是lisp,我们可以做的更好。
虽然树叶% %提供我们欲望的所有功能,它的接口是不方便和冗余。就越容易实验工具,我们就越有可能找到有趣的未来用途。code-walking效用降低周围的杂物,我们创建一个宏,它可为其用户提供隐式上下文(可能是自己的)。
而是简单的像一个隐式progn或隐式的λ,我们希望整个隐式词汇上下文保存所有这些插件功能和创建的开销
Lisp会算出,可以吗?t被忽略。
清单5.9:树叶
测试结果(defmacro树叶(树)*(树叶y %,
、树
(λ(x)(声明(可忽略的x)),�测试)
(λ(x)(声明(可忽略的x))籸esult)))
只要求我们进入最少的代码像翻译树时常见的任务。值得一提的是这个隐式词汇上下文不像简单的我们吗?t找到另一个使用常见的隐式模式。相反,我们开发了一种罕见的模式,一步一步,当我们开发tree-leaves4 /走接口。
建设我们的隐式宏,树叶/用例在上面的REPL有效地直接复制粘贴到树叶的定义,然后在不同的部分,我们希望改变使用这个宏是parameterised使用反。现在,通过这个宏,我们有一个更少的冗余接口使用效用树叶% 4%。当然,这个接口是完全任意的因为有许多可能的方式,就不可能完成。然而,这似乎是最直观的,无脂的方法,至少在使用我们迄今的设想。宏允许我们创建一个高效程序员接口简单、直接的方式不可能在其他语言。这是我们如何使用宏:
*(树叶”(1 2 3 4 5。6)))((numberp x) (evenp x)) >偶数)
(1)偶数(3偶数(5。偶数)))
注意所使用的变量x实际上是没有出现
已定义。这是因为有一个隐式的词法变量绑定在最后两个表达式。这个变量的引入不可见据说违反词法透明度。另一种说法是,介绍了一个名为x的照应语的形式使用。进一步发展这个想法,在第六章,逐字宏。
5.4 Code-Walking Macrolet
Lisp是吗?t一门语言吗?建筑材料。? Alan Kay
的表现形式写,很少说话,经常像计算机代码,品种多样的发音习惯。大多数程序员运行一个对话,推理表情和发音运营商,有时是有意识的,常常不是这样。例如,最明显的方式发音口齿不清的名字特殊形式macrolet仅仅是声音lispy组件串联的两个字:宏,让。但在阅读斯蒂尔吗?观察(crrt2-pis3]一些lisp程序员发音的方式与雪佛兰押韵,很难得到这个幽默的发音你的编程对话。
然而很明显,macrolet高级lisp编程的一个重要部分。Macrolet LISP是一种常见的特殊形式,引入了新的宏成封闭的词法作用域。写作macrolet语法转换完成相同的方式定义全球与defmacro宏。就像lisp中出现的将扩大defmacro-defined宏代码,macroletdefined lisp宏将扩大系统codewalks时你的表情。
但macrolet不仅仅是一个方便。它提供了许多重要的优势使用defmacro定义宏。首先,如果你想要使用一个宏扩展表达式中考虑到他们的词汇上下文不同,创建不同macrolet上下文是必需的。Defmacro就赢了?t工作。
最重要的是,macrolet是有用的因为有多难code walk COMMON LISP表达式。我们经常有一个任意的lisp代码树,说因为我们是macro-processing它,我们想改变的价值或意义不同的树枝上。做事喜欢为特定的形式,实现临时意义,暂时搁置特定宏,也许只有在特定的表达式词汇上下文的一部分,我们需要走代码。具体地说,我们需要遍历代码,寻找我们所期望的宏观或函数名在一个位置被评估,并替代自己的表达。
容易,对吧?困难是,许多合法lisp代码片段将天真code-walker实现。考虑如果我们想执行特殊替换的评估函数的某些符号,等等。如果我们给出以下表达式,很容易看出应该进行替换:
(废话t)
等等出现在列表的功能位置时将会评估表达式是评估我们显然应该替换。目前为止一切都很顺利。但如果我们传递这种形式:
*(废话t)
因为它是引用,这个代码是为了返回列表文字。执行替换这是不正确的。所以我们code-walker必须知道停止当它击中一个报价,没有替换的形式被引用。好,这是很容易。但是我们呢?考虑是否有任何其他情况下,它是不正确的扩展等等。如果代码是使用等等作为一个词法变量的名字吗?
(让(t(废话))等等)
即使作为一个列表的第一个元素出现,它出现在一个地方让表单绑定和使用的绑定,所以不应该扩大。即使是这个不?t似乎太糟糕了。我们可以添加一些特殊情况的逻辑来code-walker所以它知道当遇到一个让形式。不幸的是,我们还有23 ANSI ComMoN Lisp的特殊形式�需要特殊情况的逻辑补充道。什么?年代,许多特殊形式是复杂的正确走路。让我们?已经看到,可能会非常棘手,它变得更糟。以下潜在法律ComMMoN LISP表单包含一个使用应该扩大的废话。哪一个?
(let (blah (blah (blah blah))) blah)
所以code-walking是困难的,因为正确处理所有的特殊形式是困难的(也参见[spzciat-rorms]和[usEFUL-LISPatcos2])。请注意,我们不?不需要任何特殊情况的逻辑形式定义为宏。当遇到一个宏,我们可以简单地扩展它,直到它变成一个函数调用或一种特殊形式。如果它是一个函数,我们知道它遵循λ?曾经只有,从左到右评价语义。的特殊形式,我们需要开发特殊情况的逻辑。
听起来像一个大量的工作,并?t吗?它是。一个完整的ComMON LISP code-walker,尤其是便携式设计,是一个大型的、复杂的代码。所以为什么不呢?t COMMON LISP为我们提供一个接口,用于code-walking COMMON LISP代码?好吧,事实证明,在某种程度上,,,在某种程度上,它吗?年代称为macrolet。Code-walking正是COMMON LISP系统前需要做评估或编译一个表达式。就像我们假设code-walker, COMMON LISP需要理解和处理的特殊语义和其他特殊形式。
COMMON LISP以来走我们的代码来评估,通常不再需要一个单独的code-walking程序。如果我们想做选择性转换表达式
�有25个ANSI CL的特殊形式,23没有让和引用。
聪明的方式会被评估,我们可以简单的编码转换作为一个宏,然后包装macrolet形式的表达式。COMMON LISP codewalk这个表达式时评估或编译并将宏macrolet指定的转换。当然因为macrolet定义宏,它在运行时不强加任何额外的开销。和COMMON LISP Macrolet是沟通吗?年代code-walker和唯一的保证COMMON LISP宏将扩大时,它将在运行时完成编译functionjcrrr: P685] [ON-LISP-P25]。
使用macrolet最常见的场景是当你想要假装一个函数是绑定在某一词汇上下文但你想使用这个表单的行为比函数调用其他的东西。些和标签?他们只能定义函数。所以我们选择写code-walker寻找调用这个函数,并将其替换为别的,定义一个全球宏观与defmacro“函数”将扩展到别的东西,或包装形式macrolet,让系统?年代code-walker出来给我们。
正如上面提到的,写一个code-walker是困难的。如果可能的话我们应该避免这种路线。使用全局defmacro有时是可能的,但经常有问题。最大的问题是,COMMON LISP让一些担保何时?还是多久?宏将会扩展,所以我们可以吗?t可靠地使用相同的名字有不同的含义在不同的词汇上下文。当我们覆盖全球宏观可以吗?t知道ComMON LISP扩大了?还是想再次扩大在未来吗?旧的使用宏。
为一个相关的例子code-walking是有用的,让?讨论一个问题,我们在3.3节也被隐藏起来,控制结构。我们计划的初始版本命名宏,nlet,使用标签的特殊形式来创建一个新型的控制结构。暂时的使用标签允许我们定义一个函数用于指定让体内,将允许我们递归,因为如果我们开始让一次又一次新的值
清单5.10:NLET-TAIL
(defmacro !普克nlet-tail (n letargs身体)(让((gs(我在letargs收集循环(gensym)))) * ?(macrolet ((n, gs ? (progn (psetq籕(应用# ?nconc (mapcar # ?列表
>,(mapcar # ?汽车letargs)(列表,@gs)))) (?, g ! n))))(块,g !在(b(让letargs (tagbody籫回来籫!b (progn @body))))))))来绑定。当我们定义这个函数,我们提到,因为COMMON LISP并不能保证它将尾部调用优化,可能每个迭代的名字让控制结构将不必要的额外的堆栈空间。换句话说,与计划不同,COMMON LISP函数调用不能保证尾部调用优化。
即使最体面的COMMON LISP编译器将执行适当的尾部调用优化,有时我们需要确定优化。最简单的便携式实现这个目标的方法是改变nlet宏观以便它生成的扩张必然使用没有不必要的堆栈空间。
在nlet-tail,我们提供的身体周围内宏观和包起来一些形式。我们使用块和返回语句返回的最后一个表达式的值,因为我们试图模仿的行为让形式及其隐progn。请注意,我们使用gensym这个块的名字和每个让gensym参数来避免不必要的捕捉
以及这些gensyms循环宏�收集。
Nlet-tail用于原始nlet一样,除了调用non-tail命名let的位置是被禁止的,因为他们将会扩展到尾调用。时,我们使用的是缺乏想象力的示例相同nlet,除了它是保证,即使在一个lisp并吗?t执行尾部调用优化,不消耗额外的堆栈空间:
(defun nlet-tail-fact (n) (nlet-tail事实((mn) (acc 1))(如果(zerop n) acc(事实(n - 1) (* acc n)))))
作为本节的这是激励的例子,请注意,我们使用macrolet code walk提供身体寻找使用的事实。我们原始nlet使用标签的特殊形式来绑定一个函数,我们想要确保没有额外的堆栈空间消耗当我们调用命名。从技术上讲,我们想改变一些绑定词法环境和执行跳转回命名let的顶部。nlet-tail需要提供我们的名字,在我们的上面使用示例,并创建一个本地宏只提供体内生效。这个宏扩展使用psetq设置绑定到代码提供的让新值,然后跳回,不需要堆栈空间。最重要的是,我们可以用其他不相关的宏程序的名字事实上! ?。
实现这一跳,nlet-tail使用lisp tagbody特殊形式的组合和走。这两种形式提供转向系统。尽管goto强加在结构化程序设计的问题,不管这意味着什么,广泛讨论,COMMON LISP提供我们使用这些特殊形式的原因
甃oop是奇怪的COMMON Lisp的最有争议的问题之一。然而,大多数的反对意见都完全没有根据。循环是一个非常方便的领域特定语言领域的循环。
什么样的编程书不?有几个!不管怎样实现?
他们在这里。通过控制程序计数器吗?我们正在执行的代码的当前位置吗?我们可以创建非常有效的宏观经济扩张。而转到现代高级语言通常是气馁,快速浏览任何一点的汇编代码将显示goto非常活蹦乱跳的在我们的计算机软件的最低水平。即使是最坚决anti-goto倡导者不建议清除低级语言如C和汇编的goto和跳转指令。似乎在一个低水平的编程中,我们只是需要转向,至少写出高效的代码。
然而,随着Alan Kay说,lisp是吗?一种语言?它是一种建筑材料。谈论是否高或低水平根本是lisp ?t是有意义的。非常高级的lisp像我们的领域特定语言。我们写的宏来处理这些语言,我们把他们使用lisp的低水平。当然,这些扩展是lisp代码,只是不像原来的压缩版本。接下来,我们通常把这中级lisp代码编译器,先后将其转换为低,低水平的lisp。它赢了?t是漫长的概念,比如转到之前,条件分支,和一些无足轻重的进入代码,但即便如此,它仍将是lisp。最终,本地代码编译器,高水平lisp程序将被转换成汇编语言。但即使是这样,那么你的程序仍然会口齿不清。因为大多数lisp汇编器是用lisp写本身只有自然作为lisp对象来存储这些汇编程序,导致真的低级程序真的还口齿不清。只有当程序实际上是组装成二进制机器代码,它就不再是lisp。还是它?
高和低水平的区别并不适用于lisp;lisp程序的水平都是角度的问题。Lisp不是语言,而是最灵活的软件目前发现的建筑材料。
5.5递归扩展
当教学实例lisp初学者,这个问题不可避免地出现很快到教训
WTF cadr吗?
有两种方式进行。首先是向学生解释lisp列表构建缺点细胞,每一个都有一个指针叫做汽车和一个指针称为cdr。一旦明白这个概念,很容易说明的accessor函数指针,也叫汽车和cdr,可以组合成一个名为cadr的函数遍历一个列表,检索第二个元素。
第二种方法是指向学生第二和完全忽略cadr COMMON Lisp函数。cadr和第二个完成相同的任务:检索列表的第二个元素。所不同的是,第二个是命名它,和cadr命名它。指定Cadr是透明的。而第二个是函数的一个容易记住的名字,它不受欢迎地掩盖了操作的意义! !透明规范往往更好,因为我们可以考虑使用cadr函数仅仅采取第二个元素的列表。例如,我们可以透明地使用cadr作为一个概念获取lambda的论点destructuring列表形式。Cadr下面和第二都执行相同的任务,但在概念上可以代表不同的操作[ciri2-pss0)。
比哲学更重要的偏爱透明规范、汽车和cdr的组合更能代表列表访问操作,和更加一致,比把英语读写单词。汽车和cdr是有用的,因为我们可以结合成新,任意的函数。例如,(cadadr x) isthesameas(汽车(cdr(汽车(cdr x))))。COMMON LISP的规定,所有组合汽车和cdr的长度必须定义四个或更少。所以虽然没有函数second-of-second采取第二个元素的列表,然后把它作为一个列表和检索其第二个元素,我们可以使用cadadr为此。
尤其方便这些预定义的组合函数可以接受一个可用的汽车和cdr:关键
特别是因为第二cadr是完全一样的:你可以吗?t使用它来得到向量等其他序列的第二个元素。
访问器参数,像找到:
*(发现了什么? (((b) (ce d)) (Cc d) (b))):关键# ? cadadr)
(CC D)(坏的管理者)
使用预定义的cadadr访问器比建设更简明英语访问器的等效的lambda表达式组成的组合:
*(发现了什么? (((b) (ce d)) (Cc d) (b))) tkey(λ(e)(第二(第二e))))
(CC D)(坏的管理者)
ComMoON LisP还提供了函数n和nthcdr可以用作通用访问器,如果为例,我们呢?不知道哪些元素在compiletime我们想看。n简单定义:n cdr的列表,然后一辆汽车。所以(n 2列表)!是一样的(caddr列表)和(第三个列表)。Nthcdr是相同的除了它没有?t做最后的汽车:(nthcdr 2列表)是一样的(cddr列表)。
但如果位置缺点结构由一个以上的无法访问模式像n或nthcdr,我们需要结合访问器。必须把不一致的抽象来完成一项任务通常是不完备的象征。我们可以定义一个领域特定语言的域访问列表为了团结这些汽车和cdr函数,结合英国访问器和函数n和nthcdr吗?
由于汽车和cdr基本操作,我们的语言应该涉及这两个访问器完全结合
我们可以轻松地使用列表作为变量名因为COMMON Lisp ?第二个名称空间。这些例子将问题singlenamespace地像计划。
清单5.11:CXR-1

籺 ree)))))
一般方法。因为有无限的组合,继续通过定义函数组合每一个可能的访问器显然是不可行的。我们真正想要的是一个宏,它可以扩展到有效列表遍历代码。
指定列表的语法访问器通过命名它从一个C函数,紧随其后的是一个或多个与R或D字符和结束,非常直观,大概是我们想复制我们的语言。宏cxr�是一个双关语在这些访问器和一个或多个或D字符替换为一个x !3 _ cxr %,这些和Ds是作为第一个参数列表中指定的宏。这个列表是一个交替的组合数字和符号的或D。
例如,尽管COMMON LISP并吗?t为我们提供一个英语函数访问第十一个元素的列表,我们可以很容易地定义:
(defun第十一(x) (cxr % (1 10 d) x))
本节的目的是为了说明实际使用递归扩展。一个递归的扩张出现当一个宏扩展形成,还包含一个使用的一种新形式
13 xcept精神,cxr无关的Maclisp cxr大块槽访问。
宏观的问题。正如所有的递归,这个过程必须终止基本情况。希望宏最终会扩展成一种不?t包含宏的使用问题和扩张将会结束。
这里我们macroexpand cxr %的实例宏成一种也使用cxr %:
* (macroexpand > (Ccxrf % 1 (2 d)排行榜))
(汽车(CXR % 4 (2 D)排行榜))T
当我们复制这个新的递归形式macroexpand,我们发现另一个递归:
* (macroexpand > (CXR4 (2 D)排行榜))
(CDR (CXR4 (1 D)排行榜))T
下一个递归的结果说明了另一个可能的

* (macroexpand > (CXR4 (1 D)排行榜))
(CDR (CXR % 4 NIL排行榜))T

* (macroexpand > (CXR % NIL排行榜))
排行榜T
M41f Common LisP包括,它可能被称为cr。
使用CMUCL扩展macroexpand-all,完成code-walker的一个组件,我们可以看到整个原始cxr %的扩张形式:
*�(沃克:macroexpand-all * (cxr4�1 (2 d)排行榜))
(汽车(CDR (CDR排行榜)))
感谢我们优秀的lisp编译器,对于所有意图和目的的使用cxr % caddr和第三个功能相同。
但是,顾名思义,cxr %是不完整的。它仅仅是我们的最终的第一幅素描宏,cxr。第一个问题与我们的草图是它只接受整数或Ds的计数。这个规范,有n和nthcdr可以做的事情,我们宏可以吗? t。
我们需要检查的情况给出了非整型数前缀或D的象征。在这种情况下,我们的扩张代码应该评估提供和使用这个值是什么!作为汽车的数量的数量或cdr遍历。
cxr %的第二个问题是,当考虑到极其大量的前缀或D符号将内联所有汽车和cdr组合。对于小数字,性能和内联但通常它也可以增加吗?t意义内联过于大量的汽车和cdr;相反,我们应该使用像n或nthcdr循环功能。
解决这两种情况下,我们添加另一种扩张。如果参数前的一个象征是吗?t一个整数,这个新行为必须被使用,如果我们宁愿不内联大量汽车或cdr,这种行为也可以被选中。任意选择这种内联阈值是10,这个新行为与宏观cxr提供。
cxr我们可以定义nthcdr直接的透明汽车和cdr规范:
希望这个值应该是一个号码。在lisp,我们可以安全地离开lisp这种情况吗?异常系统处理和描述的程序员。
清单5.12:CXR

(,op, g ! val))))))))

列表(defun nthcdr % (n) (cxr (n d)列表))
同样,n:
列表(defun n % (n) (cxr(1)列表))
因为宏观写作是一个迭代,层的过程中,我们往往提示合并或构成宏viously之前实施。例如,在cxr的定义,我们的备用扩张利用宏定义在前一节中:nlet-tail。Nlet-tail是方便的,因为它允许我们给迭代构造和一个名字,因为我们只在迭代计划作为一个尾巴,我们确定我们可以使用它来避免不必要的堆栈消费。
下面是如何使用cxr nthcdr %扩展:
* (macroexpand * (cxr (n d)列表))
(让()(NLET-TAIL #: NAME1632 ((#: COUNT1633 N) (#: VAL1634 (CXR NIL列表)))(如果(> = 0 #:COUNT1633) #: VAL1634 (#: NAME1632 (- #: COUNT1633 1) (CDR #: VAL1634)))))
注意到复杂的宏扩展人类经常编写代码,程序员不会。尤其请注意nil cxrs的使用和使用无用的我们,都留给进一步宏观展开和编译器优化。
因为宏可以使更多的扩张对宏观的用户可见,透明规范在其他语言中通常可能的方式是不可能的。例如,根据
cxr设计、参数前和Ds整数不到cxr-inline-thresh将内联调用汽车和cdr:
* (macroexpand ?(cxr (9 d) list))
(让()(CDR (CXR (8 D)列表)))T
但由于cxr吗?透明的规范,我们可以传递一个值,虽然不是一个整数,将评估时,成为一个整数。当我们这样做时,我们知道没有内联发生因为宏将导致nlet-tail扩张。最简单的形式,评估一个整数是整数,引用:
* (macroexpand ?(cxr (?9 d) list))
(让()(NLET-TAIL #: NAME1638 ((#: COUNT1639 ? 9) (#: VAL1640 (CXR NIL列表)))(如果(> = 0 #:COUNT1639) #: VAL1640 (#: NAME1638 (- #: COUNT1639 1) (CDR #: VAL1640)))))
我们经常在一起觉得它有用结合宏:cxr可以扩展到宏观我们称为nlet-tail早些时候写道。同样,有时是有用的结合宏观与自身,导致一个递归的扩张。
5.6递归解决方案
似乎宏在前一节中,我们定义cxr,汽车和cdr包含组合的功能,
清单5.13:DEF-ENGLISH-LIST-ACCESSORS
(defmacro def-english-list-accessors(开始结束)(如果不是(< = 1开始结束)(错误“坏开始/结束范围”))? (progn籃(我从开始到结束收集循环吗? (defun�(symb(地图吗?字符串(λ(c)(如果(alpha-char-p c)
(char-upcase c) # \ -))
(格式为零”?:r”我)))(arg) (exr(1,我(- 1)d) arg)))))作为通用平面列表访问器函数n和nthcdr。但是英语读写方法像第一、第二和第十?这些功能无用吗?绝对不会。当代表的操作访问第四元素列表,使用第四确保节拍计算cadddr 3 Ds,写作和阅读效率。
事实上,英语读写方法最大的问题是只有10的限制,第一到第十,COMMON LIsP。但本节的主题之一,事实上这本书,就是lisp的每一层洋葱可以使用其他层。在lisp中没有原语。如果我们想定义更多的英语读写方法,像十一,如上所述,我们可以这样做。defun第十一函数定义是没有不同于由ANSI指定访问器像第一和第十位。因为没有原语,我们可以使用所有的lisp宏定义,我们可以利用先进的功能,如循环和格式!�在我们的宏定义。
宏def-english-list-accessors使用格式
16 COMMON Lisp的格式是一种有争议的特性。然而,最喜欢反对循环,是基于误解的概念和范围领域特定语言。
字符串" ~:r”转换为一个数字,我,一个字符串包含相应的英语单词。我们改变所有中非字母数字字符,如lisp是司空见惯,连字符。然后我们这个字符串转换为一个符号,并使用它在一个defun形式实现适当的访问器功能与我们cxr宏。
例如,说我们突然意识到我们需要访问列表的第十一个元素。我们可以使用n或cdr和英语读写方法的组合,但这将导致不一致的编码风格。我们可以重写代码访问器完全避免使用英语,但有可能是一个原因为什么我们选择使用抽象的。
最后,我们可以定义必要的访问器自己失踪。在其他语言中,这通常意味着大量的复制粘贴或者一些特殊情况的代码生成脚本?这两种特别优雅。但是lisp,我们有宏:
* (macroexpand > (def-english-list-accessors 11 20))
(PROGN
(DEFUN十一(ARG) (CXR ARG (1 10 D))) (DEFUN十二(ARG) (CXR ARG (1 11 D))) (DEFUN十三(ARG) (CXR ARG(1一12 D))) (DEFUN 14 (ARG) (CXR ARG(1一13 D))) (DEFUN十五(ARG) (CXR ARG (1 14 D))) (DEFUN 16 (ARG) (CXR ARG(1一15 D))) (DEFUN 17 (ARG) (CXR ARG(1一16 D))) (DEFUN十八(ARG) (CXR ARG (1 17 D))) (DEFUN 19 (ARG) (CXR ARG (1 18 D))) (DEFUN 20 (ARG) (CXR ARG (1 19 D))))
能够创建这些英语读写方法减少的影响十ANSI COMMON Lisp的访问限制。如果我们需要更多的英语读写方法,我们刚刚创建的defenglish-list-accessors宏。
ANSI怎么样?年代限制只有定义组合的汽车和cdr的深度四个吗?有时,当程序
清单5.14:CXR-CALCULATOR
(defun cxr-calculator (n)(我从1到n循环求和(外贸2 i)))
明复杂处理程序列表,我们希望有一个访问器函数定义是? t。例如,如果我们使用函数cadadr, second-of-second,访问列表和我们改变我们现在的数据表示,以便引用需要second-of-third,或cadaddr,我们遇到这COMMON LIsP的限制。
像我们学生的英语读写方法,我们可以编写一个程序,它定义了额外的汽车和cdr的组合。问题在于,与英语读写方法,结合功能的深度的增加像caddr导致一个指数增加的数量需要定义的函数。具体来说,访问器的数量需要覆盖的深度定义n可以通过使用函数cxr-calculator找到。
我们看到,ANSI指定30组合:
* (cxr-calculator 4)
30
给你一个想法的功能所需数量的增长速度:
*(我从1到16收集循环(cxr-calculator i))
30, 62, 126, 254 (2 June 14, 510, 1022, 2046, 4094, 8190, 16382, 32766, 65534, 131070)
显然涵盖所有汽车和cdr深陷cxr函数的组合我们需要一个不同于我们如何解决英语读写的方法问题。定义所有组合的汽车和cdr一些可接受的深度是不可行的。
清单5.15:CXR-SYMBOL-P
(defun cxr-symbol-p (s)(如果(symbolp年代)(((字符(强迫(符号名的年代)?列表)))(

(lambda (c)
软木(char = c # \) (char = c # \ D))) (cdr(但是字符))))))))首先,我们应该有一个坚实的规范cxr符号是什么。Cxr-symbol-p是一个简洁的定义:所有符号都用C,结尾R,包含5或更多或Ds中间。我们不?t要考虑cxr符号与少于5或Ds因为这些功能已经保证由CoMMON LisP ! ?
接下来,因为我们计划使用cxr来实现任意车和cdr的功能组合,我们创建一个函数cxr-symbol-to-cxr-list转换cxr的象征,所定义的cxr-symbol-p,成一个列表,可以作为第一个参数cxr !�这是其使用的一个例子:
* (cxr-symbol-to-cxr-list > caddadr)
(4 a1d1d1a41d)
注意到使用的函数列表在cxr-symbol-to-cxrlist *。列表*几乎是一样的,除了最后的基于“增大化现实”技术
7 re-binding功能指定ComMON Lisp是被禁止的。
18个有趣,弃用功能爆炸可能是有用的在这种情况下,但排除Common Lisp,因为没有人能想到的好的用途。
清单5.16:CXR-SYMBOL-TO-CXR-LIST
(defun cxr-symbol-to-cxr-list (s)(标签(收集(1)(如果1(列表* 1 Cif (char =(汽车1)# \)oA 7 d)(收集(cdr 1))))))(收集(cdr;砍掉C(但是;砍掉R(强迫(符号名的年代)
?列表))))))gument插入最后的cdr位置缺点细胞在创建列表中。列表*很方便编写递归函数时,建立一个列表,每个堆栈帧可能想添加不止一个元素的列表。在我们的例子中,每一帧都想将两个元素添加到列表:数字1和一个符号或D。
最后,我们决定的唯一途径有效地提供cxr任意深度的函数是code walk表情和定义只提供必要的功能。with-all-cxrs宏使用格雷厄姆?年代平工具code walk表达式以同样的方式提供defmacro / g !从3.5节宏观,意外捕获。满足cxr-symbol-p With-all-cxrs发现所有的符号,创建的函数是指使用cxr宏,然后结合这些函数的代码提供了一种标签)?。
现在我们可以将表达式的形式传递给with-all-cxrs和假装这些表达式可以访问任何可能cxr函数。如果我们选择,我们可以简单地返回这些函数用于其他地方:
“这种方法的一个问题是,这些访问器不会setfable。
清单5.17:WITH-ALL-CXRS
(defmacro with-all-cxrs普克(形式)?(标签(@ (mapcar(λ(s) * (s (1) (cexr (cxr-symbol-to-cxr-list s) 1))) C(删除重复值(删除如果不是# ? ?cxr-symbol-p(扁平形式))))),@forms))
* (with-all-cxrs # ? cadadadadadr)
# <解释功能>
或者,如以下所示宏扩展,我们可以嵌入任意复杂的lisp代码,利用这个无限类:
* (macroexpand > (with-all-cxrs(缺点(cadadadr列表)(caaaaaaaar列表))))
(标签
((CADADADR (L)
(CXR (1 a4a1d1a1d141d) L)) (CAAAAAAAAR(左)
(CXR (1 a1a1a1a1a1a1a1) L)))(缺点
(CADADADR LIST)
(CAAAAAAAAR LIST)))
经常任务听起来困难吗?喜欢英语的定义无限类列表访问器和car-cdr组合呢?是重新
盟友只是一个简单的问题组合在一起的集合。相比单一的问题恰好是困难,简单的集合可以被递归地接近问题解决问题。通过思考的方式将问题转化为简单问题的集合,我们使用一个可靠的方法来解决问题:分而治之。
5.7 Dlambda
在讨论关闭我们提到如何使用一个闭包作为一个对象,以及如何,一般来说,不确定的范围和词法作用域可以代替复杂对象系统。但一个对象经常提供的功能,我们大多忽略了直到现在是多个方法。换句话说,当我们简单的计数器闭包示例只允许一个操作,增量,对象通常希望能够应对不同的信息有不同的行为。
虽然闭包可以被认为是一个对象的一个方法?申请?可以设计一个方法,有不同的行为基于传递给它的参数。例如,如果我们指定第一个参数是一个符号代表消息传递,我们可以提供多个行为用一个简单的基于第一个参数的case语句。
实现一个计数器增量法和递减法,我们可以使用:
(让((数0))(λ(味精)(case味精(C: inc) (incf计数))((12月)(decf计数)))))
注意,我们选择关键字符号,符号,首先:总是评价自己,显示消息。关键词是方便的,因为我们不?t有
清单5.18:DLAMBDA
(defmacro !普克dlambda (ds) ?(λ(普克,g ! args)(案例(汽车,g ! args)籃(mapcar(λ(d)�, Cif (eq t(汽车d)) t(列表(汽车d)))((λ,@ (cdr d))应用�如果(eq t(汽车d))
giargs ? ds (edr gtargs)))))))))引用或导出他们的包,和也直观,因为它们的设计执行和其他类型的解构。通常在λ或defmacro形式关键字在运行时不变性。但是因为我们实现一个消息传递系统,这是一个类型的运行时解构,我们离开关键字处理操作在运行时执行。正如前面所讨论的那样,解构符号是一种有效的操作:仅为指针的比较。当我们的反例编译它可能减少到以下机器代码:
2 fc: MOV EAX, [# x582701E4];:公司302:CMP EBP-12, EAX
305: JEQ L3
307:MOV EAX, [# x582701E8] 3: 12月30 d: CMP EBP-12, EAX
310: JEQ L2
但为了方便,我们想避免写每一个对象或类的case语句创建。这种情况下应该宏。宏我喜欢用dlambda,展开成一个λ形式。这种扩张包括一种许多不同分支的代码之一
根据参数应用于执行。这种类型的运行时解构使dlambda它的名字:这是解构或调度版本的λ。
Dlambda被设计成通过关键字象征作为第一个参数。根据关键字,象征dlambda将执行相应的代码。例如,我们最喜欢的一个闭包的例子吗?简单的柜台吗?可以扩展以增量或减量使用dlambda数根据第一个参数。这就是所谓的让dlambda模式:
* (setf (symbol-function ?数测试)(((数0))(dlambda(:快乐()(incf计数))(:12月()(decf计数)))))
# <解释功能>
我们可以增加
*(数测试:inc) 1
和衰减*(数测试:12月)0
根据第一个参数传递闭包。虽然空在上面让dlambda,关键词符号实际上是λ解构后的名单列表。每一个公文包,换句话说,每个关键字参数,可以拥有其独特的λdestructuring列表,如以下增强柜台关闭:
* (setf (symbol-function ?数测试)(((数0))(dlambda(:重置�(setf数0))(公司(mn) Cincf数n))(: 12月(n) (decf数n))(:绑定(lo嗨)(setf计数(min嗨(max瞧
数)))))))
# <解释功能>
我们现在有几个不同的λdestructuring列表可能被使用,取决于我们的第一个关键字参数。:重置不需要参数和计算又回到0:*(数测试:重置)0
:公司和:12月把一个数值的参数,n: *(数测试:公司100)100
和:确保计数的值是两个边界值,lo和你好。如果数量超出这个界限是改变最近的边界值:*(数测试:绑定-10 10)
10
dlambda的一个重要属性是它使用λ为所有解构,以维持正常的错误检查和
我们提供的调试支持COMMON LISP的环境。例如,如果我们只给一个参数直接数测试,我们将得到一个错误与不正确的参数数量λ应用程序:
*(数测试:绑定-10)
错误:错误的参数数量,希望2和1。
尤其是当dlambda嵌入词法环境形成一个闭包,dlambda允许我们计划?在面向对象术语?好像我们与多个方法创建一个对象。Dlambda定制,使此功能方便而不是离开λ的语法和用法。Dlambda还扩展到一个λ形式和,因此,其评价结果评估λ结果:什么可以保存一个匿名函数,应用,而且,最重要的是,作为一个词法闭包的λ分量。
但dlambda需要这个同步λ更进一步。为了dlambda提供平滑的过渡从代码包含λ宏,dlambda还允许我们过程调用匿名函数,唐?t通过关键字参数作为第一个符号。当我们有大量的通过正常的λ接口编写的代码使用闭包我们会欣赏能够添加特例dlambda方法不改变其余的代码如何使用接口。
如果最后一个可能的方法是t象征,而不是一个关键字参数,总是会调用所提供的方法,如果没有特殊情况的关键字参数方法应用。这是一个做作的例子:
* (setf (symbol-function ? dlambda-test) (dlambda(:一些特别的()(格式t“特别~ %”))(t(普克args)
(格式t“默认值:? ~ %”args)))) # <解释功能>
这个定义,多数的方法调用这个函数调用默认情况下。我们默认情况下使用普克λdestructuring参数接受所有可能的参数;我们可以缩小接受参数通过提供更具体的参数λ解构。
* (dlambda-test 1 2 3)默认值:(1 2 3)
NIL
* (dlambda-test)默认值:零
NIL
然而,尽管这个匿名函数行为主要是像普通λ形式定义了默认的情况下,我们可以通过关键字参数调用的特殊方法。
*�(dlambda-test:一些特别的)特殊零
一个关键特性,将利用大量的第二章,是默认的方法和特殊方法,当然,包括dlambda词汇上下文的调用。因为密切dlambda是如何结合lambda的符号,这让我们把多种技术来创建和扩展的领域词法闭包。
