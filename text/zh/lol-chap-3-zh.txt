第三章宏观基础知识
3.1迭代开发
Lisp已经帮助一些我们最天才的人类思考从前不可能的想法。
?KEdsger Dijkstra
建设一个宏是一个迭代的过程:所有复杂的宏来自简单的宏。后从一个想法,一个粗略的实现可以创建的终极宏将会出现,就像一个雕塑从一块石头。如果粗糙的实现不是吗?t足够灵活,或导致inet ficient或危险的扩张,专业宏程序员宏会略有修改,增加功能或删除错误,直到满足所有的需求。
这个迭代过程宏观建设的必要性部分是因为这是最有效的编程风格一般,部分是由于编程宏是更复杂的比其他类型的编程。因为宏观编程需要程序员考虑多级代码在多个时间点执行,复杂问题规模速度远高于其他类型的编程。一个迭代过程有助于确保你的概念模型更紧密地结合起来,是什么实际上比如果整个创建宏写没有这种持续的反馈。

在这一章里,我们将编写一些基本宏通过引入两个常见的宏观概念:领域特定语言和控制结构。一旦这些一般宏观领域,我们退一步,讨论编写宏的过程本身。变量捕获和自由变量注入技术,介绍了定义一个新的,更方便的语法来定义使用lisp宏在这本书的其余部分。
3.2。领域特定语言
CoMMON LIsP和大多数其他编程环境中,睡眠提供了一个函数,该函数将暂停执行n秒的过程,其中n是一个非负,非复杂,数值参数。例如,我们可能想睡觉3分钟(180秒),在这种情况下,我们可以评估这种形式:
(180年睡眠)
或者如果我们宁愿想睡觉的分钟,我们可以用
(睡眠(60)* 3)
因为编译器知道如何折叠常数,这两个调用是同样有效的。更明确的我们呢?重新做,我们可能会定义一个函数sleep-minutes:
(defun sleep-minutes (m)(睡眠(* 60 m)))
定义新的函数为每个时间单位,我们可能希望使用笨重,不方便。我们真正想要的是某种抽象的,它让我们指定的单位时间的价值。我们真正想要的是一个领域特定语言。
迄今为止,lisp的解决方案是一样的,任何其他语言:创建一个函数,它接受一个值和一个单元并返回相关的价值乘以某个常数
清单3.1:SLEEP-UNITS-1
(defun sleep-units %(价值单位)(睡眠(*值
(案例单元((s) 1) ((m) 60) (Ch) 3600) (Cd) 86400) ((ms) 1/1000) 1/1000000 (Cus))))))
单位。但可能lispy改进变得明显,当我们考虑我们的选择代表了这个单位。像C语言习惯上使用一个基本数据类型int和分配任意值对应不同的单位:
#定义UNIT_SECONDS 1 #定义UNIT_MINUTES 2 # define UNIT_HOURS 3
int sleep_units (int, int单元){开关(值)f{案例UNIT_SECONDS:返回值;案例UNIT_MINUTES:返回值* 60;案例UNIT_HOURS:返回值* 3600;}}
但在lisp信号所需的单位最明显的方法是使用一个符号。象征在lisp中存在主要是没有情商其他符号。情商是最快的lisp比较运算符和比较大致对应于一个指针。由于指针可以很快相比,符号提供了非常快速和方便的方式,让两个或两个以上不同的lisp表达式知道你指的是同一件事。在lisp中我们可能定义sleep-units %函数我们可以指定单位形式:一个(sleep-units % 2 ?米)(sleep-units % 500 ?)
因为比较符号只需要一个指针比较,sleep-units %将编译成一个非常快的运行时调度:
524:CMP ESI, [# x586FC4D0] 3 7 s
530年52:JEQ不断化解:CMP ESI, [# x586FC4D4] 3;538年? 536年M: JEQ L10: CMP ESI, [# x586FC4D8] 3;? H 53 e: JEQ L9 540: CMP ESI, [# x586FC4DC] 3;546年? D: JEQ 18
注意单位给sleep-units %必须引用。这是因为当lisp评估它首先评估参数的函数,然后将结果绑定到变量函数内使用。数字和字符串和其他一些原语评价自己这就是为什么我们不?不需要报给sleep-units %的数值。但注意,他们评估你允许引用他们如果你喜欢:
(sleep-units %吗?。5 ? h)
符号,然而,唐?通常评价自己!。当lisp评估一个象征它假定你是指一个变量,并试图查找词汇上下文相关的变量值了(除非声明的变量是特殊的,在这种情况下,动态环境)。
为了避免引用单位,我们需要一个宏。不像一个函数,一个宏不评估其参数。利用这一事实,我们取代sleep-units % sleep-units宏函数。现在我们不?t需要报价单位:
作为一个规则,没有规则没有例外。一些符号做评估,例如:t, nil,和关键词。
清单3.2:SLEEP-UNITS
(defmacro sleep-units(单元)价值?(睡眠(*,价值
粄案例单位((s) 1) ((m) 60) (Ch) 3600) (Cd) 86400) ((ms) 1/1000) 1/1000000 (Cus))))))
(sleep-units。5小时)
虽然这个宏的主要目的是为了避免引用单元参数,这个宏比功能更有效,因为没有运行时调度:单位因此乘数在编译时是已知的。当然,每当我们发现这种所谓“好的难以置信”的情况下,它可能真的太好了,是真的。这个增益效率不是?t自由。通过上述运行时调度我们失去了在运行时确定时间单位的能力。这使得它不可能使用我们的宏执行下面的代码:
(sleep-units 1(如果super-slow-mode ? d ? h))
这不会工作,因为sleep-units预计的第二个参数是一个符号的case语句,而是这是一个列表的第一个元素符号。
回想一下,大多数宏创建更方便和有用的编程抽象,提高底层代码的效率。是否可以从这段代码中提取任何成语使它更有用的程序(和可能的其他未来计划)?即使现在我们可以预见想做其他事情时间值只是称睡眠。宏观的时间单位从sleep-units宏观抽象功能,返回一个值,而不是调用睡眠。值参数可以确定
清单3.3:单位时间内
(defmacro时间单位(值单位)*(*,值
粄单元(Cs) 1) ((m) 60) (Ch) 3600) (Cd) 86400) ((ms) 1/1000) (Cus) 1/1000000))))
在运行时,因为它是评估,但单位不能因为我们需要在编译时的信息,就像sleep-units一样。这是一个例子:
*(单位时间内1 d)
86400
简单的宏的时间单位提供更好的语法为解决特定领域的问题和可以给大量的生产力和正确性的优势。我们将继续本单元语言的发展进一步的5.2节中,由上而下的编程。与大多数编程语言lisp给你同样的工具用于创建您的编程环境的人。宏是足够好的COMMON LISP语言实现他们足够好实现自己的领域特定语言。
3.3。控制结构
尽管本书关注COMMON LISP,它是写给和方案的编程语言。计划是一种美妙的语言,尽管缺乏许多特性lisp程序员认为理所当然,还提供足够灵活的核心
清单3.4:NLET
(defmacro nlet (n letargs krest body) ?(labels ((,n ,(mapcar #?car letargs) 籃body)) (,n ,@(mapcar #?cadr letargs))))
专业的lisp程序员来扩展是必要的?。同样,有一些特性Scheme程序员COMMON LIsP并依靠严重吗?t具体地址。但对比每种语言提供的特性,除了少数例外,毫无意义。两种语言之间的差距,并且经常架桥。我们使用的桥梁跨越这两种语言之间,当然,宏。
计划吗?让形式是在一个方面更强大的比它的COMMON LIsP。计划吗?年代让形式支持一些所谓的命名。在计划中,您可以选择插入符号绑定列表之前让形式和计划将绑定一个函数被提供的符号在让身体?。这个函数接受我们提供的新参数的值绑定,提供一个非常方便的方式来表达循环。
幸运的是我们可以构建一个桥梁方案和COMMON LIsP nlet宏。Nlet风格让我们代码方案模拟方案?年代叫让。在nlet-fact nlet用于定义阶乘函数通过使用一个名为让:
(defun nlet-fact (n) (nlet事实(n (n))(如果(zerop n) 1 (* n (n (- 1))))))
因为nlet是我们的第一个宏,让?年代放慢脚步,
?方案和Common Lisp的主要区别在于他们迎合的社区。Scheme程序员喜欢谈论是多么伟大的有一个简短的规范;COMMON LISP程序员编写程序。
3方案只有一个名称空间,所以该函数被绑定。
在深度分析它。有时候理解宏观有助于macroezpand使用这个宏*的一个例子。为此,提供一个代表这个宏调用macroexpand函数列表。注意macroexpand只会扩大宏的符号列表的第一个元素,不会扩大你的嵌套调用宏�在下面,我们呢?已经复制一个调用直接从nlet-fact nlet,引用它,并通过它macroexpand:
* (macroexpand * (nlet事实(n (n))(如果(zerop n) 1 (* n (n (- 1))))))
(标签((事实(N)(如果(ZEROP N) 1 (* N (N (- 1)))))) (N)) T
扩大使用标签的特殊形式来绑定一个函数提供了身体。函数是命名根据使用的符号命名让形式。需要作为参数与nlet绑定的值,这里只有n。因为这可以递归函数,nlet实现迭代构造一个有用的。
虽然简单的宏可能只是填写反模板,最复杂的lisp宏至少利用?广泛的列表处理功能。Mapcar,应用一个函数列表中每个元素并返回一个结果列表值,特别是经常出现宏。很明显,mapcar
?术语的扩张实际上是很不幸的。没有说macroexpanding将导致更大的东西,扩展的代码。有时形式甚至扩展到什么(即零)。
*但macroexpand将继续扩大宏观直到第一个元素不再代表一个宏。Macroexpand-1有助于观察这一过程的第一步。
经常出现在常规lisp代码。Lisp已经调到尽可能有用处理列表。在各种各样的lisp编程,包括宏观结构,我们拼接,合并,减少,地图,和过滤列表。唯一的区别是,当编程宏,输出随后被传递给编译器或解释器。lisp编程宏实际上是相同的过程编程定期lisp。
但是是什么意思说nlet是一个新的控制结构?控制结构只是一个幻想的方式描述一些构造并吗?遵循一个函数的行为。一个函数将评估每个参数从左到右,绑定的结果在一个环境中,并执行的机器代码指定的一些λ形式。自从nlet不?t直接评估它的参数,而不是拼接成一些lisp代码的一部分,我们已经改变了流nlet形式的评估,从而创建了一个新的控制结构。
这一宽泛的定义,几乎所有宏?至少所有有趣的宏?定义新的控制结构。当人们说“只使用宏时函数赢了?t做”,他们的意思是,对于任何定义你在哪里?不想评价某些参数,或你想要评估他们的订单,或不止一次,您将需要使用一个宏。功能,无论多么巧妙地写,根本行不通。
nlet宏展示COMMON LISP的方法之一就是为宏观设计的作家。绑定让等形式,它是一种常见的约定为一个变量绑定到零如果没有指定值和变量名。换句话说,((()))将在计划,nil�语言略少macro-writer友好,这种情况下必须检查等特殊情况当遍历绑定,因为(汽车零)和(cdr nil)提高类型错误。(汽车零),COMMON LISP (cdr nil),因此(汽车(cdr nil))和(cadr nil)定义返回nil,允许第二mapcar nlet工作即使空让变量公约。这从Interlisppwrertisr COMMON LisP特性)。
瓹omMON LisP甚至允许我们写(让(a)一个)相同的效果。
我们的nlet宏观不同于计划吗?年代叫允许在一个微妙的方式。在这种情况下,宏观的接口是可以接受的,但可能不是扩张。时是很常见的编程在多个水平,我们的心智模型的代码可以很容易地从现实略有不同。方案,尾部调用一个命名让保证不需要额外的堆栈空间计划以来,由标准,使这个特定的优化。这不是COMMON LISP的情况,然而,它是可能的堆栈溢出发生在我们COMMON LISP的nlet版本不会发生与命名让计划。在5.4节,Code-Walking Macrolet我们将看到如何编写一个版本的nlet相同接口但可能更有效
扩张?。
3.4自由变量
一个自由变量是任何变量或函数表达式中引用并?t全球特殊绑定或封闭词法绑定。在以下表达式,x是免费的:
(+ 1 x)
但在以下,我们创建一个绑定的形式捕获变量x,剥夺了它的自由:
(let ((x 1)) (+ 1 x))
自由的术语和捕获一开始看起来很奇怪。毕竟,自由意味着意识和做决定的能力?一些显然是缺乏一个简单的表达式。但自由吗?t是指表达能做什么,而我们,作为程序员,可以用表达式。例如,我们可以把表达式(+ 1 x)和嵌入任何我们想要的,让我们的表达式来访问一个绑定
“在实践中,这个版本的nlet自COMMON LISP编译器通常是足够几乎肯定会在编译后的代码优化尾部调用。
名为x在周围的代码。然后我们说了我们自由变量的代码。表达式中自由变量捕获后,在上面的表格,其他周围的代码没有选择捕获变量x。我们以前自由变量已经被抓获。现在x,它是指完全明确。正因为如此,不是吗?lisp t任何需要保持参考代码中的符号x。在2.3节中详细描述,词汇和动态范围,lisp编译器会忘记的符号用来代表词法变量。
尽管任何语言表达式可以与自由变量表达式,lisp吗?年代宏观功能意味着自由变量在lisp比其他语言更有用。在大多数语言中我们被迫服从引用透明性。如果没有全球或对象中定义的变量x哭计划,无条件地下面的代码是不正确的:
some_function_or_method(){任何(1 + x);}
没有办法some_function_or_method可以为x。创建一个隐式绑定在哭,任何使用变量必须有一个文本明显定义�与原始宏观系统的语言(如C)可以完成其中的一些非常有限的意义上。但是,正如通用宏是不切实际或不可能写在C语言中,特别涉及自由变量也是如此。
在lisp中我们可以摆布表达式与自由变量请和拼接成新表情,被周围的代码,或定义全球特殊变量来捕获它们。我们也可以写宏修改哪些变量是免费的表达式中,通过重写表达式它有更少的自由变量(说一种让裹,如上所述)或通过修改表达式的方式补充道
8或,有时,在面向对象的哭,一个类或对象的定义。
新自由变量。这样的自由变量的对立面是捕获变量和被称为自由变量注入。
最简单的自由变量注入是一个宏,展开成一个符号引用:
(defmacro x-injector () 粁)
因为一个宏是一个函数,它执行它的身体作为常规lisp的形式。上述喷射器宏观评估引用符号,当然,返回一个标志吗?一个自由变量?拼接到任何表达式使用x-injector宏。讨论这样的自由变量注入Lisp,保罗•格雷厄姆写道
这种词汇交流通常被作为传染源多于快乐的源泉。通常是糟糕的风格编写这样一个宏。村里宏在这本书中,只有(两个孤立的情况下)以这种方式调用环境中使用。
相比之下,这本书从这类词汇获得多少乐趣性交。自由变量注入?编写一个宏与完整的词法知识环境将会扩大吗?只是另一种lisp宏编程的方式,一种是特别有用,当有一些稍微不同的词汇上下文,你想写代码基本一致。虽然经常一个函数调用的主要优势是你扔掉你的词汇的环境,有时候,lisp程序员,这只是一个指导方针,可以忽略通过使用宏。事实上,一旦习惯了它,一些lisp程序员尝试总是编写宏,扩展词汇上下文尽可能使用一个函数只有当他们需要评估参数还是鸡,想要一个新的词汇上下文。3.6节中,我们将看到一个方法,当你需要避免扔掉你的词汇环境参数评估。尽可能保持词汇周围环境允许非常有趣的宏观组合,在一个宏观的词汇补充道
上下文在使用一个或多个其他宏。扩张到代码使用的宏定义是一个特例,宏观组合和处理在5.5节中,递归扩展。
两点之间最短的距离是一条直线。自由变量,更普遍的是,扩展词汇上下文通常是最简单的方法通过编程的方式构建一个程序。以这种方式使用宏可能看起来像一个黑客,并可能会觉得讨厌的理由,但它方便、可靠地工作。特别是在5.4节,我们认为macrolet Code-Walking macrolet,这种风格的编程吗?结合宏?将开始感到更舒适。记住,宏观编程不是风格;它是关于权力。宏允许我们做许多事情,在其他语言中是不可能的。自由变量注入就是其中之一。
3.5意外捕获
有两个观点变量捕获。变量捕获一些非常不可预测的错误的来源,但是如果使用得当也可以高度可取的宏观特性。让吗?年代开始我们考虑用一个简单的宏定义的变量捕获格雷厄姆在Lisp: nif。Nif是一个有四个数字,如果需要的条款,而正则布尔,如果有两个必需的条款和一个可选的第三条款。Nif,或者说Nif扩展到的代码,评估第一条款和假设的结果是一个非复杂的数字。然后评估各自的三个条款,取决于结果是积极的(plusp),零(zerop)或负面(否则)。我们可以使用它来测试变量x一样:
(nif x“积极”“零”“负面”)
Nif是我们讨论的理想函数变量捕获和我们将用它来说明几个要点,也作为一个新的测试用例符号宏建设。在我们现在的版本nif由格雷厄姆,让?定义一个几乎正确,但略车版:
(defmacro nif-buggy (expr pos零底片)
?(让((obscure-name expr))(电导率((plusp obscure-name), pos) ((zerop obscure-name),零)
(t,底片))))
Nif-buggy展开成一个的代码使用让绑定的结果评估用户?年代expr形式提供。我们需要这样做,因为它是评估expr可能会产生副作用,我们需要使用它的价值两个方面:通过zerop plusp并传递它。但是我们称之为临时绑定什么呢?介绍一种微妙的错误我们选择任意符号,obscure-name。除非有人看着宏扩展,没有人会看到这个名字无论如何,所以它吗?没什么大不了的,对吧?
Nif-buggy会出现像nif在几乎所有情况下工作。只要象征obscure-name从未使用的形式提供给nif-buggy�还有没有多余的变量捕获的可能性。但是如果obscure-name出现在形式通过了吗?在许多情况下,仍然没有错误:
(nif-buggy x(让((obscure-name ? pos)) obscure-name)零*底片)
即使x是积极的,即使我们有禁止符号注入nif-buggy吗?年代宏观展开,这段代码仍然按预期的方式工作。当创建一个新绑定,绑定总是把创建的引用内部约束力,没有多余的变量捕获发生。问题只出现在我们使用obscure-name横跨在扩张它的使用。这是一个不必要的变量捕获的例子:
癘r宏展开的形式传递给它。看到sub-lexical范围。
(让((obscure-name ? pos)) (nif-buggy x obscure-name > 0 ?底片)
在这种情况下,obscure-name将绑定到x的评估的结果,所以象征pos与初衷恕不退还!�这是因为我们使用象征了一个看不见的使用的绑定。有时这样的代码与无形的绑定不透明的优先。
但不是吗?这只是一个学术问题?肯定我们能想到的罕见的足够的名字从来没有出现这样问题。是的,在很多情况下,包和智能变量命名可以解决变量捕获的问题。然而,最严重的变量捕捉bug ?t出现在代码直接由一个程序员。大多数变量捕获问题只有表面当其他宏使用宏(结合你的宏)的方式你不?t预测。保罗•格雷厄姆?年代有直接回答为什么来防止不必要的变量捕获:
为什么编写程序用小虫子当你编写程序没有错误吗?
我想我们可以进一步提炼问题:无论多么微妙,为什么东西当你能做到正确不正确?
幸运的是,事实证明,变量捕获,在某种程度上,这是一个问题,是一个简单的解决方案来解决问题。最后一个句子是一个有争议的声明对许多人来说,尤其是那些他们已经决定不?t显而易见的解决方案和有专用的大部分的时间找一个更好的。作为专业的宏程序员你会来到
10米的真理,当然,这车行为的目的是什么。很少有这直接和设计变量捕获问题。通常他们是令人惊讶和微妙。
接触这些变量捕获方案。当前流行的解决方案是使用所谓的健康的宏! !这些解决方案试图限制或消除不必要的变量捕获的影响但不幸的是这样做的,可取的变量捕获。几乎所有方法采取减少变量捕获的影响只会减少与defmacro你能做什么。健康的宏,在最好的情况下,一个新手吗?年代安全护栏;在最糟糕的情况下,他们形成一个带电的围栏上,捕捉他们的受害者在消毒,capture-safe监狱。此外,最近的研究表明,卫生宏观系统指定的各种方案修订仍然可以受到许多有趣的捕获problemsjsywtax-RULES-INSANE] [SYNTAX-RULES-UNHYGIENIC]。
真正解决变量捕获称为生成的符号,或简称为gensym。gensym是lisp的方式为我们选择一个变量的名字。而是像之前那样,我们挑选的名字像obscure-name, lisp好名字。很好的名字。这些名字很好和独特的,没有任何人(甚至gensym本身)会选择同样的名字。这怎么可能?在COMMON LISP,符号(名称)与包相关联。一个包是符号的集合,你可以通过提供的字符串的指针,其符号名的字符串。其中最重要的属性的指针(通常只是称为符号),他们将情商所有其他指针(符号),抬头在这个包中相同的符号名。象征这并是gensym ?t存在于任何包,所以没有可能的符号名,将返回一个象征情商。Gensyms是当你想表明lisp,一些符号应该eq其他符号表达式中什么都不用的名字。因为你是吗?t命名,名称冲突就可以吗?t发生。
所以通过以下三个简单的,非常重要的规则,避免不必要的变量捕获在COMMON LISP很容易:
当你用词汇或动态绑定
吗?另一个流行的术语是“宏的例子”。
在代码提供给您的宏,这个绑定名称与gensym除非你想捕捉它的代码你是包装。
每当你用一个函数绑定或者macrolet symbol-macrolet宏代码提供给您的宏,这个函数或宏名字gensym除非你想捕捉它的代码你是包装。验证这个绑定并吗?t冲突与任何的特殊形式,宏,或函数定义的标准。
不分配或re-bind特殊形式,宏,或由COMMON LISP函数指定。
一些除了COMMON LISP,纷纷扬扬地喜欢计划,有不幸的属性相结合的变量名称空间与功能/宏名称空间。有时,这些被称为lisp-1蹑地,COMMON LISP,单独的名称空间,称为lisp-2 LISP。假设lisp-1 COMMON LISP我们也会不得不构建宏时遵循这两个额外的规则:
验证故意引入词汇或动态绑定不撞上故意引入函数或宏绑定,或任何的特殊形式,宏,或函数定义的标准。
验证故意引入函数或宏绑定不撞上故意引入词汇或动态绑定。
COMMON LISP吗?年代明智的设计决策分离变量名称空间的函数名称空间消除整个维度的变量捕获问题。当然lisp-1地不受任何创造宏观理论障碍:如果我们遵循前面的两个规则,我们可以避免变量捕获COMMON LISP的我们所做的一样。然而,当编程复杂的宏很难追踪
符号在一个单一的、孤立的名称空间。有任何crosspollination名字考虑使宏观写作比它需要更加困难。
比可能不完整的标准以外的任何其他财产! ?,正是这种缺陷的单个名称空间使得计划,一个优秀的语言,不适合严肃的宏观建筑! ?。理查德·加布里埃尔和肯特皮特曼总结的问题以下难忘quoteuisr2-au1FEy:
有两种方法可以查看参数对宏和名称空间。首先,单一名称空间是基本的重要性,因此宏是有问题的。第二,宏是根本,因此单个名称空间是有问题的。
因为有比名称空间的数量少的重要性,和小的重要性超过允许的宏,它只能得出结论,计划做出了错误的决定,COMMON LISP的决定是正确的。
不过,叫gensym每一次我们想要一个无名的象征是笨重,不方便。难怪方案设计师尝试所谓的卫生宏观系统,避免到处gensym类型。错误的把计划是促进一个领域特定语言宏观建设的目的。而计划?迷你语言无疑是强大的,它忽略了整个宏点:宏是伟大的,因为他们是用lisp写的,不是低能预处理程序语言。
这本书提出了一种新的语法gensyms brevity-conscious应该更美味的但仍是一个薄膜相对于传统lisp表达式。gensyms我们的新符号,我们将使用为基础的宏在这本书中,最明显的层被剥离
特别相关的宏和例外。18但在本书中我们将看到,有很多理由选择COMMON LIsP而不是计划。
简单宏使用符号给予我们的特性。让吗?年代继续nif前一节的例子。这是格雷厄姆是如何定义一个capture-safe nif:
(defmacro nif (expr pos零底片)(((g (gensym))) ?(让((g, expr))(电导率((pos plusp g)) ((zerop g),零)
(t,底片)))))
这是如何正确使用gensym。正如我们在前一节中,看到一个宏,可以扩大用户输入的东西可能会干扰一个变量对变量捕获必须小心。格雷厄姆提出了宏观缩写withgensyms更简洁的情况下,需要创建许多gensyms:
(with-gensyms (a b c))
扩展到
(let ((a (gensym)) (b (gensym) ) (c (gensym)))
——)
因为需要gensyms defmacro形式是如此普遍,我们决定进一步追求缩写。特别是,请注意,我们必须为每个类型的临时名称gensyms(像a、b和c)至少两次:一次当我们再次声明它gensym,当我们使用它。我们可以消除这种冗余吗?
首先,考虑如何使用gensyms nif宏。当nif宏扩展,它调用gensym返回生成的象征。因为这是保证独特的象征,我们可以安全地拼接成宏扩展知道它永远不会捕捉任何意想不到的引用。但是我们仍然需要的名字
gensym宏的定义我们可以拼接成扩张在正确的地方。格雷厄姆,nif宏定义的范围,这个名字gensym g。注意这个名字从未出现在nif宏扩展:
* (macroexpand ?(nif x ?pos ?zero ?neg))
(让((#:G1605 X))(电导率((PLUSP #: G1605) ? POS) ((ZEROP #: G1605)癦ERO)
(T ?NEG)))
这个名字在宏扩展g消失。因为g只绑定在我们的扩张器环境中,这样的一个变量的名字是无关紧要的对捕获的扩张。出现的所有g,在扩张,取而代之的是一种象征G1605打印名字。前缀是#:因为象征不是囚禁在包吗?这是一个gensym。当打印形式,有必要前缀gensyms以这样一种方式,因为我们希望打破如果我们用lisp(评估)这种形式在阅读它回来。我们希望lisp休息因为我们可以吗?不知道通过查看打印的名字两个gensyms如果他们应该情商吗?这是他们的目的。Lisp休息在一个有趣的方式:因为每次#:符号是在创建一个新的符号,因为(eq ? #: ? #: 1)从来都不是真的,内部#:G1605符号在上面的扩张不让表单创建的引用绑定Lisp认为表达自由变量,指示我们,表单与gensyms读回来。
尽管这样的默认打印行为uninterned符号,仍然可以保存并重新加载宏展开。更准确的印刷表示与gensyms形式,我们可以打开* print-circle *模式打印结果! *:
我们返回t这样我们就?t看到返回的形式打印。(返回值)也很常见。
清单3.5:G-BANG-SYMBOL-PREDICATE
(defun g !-symbol-p (s)(和(symbolp s)(>(长度(符号名的s)) 2)(字符串=(符号名的年代)“蒙古包:starti 0: endi 2)))
*(让((* print-circle * t))(打印(macroexpand ? (nif x pos ?零?底片))))
(让((# 1 = #:G1606 X))(电导率((PLUSP # 1 #) ? POS) ((ZEROP # 1 #)�0) (T ?底片)))
在上面的表格中,lisp打印机使用# = # #读宏。这些阅读宏允许我们创建自我参照的表单,我们将更深入地讨论在4.5节中,循环表达式。如果我们读在上面的表格中,内部会使用的符号一样让绑定中使用的符号和扩张仍然工作。上面的定义似乎避免了dual-naming冗余。有没有一种方法我们可以把这个退到宏观宏观写作模板吗?
记住我们的名字gensyms任何宏定义,甚至像格雷厄姆,简单的名称,如g和宏扩展他们将会消失。因为这种自由命名,让?年代标准化gensyms的命名约定。简洁和独特性之间达成妥协,任何符号,从两个字符开始G !至少,紧随其后的是一个字符被认为是一个特殊的gensym引用符号称为G-bang符号。我们定义一个谓词,g !-symbol-p,决定是否一个给定的谓词
清单3.6:DEFMACRO-WITH-G-BANG
(defmacro defmacro / g !(名称args kr身体)(让((信谊(删除重复值(remove-if-not # ? g !-symbol-p(扁平的身体)))))* {(defmacro,名字籥该公司(让(mapcar(λ(s) * (s (gensym, (subseq(符号名的s) 2))))信谊)籃身体))))原子是一个G-bang象征。
现在我们已经G-bang符号标准化,我们可以创建一个宏,宏定义写道,利用宏观写作快捷方式被称为自动gensyms。宏defmacro / g !域定义了一个领域特定语言的宏观写作,但设法保留所有lisp吗?年代的权力。Defmacro / g !很简单,但是如何使用它,和它是如何工作的,可能不明显。因为这个,因为这是我们的第一个真正的宏?已经呈现在这本书中,我们将分析defmacro / g !缓慢。
解剖任何宏时,第一步是停止。唐?t认为宏观语法变换或任何其他这种无稽之谈的抽象。认为一个宏是一个函数。下面一个宏是一个函数,在完全相同的方式工作。未鉴定的表达式给出的函数作为参数提供,预计返回lisp代码插入到其他表达式。
因此,思考defmacro / g !作为一个函数,考虑其执行。因为我们是lisp编程一个普通函数,我们可以访问所有lisp吗?年代特征,甚至事业吗?由于添加到语言。在defmacro / g !,我们使用格雷厄姆?平效用,lisp ?年代remove-if-not和删除重复值函数,我们G-bang象征谓词g !-symbol-p创建一个新的列表
包含所有G-bang符号体内发现的形式,通过我们的宏。接下来,我们使用一个反模板返回一个列表代表我们希望宏扩展的代码。在我们的案例中,因为我们吗?defmacro重新编写一个改进,我们希望扩大我们的代码defmacro形式本身。但我们添加新的便利功能defmacro语言和希望创建一个更为复杂的扩张。为了给每个G-bang符号在宏吗?身体一个新鲜gensym,我们使用mapcar映射函数收集G-bang符号列表,创建一个新的列表,可以拼接成让形式,建立每个gensym绑定”,
注意我们地图包含的lambda表达式创建反算子,从而似乎是什么?但不是吗?一个嵌套反的情况。因为mapcar应用这个函数是非上市、非挂牌表达式的嵌套反仍在评估我们最初的上下文。嵌套反是出了名的难以理解,我们将回到这个概念当我们看反更深入地在第4章,读宏。
那么,究竟,defmacro / g !让我们做什么?它让我们利用这个技术自动gensyms,检查特定的符号的存在的一种方式在代码的词法作用域提供宏!如果我们不�?不使用任何G-bang符号,我们可以用defmacro / g !defmacro完全一样。但任何G-bang符号出现在身体宏扩展的解释为:
我想要一个gensym绑定在这个表达式,和我吗?已经考虑到符号。让它发生。
我们可以使用它来拯救必须显式创建一个gensym nif”中:
gensym函数可以被传递一个字符串参数。这个改变gensym吗?年代打印名字有助于阅读扩张。Defmacro / g !使用G-bang符号的打印字符的名称。
16这是,现在,简化。看到部分sub-lexical范围。
(defmacro / g !nif (expr pos零底片)
?(让(g !因此,expr))(电导率((pos plusp g !结果))((zerop g !结果),0)
(t,底片))))
当我们想使用gensym我们只是使用它。我们需要小心,当然,所有引用G-bang符号仅仅是根据宏扩展,因为这是唯一的地方gensym将绑定! ?。结束G-bang符号出现在一个反,如上图,是最明显的方法,我们可以看到的直接“平行象征g在格雷厄姆?年代nif的原始定义。
我们有一个宏定义nif似乎函数格雷厄姆的一样吗?,但这几乎改善似乎好得令人难以置信。它真的有效吗?让吗?年代宏扩展!�前我们决定:
* (macroexpand-1 > (defmacro / g !nif (expr pos零底片)?(让(g !因此,expr))(电导率((pos plusp g !结果))((zerop g !结果),0)
(t,底片)))))
(DEFMACRO NIF (EXPR POS零底片)(((G !结果(GENSYM "结果")))?(让(G !因此,EXPR))(电导率((p0 PLUSP G !结果))((ZEROP G !结果),0)(T,底片)))))
看来defmacro / g !本质上相同的代码,格雷厄姆写道,当他写nif的原始版本。看到
17 g-bang符号尤其是不?出现在扩张本身?这正是我们试图避免与gensyms。
18我们使用macroexpand-1所以我们只有扩大defmacro / g !宏观而不是defmacro它扩大到。
荷兰国际集团(ing)这个例子使用defmacro / g !,我们发现没有non-gensym绑定将创建扩展。Nif,定义defmacro / g !从变量捕获问题,是免费的。
但由于defmacro / g !本身就是一个宏,它是可能的,可能会有意外捕获或替换问题宏扩展环境?与任何足够复杂抽象,行为,在某种程度上,任意的。在同样的意义上,变量捕获本身是一个缺陷,某些属性defmacro / g !这可能似乎固有缺陷可能仅仅是它的设计!�一如既往,最好的解决方案是完全理解抽象。
一个有趣的个别案例defmacro / g !在G-bang宏定义G-bang宏。所有defmacro / g !是一组绑定引入到扩张的环境,每一个都是绑定到gensym宏可以使用,如果它想要的。在这种情况下,有多种可能性的gensym可以束缚,他们总是因为上下文的。换句话说,你可以指定哪个环境?年代gensym你应该根据使用环境评价。下面的例子:
(defmacro / g !junk-outer () ? (defmacro / g !junk-inner() ?(让((abc), g !)籫tabc)))
这里有两个gensyms创建。g的使用!abc是之前只有一个结束(逗号)所以我们知道创造的扩张是指内部gensym junk-inner的扩张。如果都有两个结束,他们会参考外gensym由junk-outer的扩张。
Defmacro / g !使用格雷厄姆?年代平功能。平,如1.3节所述,Lisp效用,采用树结构缺点?我们的lisp代码吗?并返回一个新列表的所有叶子/原子。利用平defmacro / g !是一个简单的
尽管它从来没有安全排除程序员的错误。
code-walking的例子,一个主题,我们将重新审视在这本书。
练习:在上面的G-bang宏定义G-bang宏,如果第一个问题是什么gensym前缀是一个结束,另一个是与两个前缀?
3.6一次只
Peter Norvig是一个杰出的程序员和作者。对人工智能书,尤其是人工智能:现代Approachtama \阅读之前需要解决许多我们目前面临最困难的问题是计算机科学家。Norvig更有名的lisp程序员是为他的书《人工智能编程的范例:案例研究共同点LisPipar]。这本书是过时,但仍必读严重lisp学生和包含许多重要的lisp的见解? ?。本节致力于Peter Norvig甚至PAIP中描述一个宏的名字命名的。在最后几页,藏在一个序列的描述函数实现,
曾经只有:一个教训在烦冗后不久的一个更有趣的句子:
[我| f您可以了解如何编写使用只有一次,然后你真正理解宏。
正如我们现在所知道的,没有人真正理解宏。理解一个特定的宏,甚至一个曾经只有一样重要,让你不再理解宏比理解让你真正理解数学的一个重要定理。因为到目前为止似乎无限的可能性,真正理解数学或宏确实是不可能的。
20一个比特的Common Lisp的建议PAIP永久真的是永不可选和关键参数λ或defmacro解构形式。这将咬你!
我们不会给Norvig的定义吗?年代曾经只有在这里,但这是一个相当复杂的宏观一些有趣的特性,我们将实现略有不同。曾经只有最初编写为死者lisp机编程环境,排除COMMON lisp原因无关紧要。
曾经只有背后的想法是围绕一个宏扩展的代码将创建一个新绑定。当评估宏扩展,这个绑定将初始化与评估的结果的形式传递给宏作为参数。曾经只有的身体中的代码可以使用绑定的,当然,不重新评估的形式传递给宏。表单作为参数传递给宏只和总评估一次。只有一次。
作为曾经只有的一个例子,Norvig显示一个正方形宏。其扩张接受一个参数并返回的产品参数与本身:
(defmacro广场(x) ? (#, x, x))
这将工作当我们通过很多事情:大部分变量,数字,和其他形式,可以自由地根据需要多次计算。但一旦形成,调查被传递给这个版本的广场,前景难测。行为,当然,仍然确定,但可以肯定很难确定。与这个特定的宏,表单将评估两次。很快但是因为这些事情变得复杂,在一般情况下,所有的赌注都关闭。使它方便和容易避免这些不必要的副作用来说只有一次。请注意,如果我们使用一个函数,我们免费获得这种行为。我们离开后的土地的教科书式的例子,来参加我们的感官,和广场定义为一个函数,它最终看起来像这样:
(defun广场(x)
(* x x))
因为λ是如何工作的,我们可以使用任何形式作为广场的这个函数的参数定义。因为这个论点将评估一次,我们的观念和概念模型的副作用感到满意。在大多数情况下我们期望一个表达式?只写一次只计算一次。相反,一个宏的主要力量之一是违反这个假设通过操纵评估的频率和顺序。在诸如循环,例如,我们可能想要不止一次计算表达式。我们甚至可能希望他们从未被评估,因为我们想从他们说不是他们的评价。
曾经只有允许我们指定特定的参数在宏扩展,我们想只能评价一次,评价的顺序从左到右,就像λ。这里是如何做到这一点与传统onceonly宏:
(defmacro广场(x)(曾经只有(x)
?(* x ,x)))
当然如果你曾经想做的一切就是曾经只有所有参数的宏,您将使用一个函数(λ)。我们将返回到这一点,但因为这本书吗?曾经只有t供应直接实现,我们引入一个宏观符号交替实现此功能。尽管有许多有趣的一次实现)yrrarp-pss3 | [PRACTICAL-CL-P95],本节引入了一个新的技术涉及结合defmacro / g !。
我们的曾经只有实现的第一步是创建一些新谓词和效用函数。再次妥协简洁与独特性,我们保留另一组符号为我们自己所用。所有从符号字符0 !,紧随其后的是一个或多个字符被称为O-bang符号。
一个谓词区分O-bang符号与其他对象定义:o ! -symbol-p。它的定义是几乎相同的g ! -symbol-p。我们还将介绍一个方便的效用函数
清单3.7:O-BANG-SYMBOLS
(defun o !-symbol-p (s)(和(symbolp s)(>(长度(符号名的s)) 2)(字符串=(符号名的年代)“orm: starti 0: endi 2))) (defun o -symbol-to-g !符号(s) (symb“肠胃”(subseq(符号名的s) 2)))清单3.8:DEFMACRO-BANG
(defmacro defmacro !(名称args kr身体)(让* ((os (remove-if-not # ?啊!-symbol-p args)) (gs (mapcar # ? o -symbol-to-g !符号操作系统)))? (defmacro / g !、名称、参数?(让(mapcar # ?列表(列表,@gs)(列表,@os)),�progn, @body)))))
改变成G-bang O-bang象征符号,保留爆炸后的字符:啊! -symbol-to-g !符号。该效用函数使用格雷厄姆?年代的效用函数symb创建新的符号。
Defmacro !代表我们的宏定义语言的最后一步?它增加了一个曾经只有特性。Defmacro !结合defmacro / g !从上一节。因为defmacro !直接扩展到defmacro / g !形式,它继承了自动gensym行为。理解各个部分组合是必不可少的复杂组合。回想一下,defmacro / g !寻找从G-bang开始,自动创建gensyms象征。通过扩大与G-bang形式符号,defmacro !可以避免重复gensym行为实现来说只有一次。
Defmacro !给出了一个快捷方式被称为自动来说只有一次。自动曾经只有我们可以前缀符号的一个或多个
在宏观赤身裸体?O-bang s参数,使它们O-bang定义的符号啊! -symbol-p。当我们这样做时,defmacro !会知道我们的意思是在生成的代码将创建一个绑定,当评估,包含评估的结果作为参数提供的代码的宏。这个绑定将可以通过gensym宏扩展。但在创建这个gensym扩张如何引用?通过使用上面定义的等效G-bang符号o ! symbol-to-g !符号。
的实现依赖于功能defmacro / g !。与o -symbol-to-g !象征效用,我们创建新的G-bang符号添加到defmacro / g !的形式。一旦我们有了自动gensyms,曾经只有很容易实现,就是明证的简洁defmacro !定义。
回到陆地的教科书的例子,我们将重新实现宏广场,这次defmacro !:
(defmacro !平方(o ! x) ? (* g !x, g ! x))
我们可以macroexpand:
* (macroexpand(平方(incf x)))
(让((#:X1633 (INCF X))) (X % * #: 1633 #: X1633)) T
在前一节中我提到的,我们通过一个字符串值为所有G-bang gensym符号。这使得研究的扩展形式更加容易。虽然没有什么重大的名字gensyms像#:X1633,如果我们写作或调试defmacro !广场上面的定义,我们可以直接看到这个符号与符号之间的联系中使用宏定义:x能够匹配符号从定义到扩张,反之亦然是容易得多
如果这个信息是保存的打印名gensyms使用,在defmacro / g !扩张?。
除了少详细用法和更有帮助扩张输出相比传统曾经只有defmacro !还提供了一个额外的关键特性。在传统来说只有一次,gensym的绑定创建的用于访问词法变量是相同的名称作为参数宏扩展,这阴影宏观参数,所以它不能访问的宏定义。因为defmacro !分裂成两个不同类型的符号,G-bang符号和O-bang符号,我们可以编写宏扩展,使用这两个值。为了说明这一点,这是另一个广场的宏定义:
(defmacro !广场(o0 ! x) ?t”[(progn(格式?给~ ~ %”?,olx = g ! x) (*, gix, g ! x)))
可以使用如下所示:
* (defvar x 4)
xX
*(平方(incf x)) [CINCF x)给5]25
请注意,我们引用非上市O-bang符号在上面的广场的定义。我们这样做是因为我们吗?不想再次评估这种形式。生成的扩张defmacro !已经评估了。我们只是想要传递给广场的形式和使用另一个目的,在这种情况下,一些原油调试语句。然而,即使我们评估
1这也是原因的数量打印名gensym,规定* gensym-counter *。此计数器让我们区分gensyms实例相同的打印的名字。
清单3.9:NIF
(defmacro !nif (olexpr pos零底片)?(电导率((pos plusp g ! expr)) ((zerop gtexpr),零)
(t,底片)))
一次,在这种情况下这是不正确的,没有什么阻止我们再次评估提供的形式,应该需要的抽象需求。
defmacro !语言让我们颗粒,方便控制的评估参数传递给我们的宏。如果我们前缀的所有符号代表参数与O-bang宏定义,并只使用相应的G-bang符号在宏定义中,我们的扩张将lambda表达式的一样吗?每个表单评估一次,在从左到右的顺序。没有任何这些符号的arg游戏和不使用任何G-bang符号在扩张,defmacro !就像普通COMMON LISP defmacro行为。
Defmacro !在迭代开发是最有用的一个宏。因为它是一个简单的两个字符添加到一个宏观参数λ风格评价,并使用gensyms一样容易,写他们,我们立即对这些决策可以改变我们的思想。Defmacro !感觉合适的手套/λ更紧张比COMMON LISP吗?defmacro。正是因为这一原因,迭代开发,我们将使用defmacro !作为主要的宏定义接口在这本书的其余部分。
让吗?回到格雷厄姆?年代nif宏。当更新这个宏defmacro !,我们注意到expr论点,我们创建了一个gensym,是准确评估一次。在这里,我们使用defmacro !表明这个观点应该评估只有一次通过调用它啊! expr。这个实现nif代表我们这个宏的进化的最后一步。
Defmacro !模糊了宏和函数之间的差距。正是这种特性,能够提供一些O-bang符号在宏观参数和一些常规的符号,使
defmacro !尤其有用。正如反可以翻转默认引用行为,defmacro !允许你翻转的评价语义宏观参数与普通未鉴定的宏观形式单独评估,从左到右λ参数。
3.7二元性的语法
lisp的一个最重要的概念是称为二元性的语法。了解如何使用二元性和他们为什么重要的是宏观的潜在主题写作和这本书。二元性有时设计,有时偶然发现。程序员non-lisp语言现实的双重语法太令人难以置信的在书中描述在这一点上我们将暂时回避直接定义。读者,相反,你会发现它一次又一次地慢慢地小心地应用,以免冲击。你应该经历头痛或其他不适通过这本书,我建议你立即执行一个垃圾收集周期(得到一些睡眠),然后返回一个新鲜的和开放的心态。
引用透明代码有时定义为财产任何表达式都可以插入任何地方,总是有相同的意义。引入语法双刀是引用透明性和发现他们的有意识的违反是收获果实的一种语言,使这样的侵犯。而其他语言只有让你建立一块半透明的玻璃,lisp允许您使用各式各样的烟雾,后视镜,和棱镜。魔法尘埃的宏,大多数最好的技巧是基于句法双刀。
本节描述一个重要的双语法我们已经讨论过,但还没有完全探索:COMMON LISP使用相同的语法来访问这两个主要类型的变量,动态和词汇。这本书试图说明动态和词法作用域的真正力量和COMMON LISP的原因吗?年代决定使用双语法是很重要的。
动态范围的目的是提供一种获取值的lisp表达式基于表达式
是评估,而不是定义或编译。碰巧,谢天谢地,COMMON LIsP的语法定义了因为这是相同的,用于访问局部变量,动态变量的完全相反的,他们总是把位置编译,当访问发生独立的。事实上,没有外部环境的形式声明,你可以吗?t告诉一个表达式指的是哪种类型的变量。这种双重违反语法引用透明,但而不是避免,lisp程序员欢迎这是因为正如您可以吗?t微分表达式没有上下文,也不能一个宏。有这种想法。首先,它必须明确表示,创建绑定动态变量不会创建词法闭包。作为一个例子,让?年代re-bind变量temp-special早些时候我们特别声明:
*(让((temp-special ?不管))(λ()temp-special))
# <解释功能>
尽管这是一个让/λ,这不是一个词法闭包。这是一个简单的评估λ宏观形式在一些动态上下文,结果,当然,一个匿名函数。这个函数,应用时,将访问任何当前的动态环境中存在和获取temp-special的价值。当λ宏观评价,动态绑定的temp-special象征无论存在,但谁在乎呢?记住,λ形式不变对象,只是简单的机器代码的指针回击者,所以评估这个λ形式甚至从来没有访问动态环境。我们的符号无论会发生什么变化?lisp是评估λ的形式完成的,之后删除它从动态环境和弃之而去,未使用的。

实现的东西称为意大利面条stacktspacnertsSTACKS] [INTERLISP-TOPs20]。这个数据结构不再是一个堆栈数据结构,但实际上多个路径,垃圾收集网络。COMMON LISP做了意大利面条栈和只提供词汇closuresmacarony。
所以词汇和动态变量实际上是完全不同的,理所当然地截然不同的概念,只是碰巧在COMMON LISP代码共享相同的语法。为什么我们希望这种所谓的二元性的语法呢?答案是微妙的,只有有意识地升值少数lisp程序员,但它是如此基本,值得仔细研究。这种双重语法让我们编写一个宏,有一个通用的接口来创建有用的扩展动态和词汇上下文。尽管扩张的宏观的意义是完全不同的背景下,尽管每个可以下面的意思是完全不同的东西,我们仍然可以使用相同的宏观和相同的组合与其他宏这个宏。换句话说,宏可以矛盾不仅他们的宏参数的内容,而且对不同的含义的扩展。我们可以用宏观的理解代码转换,忽略代码的语义含义,因为我们使用的代码只有一次有意义的地方呢?它没有意义在宏观处理。二元性语法越多,越强大的一个相关的宏。更多的例子双语法的优点是通过这本书详细。动态和词汇之间的对偶变量是一个温和(但有用的)例子lispy哲学。一些宏创建的特定目的有强大的双刀,有时有很多超过两种含义的扩张。
传统的大会上常见的LISP代码是前缀和后缀用星号字符特殊变量的名字。例如,我们可能吗?已经选择的名字temp-special变量* temp-special *。自本公约就像是有了另一个名称空间动态变量,减少他们的二元性与词法变量,这本书不会严格地遵守它。
星号只是约定,幸运的是,COMMON Lisp不实施。不仅我们能离开星号特殊的变量名,但我们可以将它们添加到词法变量名。也许这是一个风格的问题。这是一个较小的时尚犯罪:词法变量用星号或特殊变量没有?我倾向于认为越详细。同时,gensyms词法和特殊变量的名字,一个概念超越印刷符号上的名字。
所以,正如前面提到的,这本书劫持通常的星号代表大会。而不是
星号表示特殊变量的变量名。这本书使用
星号变量名称显示特殊变量定义的标准。
我的最大动机下降这些变量名耳套是简单的和主观的:我认为他们讨厌的类型和使代码看起来丑陋。我不会走这么远来为自己的项目,建议你这样做只是提到我多年来一直离开了耳罩,COMMON LISP感到非常满意。
