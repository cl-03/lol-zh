第1章介绍
1.1宏
Lisp吗?年代核心占据了一些空间局部最优的编程语言。
?约翰·麦卡锡措辞温和,lisp的发明者
这是一本关于编程宏lisp。与大多数编程书籍,只有给他们一个粗略的概述,这本书是一系列的教程和例子旨在让你编程复杂的宏尽可能有效和迅速。掌握宏毕业的最后一步是一个中间lisp程序员一个lisp专业。
宏lisp的最大优势是一种编程语言,任何编程语言的最大优势。你可以与他们做你不能做的事在其他语言。因为可以使用宏lisp转换成其他编程语言,程序员获得经验与他们发现所有其他语言只是lisp的皮肤上。这是大问题。Lisp是特殊的,因为它实际上是编程程序在一个更高的水平。在大多数语言发明和实施句法和语义规则,lisp是通用和可塑的。用lisp,你制定规则。
Lisp更丰富,更深层的历史比所有其他编程语言。一些最好的和最聪明的计算机科学家在我们?年代短暂的存在已经很难让它有史以来最强大的和通用的编程语言。Lisp也喜欢简洁的标准,多个优秀的开源实现,更宏观的便利比任何其他的编程语言。这本书只使用普通LIsPranst-crictrt2),但许多想法都是平凡地移植到其他地像Schemerrsrs)。也就是说,希望这本书能说服你,如果你想写宏,COMMON LISP是使用LISP。虽然不同类型的lisp是优秀的用于其他目的,COMMON lisp是当之无愧的首选工具宏专业。
COMMON LIsP的出色工作的设计者在设计一种编程语言。特别是在考虑实施质量,COMMON LISP,令人惊讶的是一些保留意见,到目前为止最好的现代程序员的编程环境。作为程序员你可以几乎总是指望COMMON LIsP做它应该做的。虽然它吗?年代真正的设计者和实现者所做的正确的方式,我们觉得他们忘了描述一些为什么吗?年代。许多局外人COMMON LISP看起来就像一个巨大的收集奇怪的特性,因此被关闭,搬到一个更直接的可喜的语言?注定永远不会经历的真正威力宏。虽然它不是主要目的,这本书可以作为旅游的许多最好的特性令人惊叹的CoMMON Lisp语言。大多数语言被设计为易于实现;COMMON LISP是设计成强大的程序。我衷心希望COMMON LISP的创造者欣赏这本书的最完整和可以治疗的语言?高级宏观特性,也是一个有趣的沧海一粟宏观的话题。
不是偶然,宏lisp几乎一样多的历史本身,被盖Hartimacro-permirions} 1963年发明。然而,宏仍不习惯“无限可能”的程度,大多数lisp程序员和被其他不使用
程序员。这对先进lispers一直是一个难题。由于宏是如此之大,为什么不呢?每个人都使用它们?虽然它吗?年代最聪明,最有决心的程序员总是在lisp宏,最终几开始自己的编程生涯。理解为什么lisp宏太大需要了解其他语言也? t。它需要了解其他不那么强大的语言。可悲的是,大多数程序员失去后会学习他们已经掌握了一些其他语言,从不让它接近理解宏是什么或如何利用。但程序员的最高百分比在任何语言总是被迫学习某种方式编写写程序的程序:宏。因为它是最好的语言编写宏,最聪明和最坚定、最好奇的程序员总是在lisp结束。
虽然程序员的最富必然是少数,总体规划人口增长数量最富的程序员也是如此。编程世界看到一些例子的力量宏和了解更少,但这种情况正在改变。由于生产力的乘法,可以通过宏,宏观的时代已经到来,世界是否准备好了。这本书的目标是成为一个基线准备不可避免的未来:一个宏的世界。做好准备。
周围的传统智慧宏仅在必要时使用它们,因为他们很难理解,包含极其微妙的bug,并限制你可能出人意料的方式如果你觉得所有的功能。这些是吗?t lisp宏系统本身的缺陷,而是宏观规划的一般特征。与任何技术一样,越强大的工具,更多的方法有滥用它。至于编程结构,lisp宏是最强大的工具。
一个有趣的并行学习宏lisp是学习C编程语言的指针。最开始的C程序员能够迅速捡起大部分的语言。功能、类型、变量、算术表达式:都有paral
lel初学者可能有在以前的知识经验,从小学数学实验与简单的编程语言。但大多数新手C程序员碰壁时指针。
指针是经验丰富的C程序员的天性,大多数人认为他们完全理解所需的正确使用C,因为指针是如此基本,最有经验的C程序员不会建议限制他们使用文体或学习目的。尽管如此,许多C初学者觉得指针是一个不必要的并发症,避免使用,导致了FORTRAN在任何语言症状有价值的语言功能被忽视。这种疾病是无知的语言?年代的特性,而不是可怜的编程风格。一旦功能完全理解,正确的风格是显而易见的。一个辅助这本书的主题,适用于任何编程语言,在编程中,风格不是直接去追求的东西。风格只有理解在哪里失踪!是必要的。
像C指针,宏lisp的特征,往往知之甚少,智慧在其正确使用很分布式和理想化。如果在考虑宏你发现自己依靠文体格言
宏lisp代码的语法变化。宏程序的解析树。只使用宏函数时赢了?t。
你可能缺少大局时宏编程。这就是这本书希望修复。
很少有好的引用或教程宏观建设。保罗•格雷厄姆?年代Lispjon-tisp)是一个例外。每一个字的Lisp是对感兴趣的人必读的宏。在Lisp和格雷厄姆?其他的作品是最
1一个推论是,有时候唯一途径有效地使用你的东西?t理解观察到其他地方复制样式。
重要的灵感创造你现在读的那本书。由于保罗•格雷厄姆和其他lisp作家宏提供程序员广泛讨论的权力,但不幸的是仍然广泛的误解。尽管智慧有关宏观编程,可以从一个简单的熟读Lisp,很少有程序员使宏观之间的联系和他们的实际编程问题。同时,Lisp将向您展示不同类型的宏,这本书将告诉你如何使用它们。
宏观写作是一个反思和迭代的过程。所有复杂的宏来自简单的宏,经常通过一长串improvement-test周期。什么?年代,识别应用宏是一个可以后天习得的技巧,直接来自编写它们。当你编写一个程序,你,作为一个有意识的人,是后一个系统和一个流程你是否意识到这一点的。每个程序员都有一个编程工具如何工作的概念模型和创建代码是一个直接的、逻辑的结果。一旦一个聪明的程序员开始认为编程的行为是一个逻辑过程,这个过程的合乎逻辑的下一步是受益于自动化本身。毕竟,这个程序员训练:自动化流程。
理解宏的至关重要的第一步是要认识到,没有周密的计划和许多的努力,大部分的程序将散落在冗余模式和僵化的抽象。这可以在几乎所有的大型软件项目视为重复代码或代码,不必要地复杂,因为正确的抽象不是吗?其作者t。宏需要识别的有效使用这些模式和抽象,然后创建代码来帮助您的代码。是不够了解如何编写宏;一个专业写宏lisp程序员需要知道为什么。
C程序员是lisp经常会犯的错误是假设一个宏的主要目的是提高代码在运行时的效率。而宏通常是非常有用的对于这个任务,目前最常用的宏
2 c程序员犯这种错误,因为他们是用来“宏观系统”,很好。
编程所需的应用程序更容易的工作。因为大部分的模式在大多数程序是多余地复制和抽象的普遍性不充分利用,适当设计的宏可以使节目表达新飞机。在其他语言过于僵化和具体,lisp是流体和通用的。
这本书不是一个lisp的介绍。主题和材料的目的是专业程序员的non-lisp语言好奇宏能提供什么,以及中间lisp的学生准备学习lisp独特魅力。基本假定中间lisp编程的知识,而是一种深刻的理解闭包和宏。
这本书也不是关于理论。所有例子都涉及工作,今天可用的代码,可以帮助提高你的编程,现在。这本书是关于使用高级编程技术来帮助你计划好。与许多其他编程书,故意使用一个简单的编程风格,以提高可访问性,这本书的观点是:最好的方法教学语言的编程是充分利用。尽管许多所提供的代码示例使用COMMON LISP的深奥的特性,这样可能不熟悉的特性描述为使用它们。校准,如果你有阅读和理解�一切在第二章,闭包和第3章,宏观基础,对于这本书的目的,可以认为自己过去的lisp的中间阶段的理解。
lisp是发现自己的一部分,这本书不会剥夺你的。被警告说,这本书比大多数人更迅速地移动,比你可能会更快。了解这本书的一些代码,您可能需要咨询其他COMMON LIsP教程或引用。我们覆盖了基础后,我们将直接进入解释一些最先进的宏观研究装备,大型接壤,未知的灰色,知识领域。所有高级宏观编程一样,本书重点关注的组合
当然,3不一定同意。
的宏。这个主题有一个可怕的声誉和很好理解一些,如果有的话,程序员。宏的组合代表最广大和肥沃的今天在编程语言的研究领域。学术界挤出最有趣的结果的类型,对象,和prolog-style逻辑,但是宏观编程仍然是一个巨大的,巨大的黑洞。没有人真正知道之外。我们所知道的是,是的,它是复杂的和可怕的,目前似乎无限的潜力。不像其他太多的编程思想,宏既不生产无用的理论刊物的学术概念,也不是一个空的企业软件术语。宏是一个黑客吗?最好的朋友。宏程序让你变得更聪明,而不是更辛苦。大多数程序员来理解宏决定他们再也不会想程序。
虽然大多数lisp写书是lisp更受欢迎,我完全不关心lisp ?年代日常公共上诉。Lisp是吗?t消失。我将非常高兴如果我能继续使用lisp的秘密武器的其余部分我的编程生涯。如果这本书只有一个目的,那就是激励的研究和研究宏,正如我一直受他们Lisp。我希望这本书的读者也可以启发,有一天我可以享受更好的lisp宏工具和更有趣的lisp宏书。
仍然在lisp的敬畏?年代的权力,
你的卑微的作者,
道格·霍伊特
1.2 U-Language
自讨论宏涉及讨论讨论本身,我们需要很清楚约定我们采用这本书。现在我写信,向你所阅读和解释,本身就是一个系统的表达价值和分析正式化。
没有人明白这一点比Haskell Curry的基础数学Logicjrounpations]的作者。咖喱,因为他不仅是在正式的想法,但也非常
清单1.1:EXAMPLE-PROGRAM-LISTING
(defun example-program-listing(){这是((程序(清单)))))的表达想法,觉得有必要抽象的概念作者和读者之间的交际语言。他称之为U-Language。
每一个调查,包括现在,必须从一个人到另一个通过语言来交流。它有利于我们的研究通过调用开始关注这个显而易见的事实,给一个名字所使用的语言,并被明确它的几个特性。我们应当叫U-Language所使用的语言。[…)就没有点引起关注,如果不是因为语言是更比其他大多数的我们的工作密切相关。
在本书中我们将介绍新的概念或要点,否则应强调在这个特殊的字体。当引用特殊形式,功能,宏,和其他标识符中发现一个程序,提出或外国,我们将使用这个特殊字体(注意,有些词有多个含义,例如λCOMMON LISP宏和λ概念;让特殊形式和列表形式)。
在这本书中介绍了新代码形式的程序清单。是专为重用的代码,或适当的实现的一个例子,提出了在函数example-programlisting的定义。但有时我们希望证明的使用一些代码或只是想讨论一些表达式的属性没有离职的书面文本?。在这些情况下,代码,或者例子使用的代码,将会出现如下所示:
?这是一个脚注,一个相关但简洁离开主
(这是(演示代码))
多写,教编程使得大量使用孤立的,做作的例子来说明一个点但是忘记把它与现实捆绑在一起。这本书吗?年代试图尽可能最小的和直接的例子为了说明宏观编程思想正在解释道。一些写作试图隐藏被使用可爱的无聊,古怪的标识符名称或表面的类比的例子。我们的示例只会阐述自己的想法。这本书说,最重要的是努力不把本身(或任何)太当回事。这里有幽默,所不同的是,你需要寻找它。
因为lisp ?年代的互动性质,评估一个简单的表达式的结果往往可以传达U-Language的等价数量多。在这种情况下,这就是我们将展示COMMON Lisp阅读评估的输出打印循环(称为REPL):
*(这是(表达式(评估)))
这就是结果
注意我们输入的文本是小写,但返回的文本lisp是大写。这个COMMON LisP的特点让我们轻松扫描REPL印出和知道哪个表情我们进入和打印出来的LisP。更准确地说,这个功能可以让我们快速扫描lisp包含符号的形式吗?在任何文件或屏幕吗?并立即知道它尚未处理的lisp读者。还要注意,星号(*)代表一个提示。这个角色是理想的,因为它可以吗?t与平衡的角色混淆,因为它的高像素计数,使它脱颖而出显然当扫描REPL会话。
文本。
编写复杂的lisp宏是一个迭代的过程。没人坐了下来,推敲出一份有一页篇幅的宏在骑士风格用其他语言编写的程序。这部分是因为lisp代码每页包含更多的信息比大多数其他语言也部分是因为lisp技术鼓励程序员成长计划:精炼他们在一系列的增强取决于应用程序的需求。
这本书区分类型的lisp,像COMMON lisp和Scheme,从更抽象的概念lisp的建筑材料。另一个重要区别是lisp编程语言和non-lisp编程语言。有时候我们需要谈论non-lisp语言,尽可能少的敌人,想要避免选择任何语言。为此,我们采取以下不同寻常的定义:
没有语言lisp宏是哭。
U-language词哭来自一篇由保罗•格雷厄姆击败Averagestpratine-aves],在那里哭是一个假设的lisp语言用来强调事实不像其他语言:lisp是不同的。哭的特点是中缀语法,恼人的类型系统和对象系统瘫痪但它唯一统一的特征是缺乏lisp宏。哭术语对我们是有用的因为有时理解一个高级宏观技术的最简单的方法是考虑为什么哭的技术是不可能的。哭的术语的目的是不要取笑non-lisp语言?。
为了说明宏观的迭代过程,这本书采用的惯例百分比(%)字符添加到名称的函数和宏定义不完整或以其他方式有待改进。多个修正可能导致多个%字符的名字之前我们在最终版本没有解决%字符。
介绍了宏咖喱吗?s元编程术语。一个meta-program与唯一的一个程序
>将会有一点点的乐趣。
清单1.2:ITERATIVE-PROCESS-EXAMPLE (defun示例函数% ();第一次尝试t)
(defun示例函数% % ();第二次尝试t)
(defun示例函数();得到它!t)的目的使程序员能够更好的编写程序。虽然元编程采用不同程度地在所有编程语言中,没有完全采用它作为lisp语言。在没有其他语言是程序员需要编写代码以这样一种方式方便元编程技术。这就是为什么lisp程序看起来怪异的non-lisp程序员:lisp代码是如何表达是一个直接后果的元编程的需要。这本书试图描述,这lisp的设计决策?在lisp写meta-programs本身?是什么给了lisp它惊人的生产力优势。然而,由于我们在lisp创建meta-programs,我们必须记住,元编程不同于U-Language规范。我们可以从不同的角度[的讨论,包括其他[,但只有一个U-Language。咖喱使得这个明确的为他的系统:
我们可以继续与任意数量的形式层次的语言水平。然而,无论有多少水平,U-Language将最高水平:如果有两个层次,这将是元语言;如果有三个的水平,这将是meta-meta-language;等等。因此U-Language和元语言必须保持截然不同。
当然,这是一本关于lisp和lisp吗?逻辑系统非常不同,所描述的咖喱,所以我们将采用
从他的工作很少有其他约定。但是咖喱吗?年代贡献逻辑和元编程继续启发我们。不仅因为他的深刻的见解关于象征性的报价,而且他的漂亮的措辞和U-Language执行。
1.3 Lisp实用程序
Lisp是一本书,你不理解或者什么?t理解。你喜欢它或者你害怕它。从其标题,Lisp是关于创建编程抽象层之上的Lisp。在我们吗?已经创建了这些抽象我们可以创建更多线程编程抽象的连续层在早些时候抽象。
在几乎任何语言值得使用,大部分的语言?年代与语言本身功能已经实现;哭的语言通常有广泛的标准库写在哭。甚至当实现者不?想在目标语言程序,你可能吗?不想。
但即使在考虑其他语言的标准库,lisp是不同的。在某种意义上,其他语言是由原语,lisp是meta-primitives组成。一旦宏标准化,如常见的LIspP,其余的从本质上没有什么语言可以开机。虽然大多数语言只是试图给一套足够灵活的这些原语,lisp给元编程系统,允许任何和所有的原语。另一种思考它是lisp完全摆脱原语的概念。在lisp,元编程系统不?t停止在任何所谓的原语。它是可能的,事实上,这些宏观的编程技术用于构建语言继续到用户应用程序。即使是最高级别的编写的应用程序的用户宏观层lisp洋葱,通过迭代增长。
在这种情况下,存在原语的语言是一个问题。任何时候有一个原始的,有一个障碍,non-orthogonality,系统的设计。有时,当然,这是必要的。大多数程序员都没有问题
清单1.3:MKSTR-SYMB (defun mkstr普克(args) (with-output-to-string (s) (dolist (args)(王子))))(defun symb (kr args)(值(实习生(应用# ?mkstr args))))治疗个别机器代码指令作为C或原语lisp编译器来处理。但是lisp用户需求控制几乎一切。没有其他语言,对控制给程序员,lisp一样完整。
听取的建议在Lisp,你正在阅读的那本书本身就是设计成一层洋葱。在同样的意义上,程序是分层的其他程序,这本书是分层在Lisp。这是格雷厄姆的中心主题吗?书:精心设计的实用程序,结合时,一起给大于部分之和的生产力优势。本节描述一组有用的实用程序从Lisp和其他地方。
Symb,分层mkstr,创建符号的一般方式。由于符号可以引用的任意字符串,并创建符号编程是如此有用,symb宏观规划和是一个重要的效用是这本书中大量使用。
组是另一个实用程序,编写宏时弹出。这是因为的一部分需要镜子运营商COMMON LIsp吗?年代setf和psetf已经组参数,部分原因是因为分组结构相关数据通常是最好的方法。因为我们经常使用这个功能,可以使抽象尽可能一般。格雷厄姆?年代集团将组织由任何提供分组,指定的参数n。在setf情况下,参数分为双,n等于2。
平是Lisp中最重要的工具之一。给定任意嵌套列表结构,平将返回一个
清单1.4:组
(defun组(n)来源(如果(zerop n)(错误“零长度”))(标签(rec (acc)来源(让(波峰(nthcdr n源)))(如果(consp rest) (rec rest(缺点(subseq源0 n) acc)) (nreverse
(缺点源acc))))))(如果源(rec源nil) nil)))

(rec (cdr x) acc)))))) (rec x nil)))
清单1.6:FACT-AND-CHOOSE
(defun事实(x)(如果(x = 0) 1 (* x(事实(1 - x))))) (defun选择(n r) (/ (n)(事实(r - n)) (r)))新列表包含所有原子可以通过列表结构。如果我们认为的表结构是一棵树,平将返回一个列表的树叶在树上。如果那棵树代表lisp代码,通过检查存在的某些对象表达式中,平完成一种code-walking,一个反复出现的主题在这本书。
事实和选择是显而易见的!和二项式系数函数的实现。
1.4许可协议
因为我相信书中给出的代码背后的概念基本物理观测或数学证明,即使我想我吗?相信我可以声称他们的所有权。因为这个原因你基本上是免费的,做任何你想做的代码从这本书。这是非常自由的许可证分发的代码:
3;这是这本书的源代码3;道格·霍伊特_Let_Over_Lambda_。3;这段代码(C) 2002 - 2008,道格·霍伊特。
3;你可以自由使用、修改和re-distribute 3;这段代码无论你想要的,除了任何
3;修改之前必须注明33;再分配。没有保修,
33表达或暗示。
a3
3;归因对我这个代码,道格·霍伊特,是33感激但不是必需的。如果你发现3;代码有用,或者希望文档,
3;请考虑购买这本书!
这本书的文本(C) 2008道格·霍伊特。保留所有权利。
1.5谢谢
布莱恩·霍伊特,南希·霍姆斯,罗莎莉福尔摩斯,伊恩,亚历克斯,我所有的家庭;syke,疯狂,费奥多,cyb0rg / asm, theclone,黑心病,d00tz, rt,岩浆,nummish,日瓦戈,解冻;迈克•康罗伊西尔维娅罗素Alan Paeth罗伯•麦克阿瑟西尔维德斯贾丁斯,约翰·麦卡锡,保罗•格雷厄姆Donald Knuth利奥布罗迪,Bruce Schneier,理查德·斯托曼Edi韦茨,Peter Norvig彼得•Seibel基督教Queinnec Keith Bostic约翰赌博;COMMON LISP的设计者和创造者,尤其是人斯蒂尔,理查德·加布里埃尔和肯特皮特曼的开发者和维护者CMUCL / SBCL CLISP, OpenBSD, GNU / Linux。
特别感谢伊恩·霍伊特的封面设计和利奥布罗迪”的卡通。
这本书是献给所有热爱编程。

