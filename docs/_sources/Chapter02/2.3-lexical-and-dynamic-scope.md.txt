# 2.3 词法作用域与动态作用域

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle%40outlook.com)>

---

变量的有效作用范围叫做作用域。现代的变成语言中比较通用的作用域是——词法作用域。当变量作用于代码段中，那么该变量就被称为是该代码段的词法作用域的绑定。最为通用的创建编定的的关键词——let，可以来介绍词法作用域中的变量：
```
* (let ((x 2))
    x)

2
```
上面 `let` 中的变量 `x` 就是通过词法作用域来访问的。同样的，由 `lambda` 和 `defun` 定义的函数中的参数也是函数中的词法绑定。词法变量指的是只能从词法作用域中对其进行访问，比如说上面的 `let` 语句。由于词法作用域是如此直接的来限制作用域中变量的访问，所以词法作用域看起来似乎是作用域的唯一选择。那这还有其他作用域的容身之处吗？


尽管不确定范围和词法范围的组合非常有用，但直到现在它还没有在主流编程语言中得到很好的应用。词法作用域第一次应用在由Steve Russell 设计的Lisp 1.5，随后演化成了 Algol60、Scheme和 Common Lisp。由于有着悠久而丰富的历史，词法作用域的许多优点渐渐被其他的语言吸收。


即便是类 C 的语言的作用域有局限性，C 程序员仍需要进行跨平台的编程。为了实现跨平台编程，C 程序员通常会用一种名为指针作用域的粗略作用域。指针作用域比较知名的有以下几点：调试困难，安全风险高以及（某些人为的）效率低。指针作用域的原理通过定义一种特定域语言，用来控制冯诺伊曼式计算机（现在大部分的CPU）中的寄存器和内存，然后使用这种语言访问和操作数据结构，并对运行程序的CPU发出相当直接的命令。在没有较好的lisp编译器之前，如果需要考虑到性能的话，指针作用域是很有必要的，但如今却成了现代编程语言的问题，而不是特性。


尽管lisp程序员很少考虑指针，但对指针作用域的理解对构造高效的lisp代码是很有有价值的。在[7.4节：指针作用域](../Chapter07/7.4-pointer-scope.md)中，我们将会研究在某些需要通知编译器生成特定的代码特殊情况中实现指针作用域。目前我们只需要讨论它的机制。在C语言中，有时需要访问定义在函数之外的变量，如 `pointer_scope_test` 函数:
```c
#include <stdio.h>

void pointer_scope_test() {
  int a;
  scanf("%d", &a);
}
```
在上面的函数中，使用了C语言中的 `&` 操作符将本地变量`a`在内存中的实际地址提供给`scanf`函数，这样 `scanf` 就知道将输入的数据写到哪里。lisp中的词法作用域我们无法直接实现这种操作。在lisp中，我们可能会将一个匿名函数传递给假设的`scanf`函数，其中 `scanf` 可以对词法变量 `a` 进行赋值，即便 `scanf` 定义在词法作用域外:
```
(let (a)
  (scanf "%d" (lambda (v) (setf a v))))
```
词法作用域是闭包的基础。实际上，词法作用域通常被更具体的叫做词法闭包，用来区分于别的闭包，就是因为这两者定义很相近。除特别注明外，书中所说的都是词法闭包。
​

除词法作用域外，COMMON LISP还有动态作用域。动态作用域是 lisp 方言中临时作用域和全局作用域的组合。这是lisp特有的作用域类型，因为它与词法作用域的语法相同，但表现方式却不一样。在COMMON LISP中，我们特意将动态作用域中的变量叫做特殊变量。这些特殊的变量可以用 `defvar`定义。一些程序员遵循用星号作为前缀和后缀的特殊变量名的惯例，比如 ** *temp-special* **​ 。这种命名方法有些掩耳盗铃。基于[3.7节：语法二义性](../Chapter03/3.7-duality-of-syntax.md)中阐述的原因，本书不会采用这种掩耳盗铃的命名方法，因此特殊变量声明如下:
```
(defvar temp-special)
```
当这样定义时，** *temp-special* ** 就是一个特殊（我们还可以通过声明一个特殊局部变量来表示变量的特殊）的、不会初始化的值。在这种情况下的变量变量称为 unbound 。只有全局变量可以不被绑定——词法变量总是被绑定的，因此总是有值。另一种思路是，默认情况下，所有符号都表示词汇上未绑定的变量。与词法变量一样，我们可以使用** *setq* ** 或 ** *setf* ** 为全局变量赋值。有些Lisp，如Scheme，没有动态作用域。其他的，如EuLisp，使用不同的语法来访问词法变量和全局变量。但在Common Lisp 中，语法是共享的。许多lisper认为这是一个特性。以下是给全局变量 ** *temp-special* ** 赋值:
```
(setq temp-special 1)
```
目前看着，这个“特殊”的变量看起来不是那么的特殊。和其他的变量没差，同样是绑定了某些全局的命名空间。但这是因为我们只对它进行了一次的绑定——默认的全局绑定。但当全局变量在新的环境中被重新绑定或是覆盖时就变的有趣了。假设现在定义一个简单的函数，该函数返回 **temp-special**​ 的值：
```
(defun temp-special-returner ()
  temp-special)
```
当这这个函数被调用时，可以用来展示 lisp 是怎样对 temp-special 求值的。
```
* (temp-special-returner)
1
```
有时，这种情况在空词法作环境（null lexical environment）中看作是对表单的求值。空词法环境显然不包含任何词法绑定。在这里 **temp-sepcial** 变量返回的是它全局变量的值——1。但在非空词法环境中（其中全局变量被重新赋值）对其求值时，全局变量返回的是新的值（因为当创建一个动态绑定时，并没有创建一个词法的环境，看起来就是如此。）
```
* (let ((temp-special 2))
    (temp-special-returner))

2
```
以上执行结果返回的是2，这代表着 **temp-special** 绑定的是 **let**​ 作用域中的值，而不是全局定义的值。如果这还不够有趣的话，看看这段Blub伪代码，就知道全局变量如何在其他大多数传统编程语言中无法实现的：
```c
int global_var = 0;

function whatever() {
  int global_var = 1;
  do_stuff_that_uses_global_var();
}

function do_stuff_that_uses_global_var() {
  // global_var is 0
}
```
虽然词法绑定的内存位置或寄存器分配在编译时是已知的（这也是词法作用域有时也被叫做静态作用域的原因），但在某种意义上，全局变量绑定是在运行时确定的。由于一个巧妙的技巧，全局变量并不是看起来那么低效。全局变量实际上总是指向内存中的相同位置。在用**let**绑定全局变量时，实际上是在编译代码，这些代码将存储变量的副本，用一个新值覆盖内存位置，在**let**​主体中对表单求值，最后从副本中恢复原始值。

全局变量总是与命名的符号相关联。全局变量指向的内存中的位置被叫做符号的“符号值”单元格。这与词法变量形成了直接的对比。词法变量仅在编译时用符号表示。因为词法变量只能从其绑定的词法范围内访问，所以编译器甚至没有理由记住用来引用词法变量的符号，因此编译器会在编译后的代码中删除这些符号。我们将在[第6.7节：潘多拉宏](../Chapter06/6.7-pandoric-macros.md)中来详细的证明这一点。

COMMON LISP的确是提供了动态范围的宝贵特性，但是词法变量是最常见的。动态作用域曾经是lisp中定义的特性，但在 Common Lisp之后，动态作用域几乎完全被词法作用域取代。因为词法作用域支持词法闭包(稍后我们将对此进行讨论)以及更有效的编译器优化，所以动态作用域的取代通常被视为一件好事。然而，COMMON LISP的设计者给我们留下了一个非常透明的窗口，让我们可以看到动态范围的世界，现在我们知道动态范围的真正含义：特殊。
