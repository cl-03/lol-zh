

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>6.3 alet 和有限状态机 &mdash; Let Over Lambda 中文文档  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4 间接链" href="6.4-indirection-chains.html" />
    <link rel="prev" title="6.2 Sharp-Backquote：#`" href="6.2-sharp-backquote.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter05/index.html">第五章：Programs that program</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第六章：回指(Anaphoric) 宏</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="6.1-more-phors.html">6.1 More Phors?</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.2-sharp-backquote.html">6.2 Sharp-Backquote：#`</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.3 <code class="docutils literal notranslate"><span class="pre">alet</span></code> 和有限状态机</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.4-indirection-chains.html">6.4 间接链</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.5-hotpatching-closures.html">6.5 热修复闭包</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.6-sub-lexical-scope.html">6.6 字词法作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.7-pandoric-macros.html">6.7 潘多拉宏</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第六章：回指(Anaphoric) 宏</a> &raquo;</li>
        
      <li>6.3 <code class="docutils literal notranslate"><span class="pre">alet</span></code> 和有限状态机</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Chapter06/6.3-alet-and-finite-state-machines.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="tex2jax_ignore mathjax_ignore section" id="alet">
<h1>6.3 <code class="docutils literal notranslate"><span class="pre">alet</span></code> 和有限状态机<a class="headerlink" href="#alet" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte &lt;<a class="reference external" href="mailto:doug&#37;&#52;&#48;hoytech&#46;com">doug<span>&#64;</span>hoytech<span>&#46;</span>com</a>&gt;</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<p>对 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 和 <code class="docutils literal notranslate"><span class="pre">if</span></code>，只有一个有用的回指配置，但却是最有趣的回指宏类型，该宏是以
不可预见的方式展开。本节 —— 甚至本章的大部分内容 —— 都是基于这样一个宏：<code class="docutils literal notranslate"><span class="pre">alet</span></code>。
有哪些额外的绑定对 let 结构主体中的结构有用呢？ <code class="docutils literal notranslate"><span class="pre">let</span></code> 的目的就是创建这样的绑定，
这样就可以捕获给 let 的变量引入。但是， <code class="docutils literal notranslate"><span class="pre">let</span></code> 宏的增强可以完全访问提供给它的所有
结构，甚至是用新绑定计算的表达式体。那么主体中最有用的部位是什么呢？在大多数情况
下，主体中最有用的部分就是主体中的最后一个结构，因为该结构的结果将从 let 语句本身
返回。我们已经看到，当返回一个引用 <code class="docutils literal notranslate"><span class="pre">let</span></code> 创建的绑定的 lambda 表达式时，结果是一个
词法闭包 —— 一个通常存储并用于以后访问 let 语句中的变量的对象。因此，扩展我们的
闭包对象模拟，<code class="docutils literal notranslate"><span class="pre">alet%</span></code> 宏的行为与 <code class="docutils literal notranslate"><span class="pre">let</span></code> 特殊结构完全相似，除了 <code class="docutils literal notranslate"><span class="pre">alet%</span></code> 从主体中捕获
符号 <code class="docutils literal notranslate"><span class="pre">this</span></code> 并将其绑定到该结构主体中的最后一个表达式 —— 作为闭包返回的表达式。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro alet% (letargs &amp;rest body)
  `(let ((this) ,@letargs)
    (setq this ,@(last body))
    ,@(butlast body)
    this))
</pre></div>
</div>
<p>当在 lambda 结构中有初始化的代码，且不想重复初始化时，<code class="docutils literal notranslate"><span class="pre">alet%</span></code> 就很有用。因为
<code class="docutils literal notranslate"><span class="pre">this</span></code> 绑定到要返回的 lambda 结构，所以我们可以在外围 let 返回它之前执行它。
下面是一个闭包，它的构造展示了个简单的 <code class="docutils literal notranslate"><span class="pre">alet%</span></code> 例子，避免了重复它的重置和
初始化代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alet</span><span class="o">%</span> <span class="p">((</span><span class="nb">sum</span><span class="p">)</span> <span class="p">(</span><span class="n">mul</span><span class="p">)</span> <span class="p">(</span><span class="n">expt</span><span class="p">))</span>
    <span class="p">(</span><span class="n">funcall</span> <span class="n">this</span> <span class="p">:</span><span class="n">reset</span><span class="p">)</span>
    <span class="p">(</span><span class="n">dlambda</span>
      <span class="p">(:</span><span class="n">reset</span> <span class="p">()</span>
        <span class="p">(</span><span class="n">psetq</span> <span class="nb">sum</span> <span class="mi">0</span>
              <span class="n">mul</span> <span class="mi">1</span>
              <span class="n">expt</span> <span class="mi">2</span><span class="p">))</span>
      <span class="p">(</span><span class="n">t</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="p">(</span><span class="n">psetq</span> <span class="nb">sum</span> <span class="p">(</span><span class="o">+</span> <span class="nb">sum</span> <span class="n">n</span><span class="p">)</span>
              <span class="n">mul</span> <span class="p">(</span><span class="o">*</span> <span class="n">mul</span> <span class="n">n</span><span class="p">)</span>
              <span class="n">expt</span> <span class="p">(</span><span class="n">expt</span> <span class="n">expt</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">list</span> <span class="nb">sum</span> <span class="n">mul</span> <span class="n">expt</span><span class="p">))))</span>
<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>我们可以依次调用它来改变 <code class="docutils literal notranslate"><span class="pre">sum</span></code>、<code class="docutils literal notranslate"><span class="pre">mul</span></code> 和 <code class="docutils literal notranslate"><span class="pre">expt</span></code> 的值:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">loop</span> <span class="k">for</span> <span class="n">i</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span> <span class="n">collect</span> <span class="p">(</span><span class="n">funcall</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">((</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span> <span class="mi">4</span> <span class="mi">16</span><span class="p">)</span>
<span class="p">(</span><span class="mi">6</span> <span class="mi">8</span> <span class="mi">256</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span> <span class="mi">16</span> <span class="mi">65536</span><span class="p">)</span>
<span class="p">(</span><span class="mi">10</span> <span class="mi">32</span> <span class="mi">4294967296</span><span class="p">))</span>
</pre></div>
</div>
<p>现在也可以调用 <code class="docutils literal notranslate"><span class="pre">:reset</span></code> 方法来重置这个闭包。注意多亏了 <code class="docutils literal notranslate"><span class="pre">alet%</span></code>，这里只需要在一个
位置写重置的基本情况（将 <code class="docutils literal notranslate"><span class="pre">sum</span></code> 置为 0，<code class="docutils literal notranslate"><span class="pre">mul</span></code> 置为 1， <code class="docutils literal notranslate"><span class="pre">expt</span></code> 置为 2）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="o">**</span> <span class="p">:</span><span class="n">reset</span><span class="p">)</span>

<span class="n">NIL</span>
</pre></div>
</div>
<p>现在，该闭包中的值都被重置了，我们从一开始就可以看到个新的序列了：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">loop</span> <span class="k">for</span> <span class="n">i</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span> <span class="n">collect</span> <span class="p">(</span><span class="n">funcall</span> <span class="o">***</span> <span class="mf">0.5</span><span class="p">))</span>

<span class="p">((</span><span class="mf">0.5</span> <span class="mf">0.5</span> <span class="mf">1.4142135</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1.0</span> <span class="mf">0.25</span> <span class="mf">1.1892071</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1.5</span> <span class="mf">0.125</span> <span class="mf">1.0905077</span><span class="p">)</span>
<span class="p">(</span><span class="mf">2.0</span> <span class="mf">0.0625</span> <span class="mf">1.0442737</span><span class="p">)</span>
<span class="p">(</span><span class="mf">2.5</span> <span class="mf">0.03125</span> <span class="mf">1.0218971</span><span class="p">))</span>
</pre></div>
</div>
<p>值得一提的是 <code class="docutils literal notranslate"><span class="pre">alet%</span></code> 改变了 let 主体中结构的计算顺序。如果你去看一下这个的展开的话，
你就会发现主体中最后一个结构实际上是第一个执行的，随后该结果在其他结构执行前会绑定
到词法变量 <code class="docutils literal notranslate"><span class="pre">this</span></code> 上。然而，只要最后一个参数是常量，这个重新排序不会产生差异。记住，
lambda 表达式是个常量，因此特别适合用在 <code class="docutils literal notranslate"><span class="pre">alet%</span></code> 中。</p>
<p>与许多宏增强一样，因为有许多可用的自由度，对该宏的改进是违反直觉的。虽然有许多
可能性，但本节将考虑其中一种具体的改进。可以让 <code class="docutils literal notranslate"><span class="pre">alet%</span></code> 不返回其主体的最后一个
结构（预期是 lambda 结构)，而是返回一个在 let 结构词法作用域内查找另一个函数的
函数，然后调用该函数。这有时又被称为间接调用（indirection），因为返回的是一个
使用指针解引用查找函数的函数，然后使用该函数，而不是返回一个函数来执行某些操作。
间接是个在编程语言中普遍存在的概念。它允许我们在运行时不间接地修改、编译时
修复内容。Lisp 有比许多其他编程语言更简洁、更有效的方式使用间接方法。 <code class="docutils literal notranslate"><span class="pre">alet</span></code>
是 <code class="docutils literal notranslate"><span class="pre">alet%</span></code> 加入了间接调用的版本，可以返回的闭包函数正在被 alet 主体内部的代码
访问或替换，或者，如果用 <code class="docutils literal notranslate"><span class="pre">dlambda</span></code> 的话（很快就会介绍），甚至可以在 alet 主体
外部被替换。</p>
<p>现在可以用 <code class="docutils literal notranslate"><span class="pre">alet</span></code> 宏更改在调用闭包时执行的函数了，我们可以使用名为 alet over
alambda 的模式创建一对相互引用的函数。只要所有的状态都变回原来的状态 ——
而不是相互转换 —— alet over alambda 就是指定无名状态机的一种便携的方法。</p>
<p>下面就是个典型的计数器闭包，接收参数 <code class="docutils literal notranslate"><span class="pre">n</span></code>，当传递符号 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 作为参数而不是
数字时，它的方向可以在递增和递减之间按 <code class="docutils literal notranslate"><span class="pre">n</span></code> 切换：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alet</span> <span class="p">((</span><span class="n">acc</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="n">alambda</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
        <span class="p">(</span><span class="n">setq</span> <span class="n">this</span>
              <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
                  <span class="p">(</span><span class="n">setq</span> <span class="n">this</span> <span class="c1">#&#39;self)</span>
                  <span class="p">(</span><span class="n">decf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">))))</span>
        <span class="p">(</span><span class="n">incf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">))))</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>让我们把这个闭包保存起来，以便我们随时可以使用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">symbol</span><span class="o">-</span><span class="n">function</span> <span class="s1">&#39;alet-test) *)</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>开始时，是增加的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alet</span><span class="o">-</span><span class="n">test</span> <span class="mi">10</span><span class="p">)</span>

<span class="mi">10</span>
</pre></div>
</div>
<p>但是，可以通过将符号  <code class="docutils literal notranslate"><span class="pre">invert</span></code> 传递给闭包来改变要调用内部 lambda 表达式的实际函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alet</span><span class="o">-</span><span class="n">test</span> <span class="s1">&#39;invert)</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>
</pre></div>
</div>
<p>现在就变成递减了：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alert</span><span class="o">-</span><span class="n">test</span> <span class="mi">3</span><span class="p">)</span>

<span class="mi">7</span>
</pre></div>
</div>
<p>最后，多亏了 <code class="docutils literal notranslate"><span class="pre">alambda</span></code> 的 <code class="docutils literal notranslate"><span class="pre">self</span></code> 绑定，我们可以用 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 参数再次修改函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alert</span><span class="o">-</span><span class="n">test</span> <span class="s1">&#39;invert)</span>

<span class="c1">#&lt;Interpreted Function&gt;</span>

</pre></div>
</div>
<p>又回到了刚开始时的状态，递增：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">alert</span><span class="o">-</span><span class="n">test</span> <span class="mi">5</span><span class="p">)</span>

<span class="mi">12</span>
</pre></div>
</div>
<p>这个闭包被绑定到函数命名空间 <code class="docutils literal notranslate"><span class="pre">alet-test</span></code> 上了。但和常规的闭包略有不同。虽然这个
闭包和常规闭包都是指向单个环境的指针，这个环境可以有任意数量的引用，但这个闭包
使用间接方法来更改调用时运行的代码段。尽管可以插入任何一段代码，但只有 <code class="docutils literal notranslate"><span class="pre">alet</span></code>
的词法范围内的代码(即具有 <code class="docutils literal notranslate"><span class="pre">this</span></code> 回指符的代码)才能访问它的词法绑定。但是，仍然
不能阻止我们插入个新的闭包，它有自己的词法绑定，可能还会因为在 <code class="docutils literal notranslate"><span class="pre">alet</span></code> 插入的
间接环境中改变行为。本章剩下的大部分内容是使用 <code class="docutils literal notranslate"><span class="pre">alet</span></code> 创建的间接环境做些有用
的事情。
​</p>
<p>一种常见的宏技术被非正式地称为将宏内部打开（turning a macro inside out）。
当打开一个宏时，可以选择一个典型的结构，该结构使用与想要创建的宏类似的宏，
并将其展开。然后使用该展开作为所需宏的模板。例如，我们希望有一种比前面介绍
的 alet over alambda 计数器更通用的方法来创建具有多个状态的闭包。下面是上面
由内而外展开的可逆计数器 alambda 用例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">macroexpand</span>
  <span class="s1">&#39;(alambda (n)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
        <span class="p">(</span><span class="n">setq</span> <span class="n">this</span>
              <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
                  <span class="p">(</span><span class="n">setq</span> <span class="n">this</span> <span class="c1">#&#39;self)</span>
                  <span class="p">(</span><span class="n">decf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">))))</span>
        <span class="p">(</span><span class="n">incf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">))))</span>

<span class="p">(</span><span class="n">LABELS</span> <span class="p">((</span><span class="n">SELF</span> <span class="p">(</span><span class="n">N</span><span class="p">)</span>
          <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">EQ</span> <span class="n">N</span> <span class="s1">&#39;INVERT)</span>
            <span class="p">(</span><span class="n">SETQ</span> <span class="n">THIS</span>
                  <span class="p">(</span><span class="n">LAMBDA</span> <span class="p">(</span><span class="n">N</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">EQ</span> <span class="n">N</span> <span class="s1">&#39;INVERT)</span>
                      <span class="p">(</span><span class="n">SETQ</span> <span class="n">THIS</span> <span class="c1">#&#39;SELF)</span>
                      <span class="p">(</span><span class="n">DECF</span> <span class="n">ACC</span> <span class="n">N</span><span class="p">))))</span>
            <span class="p">(</span><span class="n">INCF</span> <span class="n">ACC</span> <span class="n">N</span><span class="p">))))</span>
  <span class="c1">#&#39;SELF)</span>
</pre></div>
</div>
<p>如果稍微重构上面的展开，利用标签来创建多个函数绑定的事实，将会得到以下结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">alet</span> <span class="p">((</span><span class="n">acc</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="n">labels</span> <span class="p">((</span><span class="n">going</span><span class="o">-</span><span class="n">up</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
              <span class="p">(</span><span class="n">setq</span> <span class="n">this</span> <span class="c1">#&#39;going-down)</span>
              <span class="p">(</span><span class="n">incf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">)))</span>
          <span class="p">(</span><span class="n">going</span><span class="o">-</span><span class="n">down</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
             <span class="p">(</span><span class="n">setq</span> <span class="n">this</span> <span class="c1">#&#39;going-up)</span>
             <span class="p">(</span><span class="n">incf</span> <span class="n">acc</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">)))))</span>
  <span class="c1">#&#39;going-up))</span>
</pre></div>
</div>
<p>通过这个例子，我们注意到 <code class="docutils literal notranslate"><span class="pre">alambda</span></code> 能使用 <code class="docutils literal notranslate"><span class="pre">labels</span></code> 这个特殊的结构让其所有绑定
对它的函数主体都可用。还有就是，现在已经很完整的最终版宏的模版了。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro alet-fsm (&amp;rest states)
  `(macrolet ((state (s)
                `(setq this #&#39;,s)))
      (labels (,@states) #&#39;,(caar states))))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">alet-fsm</span></code> 提供了一种便携的语法，该语法可以用来表达闭包存在的多种可能状态。
就像是在 <code class="docutils literal notranslate"><span class="pre">labels</span></code> 上的宏包裹了一层薄薄的糖衣，并结合了代码遍历 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code>
的变形，该变形可以假装有个 <code class="docutils literal notranslate"><span class="pre">state</span></code> 函数，用来改变闭包的当前状态，该函数通过
<code class="docutils literal notranslate"><span class="pre">alet</span></code> 提供的 <code class="docutils literal notranslate"><span class="pre">this</span></code> 回指来访问。下面是可逆计数器的更简洁的版本的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">alet</span> <span class="p">((</span><span class="n">acc</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="n">alet</span><span class="o">-</span><span class="n">fsm</span>
    <span class="p">(</span><span class="n">going</span><span class="o">-</span><span class="n">up</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
        <span class="p">(</span><span class="n">state</span> <span class="n">going</span><span class="o">-</span><span class="n">down</span><span class="p">)</span>
        <span class="p">(</span><span class="n">incf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">)))</span>
    <span class="p">(</span><span class="n">going</span><span class="o">-</span><span class="n">down</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">eq</span> <span class="n">n</span> <span class="s1">&#39;invert)</span>
        <span class="p">(</span><span class="n">state</span> <span class="n">going</span><span class="o">-</span><span class="n">up</span><span class="p">)</span>
        <span class="p">(</span><span class="n">decf</span> <span class="n">acc</span> <span class="n">n</span><span class="p">)))))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">alet-fsm</span></code> 是之前没有见过的例子：回指注入（anaphor injection）。使用这种
隐喻在很多方面违反了词法透明性，以至于它实际上在某种程度上是词法不可见的
（lexically invisible）。<code class="docutils literal notranslate"><span class="pre">alet</span></code> 不仅无形地绑定了 <code class="docutils literal notranslate"><span class="pre">this</span></code>，而且 <code class="docutils literal notranslate"><span class="pre">alet-fsm</span></code> 宏对
<code class="docutils literal notranslate"><span class="pre">this</span></code> 的使用也是同样隐形的。 <code class="docutils literal notranslate"><span class="pre">alet-fsm</span></code> 将一个自由变量插入到词法上下文中，
而在词汇上下文中根本看不到它。</p>
<p>这其中的格式问题是不确定的，当然，宏编程与格式无关。这关乎性能。有时，插入
自由变量可以在两个宏之间创建共生关系 —— 它可以更好地以编程方式构造扩展，
而不是两个独立的扩展。由于这种宏编程非常复杂，因此可以与 C 指针进行类比。
就像学习 C 指针会产生可疑的风格建议一样，自由变量插入也是如此。</p>
<p>对于自由变量插入难以理解的原因，最合理的假设是它的故障安全行为。有了回指，
如果用户代码没有使用绑定，那么代码很可能会继续工作，不管是否希望它这样做。
它可能已经悄无声息地失败了，因此不安全。然而，当插入一个自由变量，并且
没有捕获它的环境时，整个表达式就释放了。当这种情况发生时，需要在计算表达式
之前决定要做什么。因为它有故障安全。</p>
<p>除了格式之外，自由变量插入有时正是两个相关宏来回通信时所需要的。插入和
回指的操作其实是一样的，只是方向相反。因为在宏之间打开了一个新的沟通渠道，
复杂性问题的扩展速度甚至更快。想象一下坐在一个满是易碎玻璃的房子里。你可以
放心地向房子外面的人扔东西，即使这些东西不用费心去抓，但你最好确保你能
抓住扔向你的东西。</p>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="6.4-indirection-chains.html" class="btn btn-neutral float-right" title="6.4 间接链" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="6.2-sharp-backquote.html" class="btn btn-neutral float-left" title="6.2 Sharp-Backquote：#`" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>