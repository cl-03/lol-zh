# 3.4 自由变量

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

*自由变量* 是在无全局绑定或词法闭包绑定的表达式中引用的变量或函数。 在下面的表达式中，**x** 是自由的：
```
(+ 1 x)
```
但下面的代码中，我们在捕获变量 **x** 的结构外面创建了一个绑定，从而剥夺了它的自由度：
```
(let ((x 1))
  (+ 1 x))
```
自由和捕获的术语起初可能看起来很奇怪。毕竟，自由意味着意识和做出决定的能力——这显然是简单的表达方式所缺乏的。但是自由并不是指表达式可以做什么，而是作为程序员可以用表达式做什么。例如，我们可以将表达式 **(+ 1 x)** 嵌入到任意位置，从而允许表达式访问周围代码中名为 **x** 的绑定。然后我们说代码已经捕获了自由变量。在表达式中的自由变量被捕获后，如上面的 **let** 结构，其他周围的代码没有选择捕获变量 **x**。之前的自由变量已经被捕获。现在完全清楚它指的是哪个 **x**。因此，lisp 根本不需要在代码中保留对符号 **x** 的引用。正如[2.3 节：词法作用域和动态作用域](../Chapter02/2.3-lexical-and-dynamic-scope.md)中描述的那样，lisp 编译器会忘记用于表示词法变量的符号。

尽管带有表达式的语言都可以有带有自由变量的表达式，但 lisp 的宏功能意味着自由变量在 lisp 中比在其他语言中更有用。 在大多数语言中，我们被迫遵守 *引用透明性*。 如果 Blub 程序中没有定义全局或对象变量 **x**，则下面代码毫无疑问是错误的：
```
some_function_or_method() {
  anythind(1 + x);
}
```
**some_function_or_method** 无法为 **x** 创建隐式绑定。 在 Blub 语言中，对变量的使用都必须有显式的定义[8](https://letoverlambda.com/index.cl/guest/chap3.html#)。 具有原始宏系统的语言（如 C）可以在很有限的情况下完成其中的这种绑定。 但正如通用宏在 C 中不切实际或不可能编写一样，涉及自由变量的特殊情况也是如此。

在 lisp 中，可以随意将自由变量放到表达式周围，或者将自由变量拼接成新的表达式以供周围的代码捕获，又或者定义全局特殊变量来捕获它们。 还可以编写宏来修改表达式中的哪些变量是自由的，或者通过重写表达式来减少自由变量（例如向上面一样将自由变量包在 let 结构中），或者通过修改表达式的方式来添加新的自由变量。 这种自由变量的添加与捕获变量相反，称为 *自由变量注入*。

最简单的自由变量注入就是宏展开成一个符号的引用：
```
(defmacro x-injector ()
  'x)
```
因为宏只是一个函数，它以常规的 lisp 结构执行其主体。 上面的注入宏计算引用的符号，当然，返回一个符号——一个自由变量——然后拼接到任何使用 **x-injector** 宏的表达式中。 Paul Graham 在 On Lisp 中讨论过这种自由变量注入
> _This kind of lexical intercourse is usually viewed more as a source of contagion than a source of pleasure. Usually it would be bad style to write such a macro. Of all the macros in this book, only [two isolated cases] use the calling environment in this way._

相比之下，本书从这种词汇交流中获得了很多乐趣。自由变量注入——在完全了解将要在其中扩展的词法环境的情况下编写宏——只是 lisp 宏编程的另一种方法，当有一些略微不同的词法上下文，而想在其中编写基本相同的代码时，这种方法很有用。虽然函数调用的主要优点通常是抛弃了词法环境，但有时对 lisp 程序员来说，这只是个可以用宏而忽略的指南。事实上，一旦习惯了它，一些 lisp 程序员总是尝试编写宏，尽可能地扩展词法上下文，仅在需要计算参数或只是停止并想要新的词法上下文时才使用函数。在 [3.6 节：Once Only](./3.6-once-only.md) 中，我们将看到一种在需要计算参数时避免丢弃词法环境的方法。尽量保持词法环境允许的有趣的宏组合，其中宏在使用一个或多个其他宏时添加词法上下文。展开成所定义的宏的代码是宏组合的一种特殊情况，在[5.5 节：递归展开](../Chapter05/5.5-recursive-expansions.md)中进行了讨论。


两点之间最短的距离是直线。 自由变量，通俗点说，扩展词法上下文通常是以编程方式构造程序的最简单方法。 以这种方式使用宏可能看起来像是一种 hack，且在风格上可能会令人反感，但它可以方便且可靠地工作。 尤其是我们在[5.4 节：使用 `Macrolet` 遍历代码](../Chapter05/5.4-code-walking-with-macrolet.md)中思考了 **macrolet** 之后，这种编程风格——结合宏——会开始看起来更舒服。 记住，宏编程与风格无关； 而是关乎能力。 宏允许我们实现很多语言不可能做的事情。 自由变量注入就是其中之一。
