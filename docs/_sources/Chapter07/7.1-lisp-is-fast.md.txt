# 7.1 Lisp Is Fast

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---



> 如果用指甲盖大小的瓷砖来铺地面的话，就不会有太多的浪费。 —— Paul Graham



有人觉得 lisp 很慢。对于一些早期的 lisp 实现来说，确实是这样的，但多年来这种看法
已经被证明是错误的。事实上，像 COMMON LISP 这样的现代Lisp 已经设计成用宏来
提高 Lisp 的速度。非常快。如果相信低级语言比 lisp 更高效的性能神话，那么本章的目
标可能会让你感到惊讶。本章旨在说明 lisp 可以比其他编程语言更快，而像 C 这样的低
级编程语言实际上在性能上比 lisp 更差，因为它们缺少宏。Lisp 能编写比其他语言更高效
的代码。特别是大型和复杂的程序，宏能构建比 Blub 语言更具绝对性能优势的代码。有时，
我们的语言设计成具有高效的实现，但更多时候，它们设计成为程序员提供最大的表达能力。
当选择效率时，lisp 很快，非常得快。


当其他语言提供小的、正方形的瓦片时，lisp 可以选择随意大小、形状的瓦片。在 C 语言中，
程序员总是使用一种与花哨的固定数字加法器功能直接相关的语言。除了过程和结构，在 C
语言中几乎不可能进行抽象。相反，lisp 根本不是围绕机器的能力和限制而设计的。


但可以肯定的是，其他语言能用更低效率、更方便的方式来编写。毕竟，Perl 让程序员使用
单个密集表达式进行精确匹配，但也为更快的代码提供了许多升级路径。那么，当说 lisp
不像其他语言那样，可以控制抽象的效率时，这意味着什么呢？现在你可能已经猜到了，
答案就是书中的主题：宏。


与其询问什么让程序运行得快，不如问问是什么让程序运行得慢。这是编程中最常被研究的
话题之一。根本原因可以大致分为三大类：糟糕的算法、差劲的数据结构和通用代码。


所有的语言实现都需要好算法。算法大概是对如何执行编程任务进行了充分研究的过程描述。
因为发明算法所需的投资远远大于实现算法，所以算法在整个计算机科学中无处不在。有人
已经知道了算法如何、为什么以及多快地工作；要使用算法，所要做的就是把它的伪代码转换
成系统能够理解的东西。因为 COMMON LISP 实现通常都是由聪明的人实现的，并且在过去
的几十年里不断改进，他们通常使用一些最好和最快的算法来完成大多数常见的任务。例如，
CMUCL 使用调优的堆排序实现对列表和向量的排序，使用 Mersenne Twister 19937 算法
及大周期来其生成随机数。


好的数据结构对优秀的编程语言来说也是必要的。数据结构很重要，忽略它们将导致任何语言
实现缓慢。数据结构的优化本质上归结为一个叫做局部性的概念。解释这个概念很容易 ——
访问最频繁的数据应该是访问速度最快的。数据结构和局部性是如此重要，以至于几乎所有
需要提高性能的计算级别上都能清楚地看到它们：大量的CPU寄存器、内存缓存、数据库和
缓存网络代理是其中的一些亮点。Lisp 提供了一组巨大的标准数据结构，它们也都实现得很好。
哈希表、链表（显然）、带填充指针的向量、带可互连符号的包，以及更多的都是特定、可用
且为 Common Lisp 程序员利用的都很好地实现了。


如果 lisp 提供了这么好的算法和数据结构，那 lisp 代码怎么可能比其他语言的慢呢？这个解释
是基于 lisp 最重要的设计决策：通用代码，一个与我们熟悉的二元性相似的概念。在编写 lisp
代码时，我们尽可能多地使用二元性。语言本身的结构鼓励我们这样做。lisp 程序通常比 Blub
程序短得多的部分原因是，任何给定的 lisp 代码段的用途都比相应的 Blub 代码段大得多，因此
可以更频繁地重用它。从 Blub 语言的角度来看，写得多得到得少可能会让人觉得不寻常，但这是
我们一直在讨论的 lisp 的重要设计决策 —— 语法的二元性。每个表达式附加的二元性越多，
程序似乎就越短。那么，这是否意味着为了达到或超过 C 语言的性能，需要使 lisp 程序与相应的
 C 语言程序一样长且危险呢？不，Lisp 有宏。
