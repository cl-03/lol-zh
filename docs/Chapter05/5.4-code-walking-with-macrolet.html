<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5.4 使用 macrolet 遍历代码 &mdash; Let Over Lambda 中文文档  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="5.5 递归展开" href="5.5-recursive-expansions.html" />
    <link rel="prev" title="5.3 隐式上下文" href="5.3-implicit-contexts.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter01/index.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter02/index.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter03/index.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter04/index.html">第四章：Read 宏</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第五章：Programs that program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="5.1-lisp-is-not-functional.html">5.1 非函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.2-top-down-programming.html">5.2 自上而下的编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.3-implicit-contexts.html">5.3 隐式上下文</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.4 使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 遍历代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.5-recursive-expansions.html">5.5 递归展开</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.6-recursive-solutions.html">5.6 递归方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.7-dlambda.html">5.7 Dlambda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter06/index.html">第六章：回指(Anaphoric) 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter07/index.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter08/index.html">第八章：Lisp 与 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendices/index.html">附录</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第五章：Programs that program</a> &raquo;</li>
      <li>5.4 使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 遍历代码</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Chapter05/5.4-code-walking-with-macrolet.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="macrolet">
<h1>5.4 使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 遍历代码<a class="headerlink" href="#macrolet" title="永久链接至标题"></a></h1>
<hr class="docutils" />
<p>Author: Doug Hoyte</p>
<p>Translator: Yuqi Liu &lt;<a class="reference external" href="mailto:yuqi&#46;lyle&#37;&#52;&#48;outlook&#46;com">yuqi<span>&#46;</span>lyle<span>&#64;</span>outlook<span>&#46;</span>com</a>&gt;</p>
<hr class="docutils" />
<blockquote>
<div><p>Lisp 不是门语言，而是构建语言的原料。 —— Alan Kay</p>
</div></blockquote>
<p>像计算机代码，写出的表达式结构基本不会说话，，因此往往会有多种不同的发音习惯。大多数
程序员在脑中会有个对话，推理表达式和读出运算符，有时是有意识的，但大部分情况下是无意
识的。例如，lisp 的 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 的发音最简单的方法就是把两个 lisp 关键字 （<code class="docutils literal notranslate"><span class="pre">macro</span></code> 和
<code class="docutils literal notranslate"><span class="pre">let</span></code>）连起来读。但看过 Steele 的 observation 后，部分程序员会用 <code class="docutils literal notranslate"><span class="pre">Chevrolet</span></code> 押韵的方式
来读 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code>，这种幽默的发音很难从脑中的对话中去掉。</p>
<p>不管 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 是怎么读的，它都是 lisp 高级编程里很重要的一部分。<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 是个特殊
的 COMMON LISP 结构，它在其封闭的词法作用域中引入新的宏。<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 的语法转换和
<code class="docutils literal notranslate"><span class="pre">defmacro</span></code> 定义全局的宏一样。就像 lisp 会在代码中展开以 <code class="docutils literal notranslate"><span class="pre">defmacro</span></code> 定义的宏，当 lisp
遍历代码中的表达式一样，<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 定义的宏也会被展开。</p>
<p>但 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 的不止有这么点功能。与 <code class="docutils literal notranslate"><span class="pre">defmacro</span></code> 相比，<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 有很多重要的优点。
首先，如果你想要通过给定不同的表达式的内容让宏以不同的方式展开，就需要使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code>
来创建不同的内容。而这是 <code class="docutils literal notranslate"><span class="pre">defmarco</span></code> 做不到的。</p>
<p>最重要的是，<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 很有用，因为遍历 COMMON LISP 表达式的代码很难。对任意的 lisp
代码树，假设是因为用宏在处理它，然后我们想要改变不同分支的值或含义。为了实现某些结构
的临时含义，以及临时重写某些特定宏（可能只是表达式词法上下文中特定部分），我们需要
遍历代码。具体来说，需要递归地遍历代码，在需要求值的位置查找所需的宏或函数名，然后
用自己的表达式替换他的位置。</p>
<p>很简单，对吧？难点在于，很多正常的 lisp 代码段会破坏原生的代码遍历的实现。假设我们想
要对一个函数执行的特定符号（ <code class="docutils literal notranslate"><span class="pre">blah</span></code> ）进行替换，当给出以下表达式时，就很容易看出替
换位置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">blah</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">blah</span></code> 所在的位置是表达式的函数位置，当表达式计算时，<code class="docutils literal notranslate"><span class="pre">blah</span></code> 会被调用，显然，我们需要
在这个时候对 <code class="docutils literal notranslate"><span class="pre">blah</span></code> 进行替换。目前来说还不错，但如果传入下面这个结构会怎么样呢？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;(blah t)</span>
</pre></div>
</div>
<p>因为表达式是被引用的，所以上面的代码的意思是直接返回一个列表。这里进行替换的话就会
出错。所以我们的代码遍历器在遇到引号（<code class="docutils literal notranslate"><span class="pre">'</span></code>）时，必须停止，同时不会去替换引用的结构中
的内容。很好，这也很简单。但考虑一下其他无法展开 blah 的场景。假如 <code class="docutils literal notranslate"><span class="pre">blah</span></code> 是个词法
变量的变量名呢？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">blah</span> <span class="n">t</span><span class="p">))</span>
  <span class="n">blah</span><span class="p">)</span>
</pre></div>
</div>
<p>尽管 <code class="docutils literal notranslate"><span class="pre">blah</span></code> 是列表中的第一个位置，但这里它是 <code class="docutils literal notranslate"><span class="pre">let</span></code> 结构中的本地绑定，而这种绑定是不
会被展开的。但这也不算太糟糕。解决办法是可以在代码遍历器中添加一些特殊的逻辑，这样
代码遍历器就知道在遇到 <code class="docutils literal notranslate"><span class="pre">let</span></code> 结构时该怎么处理。不幸的是，ANSI COMMON LISP 中还有
23 个这种的特殊结构，这些结构也需要添加特定的逻辑。更重要的是，许多特殊结构很复杂，
不能正确的进行遍历。 正如上面所见的 <code class="docutils literal notranslate"><span class="pre">let</span></code>，比较棘手，而且还有更糟的情况。下面一段
合规的 COMMON LISP 代码结构中有个 <code class="docutils literal notranslate"><span class="pre">blah</span></code> 需要展开。但是具体是哪一个呢？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">let</span> <span class="p">(</span><span class="n">blah</span> <span class="p">(</span><span class="n">blah</span> <span class="p">(</span><span class="n">blah</span> <span class="n">blah</span><span class="p">)))</span>
  <span class="n">blah</span><span class="p">)</span>
</pre></div>
</div>
<p>所以说遍历代码是很难的，因为要正确地处理特殊结构很难（见 [special-forms] 和
[USEFUL-LISP-ALGOS]）。注意，对定义为宏的结构，我们不会要特殊的逻辑。在遇到宏时，
可以简单地展开它，直到它变成函数调用或特殊的结构。如果是个函数的话，我们知道函数
遵循 lambda 从左到右且仅执行一次的语义。这才是需要开发特定的逻辑来处理的特殊结构。</p>
<p>听起来有很多工作要做，不是吗？事实确实是这样的。完整的 COMMON LISP 代码遍历器，
尤其是设计成可移植时，是段庞大且复杂的代码。那为什么 COMMON LISP 不提供个接口来
遍历 COMMON LISP 的代码呢？Emm，在某种程度上，COMMON LISP 确实提供了这个接
口，而这个接口的就叫做 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code>。代码遍历正是Common Lisp系统在计算或编译表达式
之前需要做的事情。就像我们假设的代码遍历器一样，COMMON LISP 需要理解并处理 <code class="docutils literal notranslate"><span class="pre">let</span></code>
和其他特殊结构的特殊语义。</p>
<p>因为 COMMON LISP 在执行代码时需要遍历这些代码，所以没必要写一个单独的代码遍历器。
如果想要对表达式选择性转换，以一种智能的方式来计算实际需要计算的内容，可以将这个转换
打包成宏，然后使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 结构将这个表达式包裹起来。当这个表达式被执行或编译时，
COMMON LISP 会遍历其代码，然后应用由 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 指定的宏转换。当然，由于
<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 定义了这些宏，所以它不会在运行时增加任何额外的开销。<code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 用于与
COMMON LISP 的代码遍历程序通信，而 COMMON LISP 对宏何时展开的唯一保证是它将在
编译函数的运行时之前完成。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 最常见的一个场景就是，当你想假装一个函数绑定在某个词法上下文中，
但希望使用这个结构的行为不是函数调用。<code class="docutils literal notranslate"><span class="pre">flet</span></code> 和 <code class="docutils literal notranslate"><span class="pre">labels</span></code> 就不行了：他们只能定义
函数。所以我们选择写个代码遍历器来调用该函数，并将其替换为别的，用 <code class="docutils literal notranslate"><span class="pre">defmacro</span></code>
定义一个全局宏所以该“函数”会展开成别的，或是将这个结构嵌在 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 中然后让
系统的代码遍历器来执行。</p>
<p>综上所述，实现个代码遍历器很难。如果可以的话，最好是避开这条路。用全局的
<code class="docutils literal notranslate"><span class="pre">defmacro</span></code> 有时可以实现，但通常都有问题。最大的问题是 COMMON LISP 无法保证
宏展开的时间或频率，因此无法可靠地在不同的词法上下文中使相同的变量名具有不同的
含义。当重写全局宏时，我们无法确定 COMMON LISP 之前使用该宏是否已经展开过，
或者之后是不是还需不需要再次进行展开。</p>
<p>为了举例说明这种代码遍历的用处，让我们重新讨论在 <a class="reference internal" href="../Chapter03/3.3-control-structures.html"><span class="doc std std-doc">3.3 Control Structures</span></a> 中忽略
的问题。名为 <code class="docutils literal notranslate"><span class="pre">nlet</span></code> 的 Scheme 初始版本的 <code class="docutils literal notranslate"><span class="pre">let</span></code> 宏，是用 <code class="docutils literal notranslate"><span class="pre">label</span></code> 这个特定的结构
创建了个新的控制结构类型。<code class="docutils literal notranslate"><span class="pre">labels</span></code> 的这种用法允许我们临时定义函数，以便在
<code class="docutils literal notranslate"><span class="pre">let</span></code> 主题中使用，该函数允许递归，就像在 <code class="docutils literal notranslate"><span class="pre">let</span></code> 绑定中再次使用 <code class="docutils literal notranslate"><span class="pre">let</span></code> 绑定新的值
一样。当定义这个函数时，我们提到，因为 COMMON LISP 不能保证它将优化掉尾调用，
所以这个 <code class="docutils literal notranslate"><span class="pre">let</span></code> 控制结构每次迭代都可能会占用不必要的额外堆栈空间。换句话说，不同
于 Scheme，COMMON LISP 函数调用不能保证是优化的尾部调用。</p>
<p>即使大部分像样的 COMMON LISP 编译器都会执行适当的尾部调用优化，有时我们需要
确认优化已经进行了。最简单的、可移植的实现方法是修改 <code class="docutils literal notranslate"><span class="pre">nlet</span></code> 宏，这样它生成展开
时就不会使用不必要的堆栈空间。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(defmacro! nlet-tail (n letargs &amp;rest body)
  (let ((gs (loop for i in letargs
                  collect (gensym))))
    `(macrolet
       ((,n ,gs
          `(progn
             (psetq
              ,@(apply #&#39;nconc
                       (mapcar
                         #&#39;list
                         &#39;,(mapcar #&#39;car letargs)
                         (list ,@gs))))
             (go ,&#39;,g!n))))
        (block ,g!b
          (let ,letargs
            (tagbody
              ,g!n (return-from
                     ,g!b (progn ,@body))))))))
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code> 中，我们将宏的主体嵌在了一些其他的结构中。我们用 <code class="docutils literal notranslate"><span class="pre">block</span></code> 和
<code class="docutils literal notranslate"><span class="pre">return-from</span></code> 语句来返回最后那个表达式的值，因为我们想要模拟 <code class="docutils literal notranslate"><span class="pre">let</span></code> 结构的行为
和它的隐式 <code class="docutils literal notranslate"><span class="pre">progn</span></code>。注意我们在 <code class="docutils literal notranslate"><span class="pre">block</span></code> 中用了 <code class="docutils literal notranslate"><span class="pre">gensym</span></code> 变量名，同时在每个 <code class="docutils literal notranslate"><span class="pre">let</span></code>
中都用 <code class="docutils literal notranslate"><span class="pre">gensym</span></code> 生成参数名，这样可以避免不必要的异常捕获，然后用 <code class="docutils literal notranslate"><span class="pre">loop</span></code> 宏将这
些 <code class="docutils literal notranslate"><span class="pre">gensyms</span></code> 汇集起来。</p>
<p><code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code> 和我们最初的 <code class="docutils literal notranslate"><span class="pre">nlet</span></code> 的结构是一样的，除了非尾部的 <code class="docutils literal notranslate"><span class="pre">let</span></code> 结构调用被
禁用，因为这些 <code class="docutils literal notranslate"><span class="pre">let</span></code> 结构会展开成尾部调用。下面是个和介绍 <code class="docutils literal notranslate"><span class="pre">nlet</span></code> 是使用一样无趣
的例子，不同的是这个例子中可以保证，即使在不执行尾部调用优化的 lisp 中，也不会
消耗额外的堆栈空间。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defun</span> <span class="n">nlet</span><span class="o">-</span><span class="n">tail</span><span class="o">-</span><span class="n">fact</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">(</span><span class="n">nlet</span><span class="o">-</span><span class="n">tail</span> <span class="n">fact</span> <span class="p">((</span><span class="n">n</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">acc</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">zerop</span> <span class="n">n</span><span class="p">)</span>
      <span class="n">acc</span>
      <span class="p">(</span><span class="n">fact</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span> <span class="n">acc</span> <span class="n">n</span><span class="p">)))))</span>
</pre></div>
</div>
<p>因为这是本节的示例，注意，我们用 <code class="docutils literal notranslate"><span class="pre">macrolet</span></code> 对提供的内容进行代码遍历，来查找
<code class="docutils literal notranslate"><span class="pre">fact</span></code>。在之前的 <code class="docutils literal notranslate"><span class="pre">nlet</span></code> 用 <code class="docutils literal notranslate"><span class="pre">labels</span></code> 来制定结构绑定函数的地方，我们希望确保在调用
<code class="docutils literal notranslate"><span class="pre">let</span></code> 结构时不会消耗额外的堆栈空间。从技术上来说，我们希望修改词法环境中的一些
绑定，然后跳转回这个 <code class="docutils literal notranslate"><span class="pre">let</span></code> 结构的顶部。因此 <code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code> 接受上面示例中 <code class="docutils literal notranslate"><span class="pre">let</span></code> 的
名称，并创建个本地宏，该宏只在对应的代码主体中生效。这个宏展开的代码中，使用
<code class="docutils literal notranslate"><span class="pre">psetq</span></code> 将 <code class="docutils literal notranslate"><span class="pre">let</span></code> 的绑定设为提供的新的值，然后跳转回顶部，不需要堆栈空间。最重要
的是，我们可以在程序中其他无关的宏中使用 <code class="docutils literal notranslate"><span class="pre">fact</span></code> 这个变量名。</p>
<p>为了实现这个跳转， <code class="docutils literal notranslate"><span class="pre">nlet-tail</span></code> 使用了 lisp 的特殊结构 ——<code class="docutils literal notranslate"><span class="pre">tagbody</span></code> 和 <code class="docutils literal notranslate"><span class="pre">go</span></code> 的组合。
这两个结构提供了个跳转（goto）系统。尽管结构化编程带来的问题（不管这意味着什么）
讨论广泛，COMMON LISP 提供这些特殊结构的原因正是我们在这里使用它们的原因。通过
控制程序计数器（执行中代码的当前位置），可以创建很有效的宏展开。虽然在现代高级语
言中，通常都不推荐用 <code class="docutils literal notranslate"><span class="pre">goto</span></code>，但快速浏览任意的汇编代码，就会发现 <code class="docutils literal notranslate"><span class="pre">goto</span></code> 在计算机软件
最底层上非常活跃。即使是最坚定的反 <code class="docutils literal notranslate"><span class="pre">goto</span></code> 倡导者也不建议抛弃像 C 这样的低级语言以及
<code class="docutils literal notranslate"><span class="pre">goto</span></code> 和 <code class="docutils literal notranslate"><span class="pre">jump</span></code> 汇编指令。在底层编程中，要想写出高效的代码，似乎只要 <code class="docutils literal notranslate"><span class="pre">goto</span></code>。</p>
<p>然而，正如 Alan Kay 所说， lisp 不是门语言，而是个构建原料。讨论 lisp 是否是高级还是
低级语言完全没有意义。有很高级的 lisp，如特定域（domain specific）语言。通过编写的
用于处理这些语言的宏，我们将它们的用法转换为较低层次的 lisp。当然，这些展开也是
lisp 代码，只是不像原始版本那样压缩。接下来，通常我们将这个中级的 lisp 代码交给编译器，
编译器会将这些代码转换为更低级别的 lisp 代码。用不多久，诸如 <code class="docutils literal notranslate"><span class="pre">go-to</span></code>、条件分支和位
填充等概念就会出现在代码中，但即便如此，代码还是 lisp。最后，使用本地代码编译器，
高级 lisp 程序将会转换成汇编语言。但即使是这时，代码依然还是 lisp。这是因为大部分 lisp
汇编程序都是用 lisp 本身编写的，所以很自然地这些汇编程序都保存为 lisp 对象，这样就产生
真正的 lisp 底层程序。只有程序真正变成二进制机器码时，它才不再是lisp。难道不是吗？</p>
<p>高阶或低阶的区别在 lisp 中不适用，lisp 程序的级别完全取决于视角。 Lisp 不是门语言，而是
迄今为止所发现的最灵活的软件构建原料。</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="5.3-implicit-contexts.html" class="btn btn-neutral float-left" title="5.3 隐式上下文" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="5.5-recursive-expansions.html" class="btn btn-neutral float-right" title="5.5 递归展开" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021-2022, Yuqi Liu, Xuting Yang.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>