# 8.1 奇怪的设计

---

Author: Doug Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>

Translator: Yuqi Liu <[yuqi.lyle@outlook.com](mailto:yuqi.lyle@outlook.com)>

---

本章是迄今为止我们在本书中看到的许多宏技术的高潮。 使用已开发的宏抽象，我们创建了我最喜欢的编程语言之一的实现：forth。 虽然这个实现体现了 forth 的大部分重要思想，但它非常不同并且很混乱。 尽管本章中的代码有一些有趣的用途，但主要目的是向 lisp 读者教授 forth 元编程的概念和基础知识，并成为讨论本书中心主题的平台——用宏创建和使用二元性语法。


Forth，比除了 lisp 外所有语言都拥有丰富而迷人的历史，我很感激发现它。 出于这个原因，以及其他一切，这一章是献给我的父亲 Brian Hoyte <[doug@hoytech.com](mailto:doug@hoytech.com)>
 的，他向我介绍了 forth 和计算机编程。 本章的部分灵感来自 [THREADING-LISP] 和 Henry Baker [LINEAR-LISP][LINEAR-LISP-AND-FORTH] 的研究。


Forth 是第一个在没有强力的政府、学术或企业赞助的情况下创建和开发的编程语言——或者至少是第一个成功的此类语言。 1968 年左右，Chuck Moore 独立发明了forth，而不是出于大型组织的需求，以解决他自己在天文学、硬件设计等方面的计算需求。 从那时起，forth 已被热情的草根用户社区分发、实现和改进[EVOLUTION-FORTH-HOPL2]。 与麻省理工学院（以及后来的 DARPA）对早期 lisp 和 Common Lisp、IBM 的 FORTRAN 和 AT&T 的 unix 语言 C 的赞助形成对比。


由于这些原因，并且因计算机软件和硬件角色的普遍不同的哲学，所以 forth 是不同的。 甚至比 lisp 还要多，forth 看起来很奇怪。 但是和 lisp 一样，forth 看起来很奇怪是有原因的：它的设计考虑了更多而不是格式。 Forth 在设计上很奇怪，而且这种设计与宏有关。


如今，forth 常见于所谓的嵌入式平台——资源严重受限的计算机。 可以在几乎所有曾经创建的可编程计算机系统上完全实现该语言，这证明了该语言的设计。 Forth 被设计成尽可能容易实现和试验。 事实上，创建 forth 的克隆是如此的微不足道，以至于发明一两种基于堆栈的 forth 语言对于对编程语言设计感兴趣的程序员来说几乎是一种仪式。 PostScript 和 Joy 这些基于堆栈的语言，它们可以追溯到 forth 并做出了有趣的贡献。


重要的 forth 实现决策通常基于正在实现 forth 的计算机的确切资源。 Forth 程序员设计了一组抽象寄存器，这些寄存器要么映射到真实寄存器，要么映射到内存位置，或者可能以完全不同的方式实现。 但是，如果我们在 lisp 上实现 forth，一个潜力无限且限制很少的环境，该怎么做呢？ 不是简单地将 forth 抽象寄存器的任意映射强加到 lisp 代码中，而是尝试退后一步。 如果 Chuck 有一个 lisp 机器会是什么样子？ 与其适应任意机器的功能，无论是真实的还是虚拟的，我们探索了一组最小的抽象寄存器，在 lisp 上实现时针对简单性和功能进行了优化。


但实际上，寻找一组最优的抽象概念是 Chuck 在创建 forth 时所做的，应用了他在很多架构上的数十种不同的 forth 实现经验。 这就是为什么 forth 如此伟大。 与 lisp 一样，forth 代表了语言设计空间中的高局部最大值，并且与 lisp 一样，forth 与其说是门编程语言或标准，不如说是种构建材料和智慧的集合，关于什么有效，什么无效。
```
(defvar forth-registers
  '(pstack rstack pc
    dict compiling dtable))
```
`forth-registers`表示 forth 机器的抽象寄存器的符号列表。 当然 lisp 不考虑寄存器和固定数字，而是变量和符号。 在这里开始我们开发 forth 环境看起来可能很奇怪，只有一个变量名列表，但实际上这始终是实现 forth 系统的第一步。 创造 forth 是个巧妙的引导过程，在美丽和聪明方面只有 lisp 才能超越。 以下是对该过程的适度描述。


forth 的特征之一是它直接访问程序使用的堆栈数据结构，既可以将参数传递给子例程，也可以跟踪这些子例程中的执行路径。 Forth 特别有趣，因为与大多数编程语言不同，它将堆栈数据结构的这两种用途分为两个堆栈，这两个堆栈你设置可以玩弄它。 在典型的 C 实现中，函数调用的参数及其所谓的返回地址存储在单个、可变大小的堆栈帧中，用于每个函数调用。 forth，它们是两个不同的堆栈，称为参数堆栈和返回堆栈，分别表示为我们的抽象寄存器 `pstack`和 `rstack`。 我们使用 Common Lisp 的 push 和 pop 宏，这意味着这些堆栈是用 cons 单元链表实现的，而不是大多数使用的数组数据结构。


抽象寄存器 pc 是程序计数器的缩写，一个指向当前正在执行的代码的指针。 我们将很快解释什么是代码以及如何指向它，以及我们的抽象寄存器编译和 dtable。
```
(defstruct forth-word
  name prev immediate thread)
```
另一个构建 forth 模块是其字典概念。  forth 字典是 forth words 的单链表，类似于lisp函数。 words 用 lisp 结构表示。 结构是基于槽的有效数据结构，通常用向量实现。 word 槽是用于在字典中查找单词的符号。 请注意，forth 字典不是按字母顺序存储的，而是按时间顺序存储的。 当添加新单词时，会将新的 words 追加到字典的末尾，以便在遍历字典时首先检查最新定义的 words。 字典的最后一个元素总是存储在抽象寄存器字典中。 为了遍历字典，从 `dict` 开始并跟随单词结构的 prev 指针，prev 指针指向先前定义的 word，如果是最后一个 word 的话，prev 指针指向 nil。


给定 `w`，一个要查找的单词，最后是要检索的字典，根据单词 `w` 是否在字典中找到，`forth-lookup`将返回个 forth 单词结构或 nil。 使用比较函数 `eql` 代替 `eq` 是因为 —— 与 lisp 不同 —— forth 允许用数字和其他非符号命名单词。
```
(defun forth-lookup (w last)
  (if last
    (if (eql (forth-word-name last) w)
      last
      (forth -lookup
        w (forth-word-prev last)))))
```
forth 词的 immediate 槽是个标志，指示该单词是否是立即的。即时性是 forth 元编程概念，我们将很快深入探讨。现在这里是一个与其 lisp 对应物的粗略类比：立即字就像 lisp 宏，因为它们是在编译时而不是运行时执行的 forth 函数。什么？只有 lisp 应该有宏。虽然 Common Lisp 宏系统确实比任何其他宏系统（包括最佳的 forth）强大得多，但 forth 的扩展能力几乎超过了所有其他语言。与 lisp 一样，这种能力是一种设计理念的结果：如果它对语言实现者来说足够好，那么对于应用程序程序员来说也足够好。像 lisp 一样，forth 并没有真正认识到原始的概念。相反，它提供了一组元基元，可以将它们组合起来以构建你（程序员）想要的语言。与 lisp 一样，与大多数 Blub 语言不同，通过使用宏以新颖的方式扩展语言不仅是可能的，而且是鼓励的。像 lisp 一样，forth 与格式无关，而与强大有关。
