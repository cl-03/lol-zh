
<!-- saved from url=(0054)https://letoverlambda.com/textmode.cl/guest/chap6.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Let Over Lambda</title>
</head><body>

<center>
<h1>Let Over Lambda -- 50 Years of Lisp</h1>
<h2>by Doug Hoyte</h2>
</center>
<h2>Anaphoric Macros</h2>

<script type="text/javascript">
function toggle_note(n) {
  if (document.getElementById("note_"+n).style.display == "") {
    document.getElementById("note_"+n).style.display = "none";
  } else {
    document.getElementById("note_"+n).style.display = "";
  }
}
</script><h3 id="sec_1">More Phors?</h3>
<p>Some of the most interesting macros from Paul Graham's <i>On Lisp</i> are <i>anaphoric macros</i>. An anaphoric macro is one that deliberately captures a variable from forms supplied to the macro. Thanks to their <i>transparent specifications</i>, these deliberately captured variables allow us windows of control over the macro expansion. Through these windows we can manipulate the expansion through <i>combinations</i>.</p><p>The classic anaphora like those in <i>On Lisp</i> are named after the literal words<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(1); return false"><sup>1</sup></a><span id="note_1" style="display:none"> <sup><i>A U-language quotation.</i></sup> </span> <i>anaphor</i> and its plural, <i>anaphora</i>. An anaphor is a means of capturing a <i>free U-language word</i> for use in subsequent U-language. In programming terms, implementing a classic anaphor means finding places in your code—or in code you would like to write—where expressions can benefit from being able to refer to the results of previous, related expressions. Graham's anaphora and associated code are worth careful study. Especially see the <b>defanaph</b> macro<sup><small>[ON-LISP-P223]</small></sup> which enables some interesting types of <i>automatic anaphor</i> programming.</p><p>After some period of use, <b>alambda</b> has been found to be the most useful of the anaphoric macros in <i>On Lisp</i>. It is also one of the most simple and elegant demonstrations of an anaphoric macro and its intentional variable capture.</p><p></p><fieldset><legend>ALAMBDA</legend><pre class="lol_code">;; Graham's alambda
(defmacro alambda (parms &amp;body body)
  `(labels ((self ,parms ,@body))
     #'self))</pre></fieldset><p></p><p>With <b>alambda</b> we capture the name <b>self</b> so that we can use it to refer to the very anonymous function we are building. In other words, recursing is as simple as a call to <b>self</b>. For example, the following function returns a list<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(2); return false"><sup>2</sup></a><span id="note_2" style="display:none"> <sup><i>If the condition is false, an absent tertiary clause on an if form returns <b>nil</b>, which is a list.</i></sup> </span> of the numbers from <b>n</b> down to 1:</p><p></p><pre class="lol_pre">(alambda (n)
  (if (&gt; n 0)
    (cons
      n
      (self (- n 1)))))</pre><p></p><p><b>Alambda</b> lets our code be intuitive and easy to read, and allows us to change our mind about whether an anonymous function should be able to call itself as easily as adding a single letter<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(3); return false"><sup>3</sup></a><span id="note_3" style="display:none"> <sup><i>This is another reason to not sharp-quote lambda forms. Changing a sharp quoted lambda form to an alambda form also requires deleting two characters.</i></sup> </span>. Because of <b>alambda</b>'s transparent specification for the <b>self</b> binding—and the fact that the only reason to ever use <b>alambda</b> is to make use of this binding—unwanted variable capture is never a problem.</p><p></p><fieldset><legend>AIF</legend><pre class="lol_code">;; Graham's aif
(defmacro aif (test then &amp;optional else)
  `(let ((it ,test))
     (if it ,then ,else)))</pre></fieldset><p></p><p>Another handy anaphoric macro from <i>On Lisp</i> is <b>aif</b>, a macro that binds the result of the test clause to <b>it</b> for the true (secondary or consequent) clause to make use of<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(4); return false"><sup>4</sup></a><span id="note_4" style="display:none"> <sup><i>Exercise: Why would the false (tertiary or alternant) clause never make use of this anaphor?</i></sup> </span>. <b>Aif</b> makes use of a valuable C<small>OMMON</small> L<small>ISP</small> feature: <i>generalised booleans</i>. In C<small>OMMON</small> L<small>ISP</small>, any non-nil value is a true boolean value so C<small>OMMON</small> L<small>ISP</small> programmers typically embed interesting information in truth values. Languages that have reserved true and false values—notably Scheme—employ <i>explicit booleans</i>, which sometimes force you to throw out extra information to satisfy redundant type constraints. Scheme has actually added a <i>kludge</i> to allow <b>if</b>, <b>cond</b>, <b>and</b>, <b>or</b>, and <b>do</b> to accept non-boolean<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(5); return false"><sup>5</sup></a><span id="note_5" style="display:none"> <sup><i>According to the Scheme <b>boolean?</b> predicate.</i></sup> </span> values<sup><small>[R5RS-P25]</small></sup>. C<small>OMMON</small> L<small>ISP</small>, of course, is designed <i>right</i>—everything is a boolean.</p><p>It must also be pointed out that <b>aif</b> and <b>alambda</b>, like all anaphoric macros, violate <i>lexical transparency</i>. A fashionable way of saying this is currently to say that they are <i>unhygienic</i> macros. That is, like a good number of macros in this book, they invisibly introduce lexical bindings and thus cannot be created with macro systems that strictly enforce hygiene. Even the vast majority of Scheme systems, the platform that has experimented the most with hygiene, provide unhygienic defmacro-style macros—presumably because not even Scheme implementors take hygiene very seriously. Like training wheels on a bicycle, hygiene systems are for the most part toys that should be discarded after even a modest level of skill has been acquired.</p><p>Yes, there are many interesting things we can do with deliberate variable capture. There are a lot more phors. This book and Graham's <i>On Lisp</i> describe a only a tiny fraction of the potential inherent to this technique. Many more incredible inventions will come out of the intelligent application of anaphoric macros.</p><p>After a brief interlude into anaphora introduced by read macros, the remainder of this chapter describes a modest, specific application of anaphora related to one of the central themes of this book: the lexical closure—<i>let over lambda</i>. Most of this chapter describes interesting anaphoric macros for customising, adapting, and extending closures. Although the topics are very practical for use in real code, their main purpose is as a platform for discussing the properties and variations of anaphoric macros. Using macros to extend the concept of a closure is currently a hot research topic<sup><small>[FIRST-CLASS-EXTENTS]</small></sup><sup><small>[OPENING-CLOSURES]</small></sup>.</p><h3 id="sec_2">Sharp-Backquote</h3>
<p>Although most anaphora are introduced by regular macros, read macros also have the potential to introduce code that invisibly creates bindings for us. When read macros do so, they are called <i>read anaphora</i>. This section presents one such read macro that, while itself very modest, surprised even myself by turning out to be one of the most consistently useful throughout this book. I have tried to introduce this macro as soon as possible so that it can be used for the remainder of the code. Already, several macros shown should have used it.</p><p></p><fieldset><legend>SHARP-BACKQUOTE</legend><pre class="lol_code">(defun |#`-reader| (stream sub-char numarg)
  (declare (ignore sub-char))
  (unless numarg (setq numarg 1))
  `(lambda ,(loop for i from 1 to numarg
                  collect (symb 'a i))
     ,(funcall
        (get-macro-character #\`) stream nil)))

(set-dispatch-macro-character
  #\# #\` #'|#`-reader|)</pre></fieldset><p></p><p>Sharp-backquote is a read macro that reads in as a lambda form. By default, this lambda form will take exactly one argument: <b>a1</b>. The read macro then recursively invokes the <b>read</b> function with the supplied stream. Here is an example with the evaluation stopped (by <b>quote</b>) so we can observe the transparent introduction of the read anaphor<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(6); return false"><sup>6</sup></a><span id="note_6" style="display:none"> <sup><i>The prefix of the captured symbol, "a", of course stands for anaphor.</i></sup> </span>:</p><p></p><pre class="lol_pre">* '#`((,a1))

(LAMBDA (A1)
  `((,A1)))</pre><p></p><p>This read macro abstracts out a common macro pattern. For example, if we have a list of variables and would like to make a list of let bindings that bind each variable to a symbol, say, <b>empty</b>, we can use <b>mapcar</b> like so:</p><p></p><pre class="lol_pre">* (mapcar (lambda (a)
            (list a ''empty))
    '(var-a var-b var-c))

((VAR-A 'EMPTY)
 (VAR-B 'EMPTY)
 (VAR-C 'EMPTY))</pre><p></p><p>But especially for complicated list structure, this can get messy, so lisp programmers like to use backquote to knock it up one level of quotation:</p><p></p><pre class="lol_pre">* (mapcar (lambda (a)
            `(,a 'empty))
    '(var-a var-b var-c))

((VAR-A 'EMPTY)
 (VAR-B 'EMPTY)
 (VAR-C 'EMPTY))</pre><p></p><p>Our new anaphor-introducing read macro hides the lambda form:</p><p></p><pre class="lol_pre">* (mapcar #`(,a1 'empty)
    '(var-a var-b var-c))

((VAR-A 'EMPTY)
 (VAR-B 'EMPTY)
 (VAR-C 'EMPTY))</pre><p></p><p>The reason for the <b>1</b> character in the symbol <b>a1</b> above is that users of the read macro can introduce a variable number of anaphora depending on the number provided to the <b>numarg</b> parameter of the read macro:</p><p></p><pre class="lol_pre">* '#2`(,a1 ,a2)

(LAMBDA (A1 A2)
  `(,A1 ,A2))</pre><p></p><p>So we can <b>mapcar</b> sharp-backquote expressions across more than one list at a time:</p><p></p><pre class="lol_pre">* (let ((vars '(var-a var-b var-c)))
    (mapcar #2`(,a1 ',a2)
      vars
      (loop for v in vars
            collect (gensym
                      (symbol-name v)))))

((VAR-A '#:VAR-A1731)
 (VAR-B '#:VAR-B1732)
 (VAR-C '#:VAR-C1733))</pre><p></p><p>Another way to think about sharp-backquote is that it is to list interpolation as the <b>format</b> function is to string interpolation. Just as format lets us use a template with slots that are to be filled with the values of separate arguments, sharp-backquote lets us separate the structure of the list interpolation from the values we want to splice in. Because of the earlier described <i>duality of syntax</i> between lambda forms in the function position of a list and the lambda forms that use the <b>lambda</b> macro to expand into a function, we can also use sharp-backquote as the first element in a function call:</p><p></p><pre class="lol_pre">* (#3`(((,a1)) ,@a2 (,a3))
      (gensym)
      '(a b c)
      'hello)

(((#:G1734)) A B C (HELLO))</pre><p></p><p>Unlike <b>format</b>, sharp-backquote doesn't use sequential positioning. Instead it uses the number on our anaphoric bindings. As a consequence, the order can be mixed up and we can even splice in bindings more than once:</p><p></p><pre class="lol_pre">* (#3`(((,@a2)) ,a3 (,a1 ,a1))
      (gensym)
      '(a b c)
      'hello)

(((A B C)) HELLO (#:G1735 #:G1735))</pre><p></p><p>Exercise: The references to the gensym <b>#:G1735</b> look like they point to the same symbol but, of course, you never really can tell with gensyms by looking at their print names. Are these symbols <b>eq</b>? Why or why not?</p><h3 id="sec_3">Alet and Finite State Machines</h3>
<p>With <i>lambda</i> and <i>if</i> there is only one useful anaphoric configuration. But the most interesting types of anaphoric macros make use of expansions in unforeseen ways. This section—even most of this chapter—is based around one such macro: <b>alet</b>. What extra bindings could be useful to forms inside the body of a let form? The very purpose of <b>let</b> is to create such bindings so capturing the variable introductions given to a let form is already done. However, a macro enhancement to <b>let</b> can have complete access to all the forms given to it, even the body of expressions intended to be evaluated with the new bindings. So what is the most useful part of the body? In most cases it is the last form in the body since the results from that form will be returned from the let statement itself<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(7); return false"><sup>7</sup></a><span id="note_7" style="display:none"> <sup><i>Because <b>let</b> provides an implicit progn.</i></sup> </span>. We've seen that when we return a lambda expression that references these bindings created by <b>let</b>, the result is a lexical closure—an object frequently stored and used to later access the variables in the let statement. So, extending our closure-object analogy, the <b>alet%</b> macro acts exactly like the <b>let</b> special form except that it captures the symbol <b>this</b> from the body and binds it to the last expression in the form's body—the one that will be returned as the closure<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(8); return false"><sup>8</sup></a><span id="note_8" style="display:none"> <sup><i><b>Setq</b> is used so that the form bound to <b>this</b> is defined in the lexical scope of the other arguments given by <b>letargs</b>.</i></sup> </span>.</p><p></p><fieldset><legend>ALET-1</legend><pre class="lol_code">(defmacro alet% (letargs &amp;rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     this))</pre></fieldset><p></p><p><b>Alet%</b> can be useful when we have initialisation code in the lambda form that we don't want to duplicate. Because <b>this</b> is bound to the lambda form that we are returning, we can execute it before we return it from the enclosing let. The following is a closure whose construction shows a simple example use of <b>alet%</b> that avoids duplicating its reset and initialisation code:</p><p></p><pre class="lol_pre">* (alet% ((sum) (mul) (expt))
    (funcall this :reset)
    (dlambda
      (:reset ()
        (psetq sum 0
               mul 1
               expt 2))
      (t (n)
        (psetq sum (+ sum n)
               mul (* mul n)
               expt (expt expt n))
        (list sum mul expt))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Which we can call successively to change the values of <b>sum</b>, <b>mul</b>, and <b>expt</b>:</p><p></p><pre class="lol_pre">* (loop for i from 1 to 5 collect (funcall * 2))

((2 2 4)
 (4 4 16)
 (6 8 256)
 (8 16 65536)
 (10 32 4294967296))</pre><p></p><p>We can now reset the closure by invoking its <b>:reset</b> method. Notice that we only had to write the reset base cases (0 for <b>sum</b>, 1 for <b>mul</b>, and 2 for <b>expt</b>) in one location thanks to <b>alet%</b>:</p><p></p><pre class="lol_pre">* (funcall ** :reset)

NIL</pre><p></p><p>Now that the closure's variables are reset, we can see a new sequence from the start:</p><p></p><pre class="lol_pre">* (loop for i from 1 to 5 collect (funcall *** 0.5))

((0.5 0.5 1.4142135)
 (1.0 0.25 1.1892071)
 (1.5 0.125 1.0905077)
 (2.0 0.0625 1.0442737)
 (2.5 0.03125 1.0218971))</pre><p></p><p>Note that <b>alet%</b> changes the evaluation order of the forms in the let body. If you look at the expansion you will notice that the last form in the body is actually evaluated first, and its results are then bound to the lexical binding <b>this</b> before the preceding forms are evaluated. As long as the last argument is a constant, however, this re-ordering makes no difference. Remember that a lambda expression<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(9); return false"><sup>9</sup></a><span id="note_9" style="display:none"> <sup><i><b>Dlambda</b> expands into lambda forms.</i></sup> </span> is a constant value and is thus perfectly suitable for use in <b>alet%</b>.</p><p>As with many macro enhancements, because of the many degrees of freedom available, improvements to this macro are counterintuitive. Although there are many possibilities, this section considers one such specific improvement. <b>Alet%</b> can be made to not return the last form in its body—which we anticipate to be a lambda form—but instead a function that looks up another function inside the let form's lexical scope, then calls that function instead. This is sometimes called <i>indirection</i> because instead of returning a function to do something, we return a function that looks up a function using a pointer dereference, then uses that function instead. Indirection is a concept ubiquitous throughout programming languages for good reason. It lets us change things at run-time that, without indirection, are fixed at compile-time. Lisp lets us use indirection in a more succinct and efficient manner than many other programming languages. <b>Alet</b>, a version of <b>alet%</b> with indirection added, allows the function we returned as the closure to now be accessed or replaced by code inside the alet body, or, if we use <b>dlambda</b>, as will be shown soon, even outside the alet body.</p><p></p><fieldset><legend>ALET</legend><pre class="lol_code">(defmacro alet (letargs &amp;rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     (lambda (&amp;rest params)
       (apply this params))))</pre></fieldset><p></p><p>Now that we can change the function that gets executed when invoking a closure with our <b>alet</b> macro we can create a pair of mutually referential functions using a pattern called <i>alet over alambda</i>. As long as all the states go back to the original state—instead of going to each other—alet over alambda is a convenient way to specify nameless state machines.</p><p>The following is a typical counter closure that takes an argument <b>n</b> and can have its direction toggled between increment and decrement by <b>n</b> when we pass the symbol <b>invert</b> as the argument instead of a number:</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (alambda (n)
      (if (eq n 'invert)
        (setq this
              (lambda (n)
                (if (eq n 'invert)
                  (setq this #'self)
                  (decf acc n))))
        (incf acc n))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Let's store this closure so we can use it as often as we want:</p><p></p><pre class="lol_pre">* (setf (symbol-function 'alet-test) *)

#&lt;Interpreted Function&gt;</pre><p></p><p>When we start, we are going up:</p><p></p><pre class="lol_pre">* (alet-test 10)

10</pre><p></p><p>But we can change the actual function to be called to the internal lambda expression in our definition by passing the symbol <b>invert</b> to the closure:</p><p></p><pre class="lol_pre">* (alet-test 'invert)

#&lt;Interpreted Function&gt;</pre><p></p><p>And now we're going down:</p><p></p><pre class="lol_pre">* (alet-test 3)

7</pre><p></p><p>Finally, thanks to the <b>self</b> binding provided by <b>alambda</b>, we can again change the function to be called by passing the symbol <b>invert</b>:</p><p></p><pre class="lol_pre">* (alet-test 'invert)

#&lt;Interpreted Function&gt;</pre><p></p><p>Back where we started, going up:</p><p></p><pre class="lol_pre">* (alet-test 5)

12</pre><p></p><p>This closure has been bound in the function namespace to the symbol <b>alet-test</b>. But this closure is slightly different than a regular closure. While both this closure and regular closures are pointers to a single environment, one that can have any number of references to it, this closure uses indirection to change which piece of code gets run when it is invoked. Although any piece of code can be installed, only ones in the lexical scope of the <b>alet</b>, the one with the <b>this</b> anaphor available, can access its lexical bindings. But there is still nothing to prevent us from installing a new closure, with its own lexical bindings and perhaps with changed behaviour in the <i>indirection environment</i> installed by <b>alet</b>. Much of the remainder of this chapter is about useful things we can do with indirection environments created by <b>alet</b>.</p><p>A common macro technique is informally known as <i>turning a macro inside out</i>. When you turn a macro inside out you pick a typical form that uses a macro similar to the macro you would like to create, and expand it. You then use that expansion as a template for your desired macro. For example, we would like a more general method of creating closures with multiple states than the alet over alambda counter presented earlier. Here is the above inside out expansion of the invertible counter alambda use case:</p><p></p><pre class="lol_pre">* (macroexpand
   '(alambda (n)
      (if (eq n 'invert)
        (setq this
              (lambda (n)
                (if (eq n 'invert)
                  (setq this #'self)
                  (decf acc n))))
        (incf acc n))))

(LABELS ((SELF (N)
          (IF (EQ N 'INVERT)
            (SETQ THIS
                  (LAMBDA (N)
                    (IF (EQ N 'INVERT)
                      (SETQ THIS #'SELF)
                      (DECF ACC N))))
            (INCF ACC N))))
  #'SELF)</pre><p></p><p>If we re-factor the above expansion slightly to take advantage of the fact that <b>labels</b> allows us to create multiple function bindings<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(10); return false"><sup>10</sup></a><span id="note_10" style="display:none"> <sup><i>Hence the plurality of <b>labels</b>.</i></sup> </span>, we arrive at the following:</p><p></p><pre class="lol_pre">(alet ((acc 0))
  (labels ((going-up (n)
             (if (eq n 'invert)
               (setq this #'going-down)
               (incf acc n)))
           (going-down (n)
             (if (eq n 'invert)
               (setq this #'going-up)
               (incf acc (- n)))))
    #'going-up))</pre><p></p><p>From this, we notice that <b>alambda</b> can use the <b>labels</b> special form to make all of its bindings available to all of the bodies of its functions. What's more, we now have a fairly complete template for our eventual macro.</p><p></p><fieldset><legend>ALET-FSM</legend><pre class="lol_code">(defmacro alet-fsm (&amp;rest states)
  `(macrolet ((state (s)
                `(setq this #',s)))
     (labels (,@states) #',(caar states))))</pre></fieldset><p></p><p><b>Alet-fsm</b> gives us a convenient syntax for expressing multiple possible <i>states</i> for our closure to exist in. It is a very light sugar coating of macros over top of <b>labels</b>, combined with a <i>code-walking</i> <b>macrolet</b> transformation that allows us to pretend as though we have a function, <b>state</b>, that can change the closure's current state, accessed through the <b>this</b> anaphor provided by <b>alet</b>. As an example, here is a cleaner version of our invertible counter:</p><p></p><pre class="lol_pre">(alet ((acc 0))
  (alet-fsm
    (going-up (n)
      (if (eq n 'invert)
        (state going-down)
        (incf acc n)))
    (going-down (n)
      (if (eq n 'invert)
        (state going-up)
        (decf acc n)))))</pre><p></p><p><b>Alet-fsm</b> is an instance of a technique we haven't seen before: <i>anaphor injection</i>. The use of this anaphor violates lexical transparency in so many ways that it is actually, somehow, <i>lexically invisible</i>. Not only does <b>alet</b> bind <b>this</b> for us invisibly, but the use of <b>this</b> by our <b>alet-fsm</b> macro is similarly invisible. <b>Alet-fsm</b> injects a free variable into our lexical context without us being able to see it at all in the lexical context.</p><p>The stylistic issues of this are uncertain<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(11); return false"><sup>11</sup></a><span id="note_11" style="display:none"> <sup><i>As are, by nature, all stylistic issues. Once something is perfectly understood, style becomes irrelevant. Free variable injection is not yet perfectly understood.</i></sup> </span>, but macro programming is, of course, not about style. It is about power. Sometimes free variable injection can create a symbiosis between two macros—one that can better programmatically construct expansions than can two isolated expansions. Because this type of macro programming is sophisticated, parallels can again be drawn to the C pointer analogy. Just as learning C pointers breeds dubious stylistic advice, so does free variable injection.</p><p>The most plausible hypothesis for the source of difficulty in understanding free variable injection is its <i>fail-safe</i> behaviour<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(12); return false"><sup>12</sup></a><span id="note_12" style="display:none"> <sup><i>Safe in the sense that, contrary to the real world, failing as quickly and as loudly as possible is safest.</i></sup> </span>. With an anaphor, if the supplied user code doesn't make use of the binding the code will probably continue to function, whether you intended it to or not. It has, possibly, failed silently and thus un-safely. However, when you inject a free variable and there is no environment there to capture it, your entire expression has become free. When this happens, you need to decide what to do before you can evaluate that expression. It has failed safe.</p><p>Style aside, free variable injection is sometimes just what we need when we want two related macros to communicate back and forth. Injection is really the same operation as that performed by anaphora, just in the opposite direction. Because you are opening up a new channel of communication between your macros, the complexity issues scale even more quickly. Consider sitting in a house full of fragile glass. You can safely throw objects to people outside the house, even if they don't bother catching them, but you had better make sure you catch any objects thrown back at you.</p><h3 id="sec_4">Indirection Chains</h3>
<p>There are many ways we can take advantage of the <b>this</b> anaphor provided by <b>alet</b>. Since the environment is accessed through a dummy closure that forwards all invocations to the real closure pointed to by <b>this</b>, we can pass the dummy closure reference around, copying it as often as needed. <i>Indirection</i> like this is useful because we can change what happens when this dummy closure is invoked without having to change references to the dummy closure.</p><p></p><fieldset><legend>ICHAIN-BEFORE</legend><pre class="lol_code">(defmacro! ichain-before (&amp;rest body)
  `(let ((,g!indir-env this))
     (setq this
       (lambda (&amp;rest ,g!temp-args)
         ,@body
         (apply ,g!indir-env
                ,g!temp-args)))))</pre></fieldset><p></p><p><b>Ichain-before</b> is intended to be expanded in an <b>alet</b> form. It adds a new body of code to be executed before invoking the main closure. Going back to our counter example, <b>ichain-before</b> lets us add a new closure that prints out the previous value of the closed-over <b>acc</b> variable before it goes ahead and increments it:</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (ichain-before
      (format t "Changing from ~a~%" acc))
    (lambda (n)
      (incf acc n)))

#&lt;Interpreted Function&gt;</pre><p></p><p>Which works as expected:</p><p></p><pre class="lol_pre">* (funcall * 2)
Changing from 0
2
* (funcall ** 2)
Changing from 2
4</pre><p></p><p>There is a reason we put chain in the name of <b>ichain-before</b>, though. We can put as many of these closures on to be executed as we please:</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (ichain-before
      (format t "A~%"))
    (ichain-before
      (format t "B~%"))
    (ichain-before
      (format t "C~%"))
    (lambda (n)
      (incf acc n)))

#&lt;Interpreted Function&gt;</pre><p></p><p>Each addition of a new link in the chain adds the link to the very beginning of the chain, resulting in the links being visited in the reverse order from which they were added:</p><p></p><pre class="lol_pre">* (funcall * 2)
C
B
A
2</pre><p></p><p>Statically adding indirection chains is sometimes useful when changing macros to avoid re-structuring macros by adding new surrounding code. But the most interesting possibilities for indirection chains pop up when we add them dynamically. Because we can create new closures at run-time and because we can access the internals of a closure through an anaphor, we can re-write how functions work at run-time. Here is a simple example in which every invocation of the closure adds another bit of code that prints "Hello world" when run:</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (lambda (n)
      (ichain-before
        (format t "Hello world~%"))
      (incf acc n)))

#&lt;Interpreted Function&gt;</pre><p></p><p>Every invocation adds a new closure to the indirection chain:</p><p></p><pre class="lol_pre">* (loop for i from 1 to 4
    do
      (format t "~:r invocation:~%" i)
      (funcall * i))
first invocation:
second invocation:
Hello world
third invocation:
Hello world
Hello world
fourth invocation:
Hello world
Hello world
Hello world</pre><p></p><p>The <b>ichain-after</b> macro is similar to the <b>ichain-before</b> macro except it adds the closures to the other end of the execution chain: after the main closure has been invoked. <b>Ichain-after</b> uses <b>prog1</b>, which executes its provided forms consecutively and then returns the result of evaluating the first form.</p><p></p><fieldset><legend>ICHAIN-AFTER</legend><pre class="lol_code">(defmacro! ichain-after (&amp;rest body)
  `(let ((,g!indir-env this))
     (setq this
       (lambda (&amp;rest ,g!temp-args)
         (prog1
           (apply ,g!indir-env
                  ,g!temp-args)
           ,@body)))))</pre></fieldset><p></p><p><b>Ichain-before</b> and <b>ichain-after</b> can be combined so that the before forms are executed before the evaluation of the main closure and the after forms after:</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (ichain-before
      (format t "Changing from ~a~%" acc))
    (ichain-after
      (format t "Changed to ~a~%" acc))
    (lambda (n)
      (incf acc n)))

#&lt;Interpreted Function&gt;
* (funcall * 7)
Changing from 0
Changed to 7
7</pre><p></p><p><b>Ichain-before</b> and <b>ichain-after</b> are macros that inject free variables into their expansion. They inject the symbol <b>this</b> which we rely on being captured by the expansion of an <b>alet</b> macro. This sort of injection of symbols might seem to be bad style or error-prone, but it is actually a common macro technique. In fact, almost all macros inject symbols into the expansion. For instance, along with <b>this</b>, the macro <b>ichain-before</b> also injects symbols like <b>let</b>, <b>setq</b>, and <b>lambda</b> to be spliced into wherever the macro is expanded. The difference between symbols like <b>this</b> and pre-defined symbols like <b>setq</b> is that while <b>lambda</b> always refers to a single well-understood ANSI macro, symbols like <b>this</b> can refer to different things depending on the environments in which they are expanded.</p><p><b>Ichain-before</b> and <b>ichain-after</b> are useful for tagging on code for a closure to run before or after the execution of the original closed-over expression but are by no means the only things we can do with the <b>this</b> anaphor. Another common task is checking for the validity of closure data after an invocation of the closure.</p><p></p><fieldset><legend>ICHAIN-INTERCEPT-1</legend><pre class="lol_code">(defmacro! ichain-intercept% (&amp;rest body)
  `(let ((,g!indir-env this))
     (setq this
       (lambda (&amp;rest ,g!temp-args)
         (block intercept
           (prog1
             (apply ,g!indir-env
                    ,g!temp-args)
             ,@body))))))</pre></fieldset><p></p><p><b>Ichain-intercept%</b> is another macro designed to be used inside an <b>alet</b> form. The idea is that we would like to be able to intercept invocations of the closure and verify that the actions they performed didn't cause some sort of inconsistent state in the closure.</p><p>So we can add an intercept to our usual counter closure like so:</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (ichain-intercept%
      (when (&lt; acc 0)
        (format t "Acc went negative~%")
        (setq acc 0)
        (return-from intercept acc)))
    (lambda (n)
      (incf acc n)))

#&lt;Interpreted Function&gt;</pre><p></p><p>When the counter falls below 0, the code installed by <b>ichain-intercept%</b> will warn us:</p><p></p><pre class="lol_pre">* (funcall * -8)
Acc went negative
0</pre><p></p><p>The counter was reset back to 0:</p><p></p><pre class="lol_pre">* (funcall ** 3)

3</pre><p></p><p>The most interesting thing about <b>ichain-intercept%</b> is that it introduces a <i>block anaphor</i> named <b>intercept</b>. To use this anaphor we use <b>return-from</b>. The block will return this value from the closure invocation, intercepting the original value.</p><p></p><fieldset><legend>ICHAIN-INTERCEPT</legend><pre class="lol_code">(defmacro! ichain-intercept (&amp;rest body)
  `(let ((,g!indir-env this))
     (setq this
       (lambda (&amp;rest ,g!temp-args)
         (block ,g!intercept
           (macrolet ((intercept (v)
                       `(return-from
                          ,',g!intercept
                          ,v)))
             (prog1
               (apply ,g!indir-env
                      ,g!temp-args)
               ,@body)))))))</pre></fieldset><p></p><p>Instead of capturing the block anaphor <b>intercept</b>, <b>ichain-intercept</b> creates a local macro that allows the code inside <b>ichain-intercept</b> to use <b>intercept</b> to expand into a <b>return-from</b> where the block is specified by a gensym.</p><p></p><pre class="lol_pre">* (alet ((acc 0))
    (ichain-intercept
      (when (&lt; acc 0)
        (format t "Acc went negative~%")
        (setq acc 0)
        (intercept acc)))
    (lambda (n)
      (incf acc n)))

#&lt;Interpreted Function&gt;</pre><p></p><p>This works the same as with <b>ichain-intercept%</b>:</p><p></p><pre class="lol_pre">* (funcall * -8)
Acc went negative
0
* (funcall ** 3)

3</pre><p></p><p>Of course, introducing all these closures transparently into operations can affect run-time performance. Luckily, modern lisp compilers are very good at optimising closures. If your application can stand a few pointer dereferences—and often it can—indirection chains might just be the best way to structure it. See <a href="https://letoverlambda.com/textmode.cl/guest/chap7.html#sec_4">section 7.4, Pointer Scope</a> for another interesting way to think about indirection chains. Also see CLOS's before, after, and around functionalities.</p><h3 id="sec_5">Hotpatching Closures</h3>
<p>There are three purposes for this important section. First, another interesting use of the <b>this</b> anaphor from <b>alet</b> is described. Second, the pattern <i>alet over dlambda</i> is discussed. Finally, a useful macro technique called <i>anaphor closing</i> is introduced.</p><p></p><fieldset><legend>ALET-HOTPATCH-1</legend><pre class="lol_code">(defmacro alet-hotpatch% (letargs &amp;rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     (lambda (&amp;rest args)
       (if (eq (car args) ':hotpatch)
         (setq this (cadr args))
         (apply this args)))))</pre></fieldset><p></p><p>In order to clearly illustrate anaphor closing, we will not work with the <b>alet</b> macro but instead an inside out expansion. <b>Alet-hotpatch%</b> is an expansion of <b>alet</b> with a special lambda form provided. This lambda form checks the first argument<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(13); return false"><sup>13</sup></a><span id="note_13" style="display:none"> <sup><i>With a pointer comparison.</i></sup> </span> to see if it is the keyword symbol <b>:hotpatch</b> and, if so, replaces the indirected closure with another provided argument.</p><p>Being able to change the closure used in another forwarding closure at run-time is known as <i>hotpatching</i>. For instance, here we create a hotpatchable closure and store it in the symbol-function cell of the symbol <b>hotpatch-test</b> for later use:</p><p></p><pre class="lol_pre">* (setf (symbol-function 'hotpatch-test)
    (alet-hotpatch% ((acc 0))
      (lambda (n)
        (incf acc n))))

#&lt;Interpreted Function&gt;</pre><p></p><p>It can now be used like so:</p><p></p><pre class="lol_pre">* (hotpatch-test 3)

3
* (hotpatch-test 4)

7</pre><p></p><p>We can replace the lambda form—along with its associated environment—by calling this closure with the symbol <b>:hotpatch</b> and a replacement function or closure:</p><p></p><pre class="lol_pre">* (hotpatch-test
    :hotpatch
    (let ((acc 0))
      (lambda (n)
        (incf acc (* 2 n)))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Now the closure will have the new, hotpatched behaviour:</p><p></p><pre class="lol_pre">* (hotpatch-test 2)

4
* (hotpatch-test 5)

14</pre><p></p><p>Notice how the counter value reset to 0 since we also hotpatched the closure's environment with a new value for the counter's accumulator, <b>acc</b>.</p><p></p><fieldset><legend>ALET-HOTPATCH</legend><pre class="lol_code">(defmacro alet-hotpatch (letargs &amp;rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     (dlambda
       (:hotpatch (closure)
         (setq this closure))
       (t (&amp;rest args)
         (apply this args)))))</pre></fieldset><p></p><p>Haven't we seen this sort of <i>run-time destructuring</i> on keyword symbols before? Yes, in fact we wrote a macro for doing exactly this in <a href="https://letoverlambda.com/textmode.cl/guest/chap5.html#sec_7">section 5.7, Dlambda</a>. <b>Alet-hotpatch</b> is a version of <b>alet-hotpatch%</b> that takes advantage of <b>dlambda</b>. Sometimes without even realising it, by using macros we wrote previously in the definition of new macros, we are performing <i>macro combination</i>. With well designed macros the expansion can be fully understood and, although it might violate lexical transparency in many ways, no combination problems emerge because all components fit together meaningfully.</p><p><b>Alet-hotpatch</b> creates a hotpatchable closure but there is one slight conceptual flaw. Because the only real reason for using <b>alet-hotpatch</b> is to create this sort of hotpatchable closure, we might forget that it also introduces the anaphor <b>this</b> into the scope of the forms provided. When we forget about anaphora we've created, we risk unwanted variable capture problems. To avoid these problems, we might choose to employ a technique known as <i>anaphor closing</i>. When we close an anaphor, we don't need to change the way our anaphoric macros function, just restrict them in the ways they can be combined.</p><p>Because we have turned the <b>alet</b> expansion inside out, we can lexically see the creation of the <b>this</b> anaphor in the definition of <b>alet-hotpatch</b>. And because <b>alet-hotpatch</b> also contains the code using the <b>this</b> anaphor to implement hotpatching, we can close the anaphor so that the symbol <b>this</b> is no longer captured by the macro. How do we normally avoid introducing unwanted bindings? We name the bindings using gensyms of course.</p><p></p><fieldset><legend>LET-HOTPATCH</legend><pre class="lol_code">(defmacro! let-hotpatch (letargs &amp;rest body)
  `(let ((,g!this) ,@letargs)
     (setq ,g!this ,@(last body))
     ,@(butlast body)
     (dlambda
       (:hotpatch (closure)
         (setq ,g!this closure))
       (t (&amp;rest args)
         (apply ,g!this args)))))</pre></fieldset><p></p><p><b>Let-hotpatch</b> is an example of closing the <b>this</b> anaphor into a more contained version—a safer version for when hotpatching is all that is required. The leading <b>a</b> was removed from the name to suggest that this new macro no longer introduces an anaphor into the supplied body of code. Of course if we wanted to refer to <b>this</b> for some reason other than hotpatching, we should have left the anaphor open.</p><p>This technique of opening and closing anaphora becomes second nature after you have written enough of such macros. Just like we can write macros that inject free variables into an expansion without thinking about how we will capture them until we write the lexical context in which they will be expanded, we sometimes choose to leave an anaphor open while developing macros to experiment with combinations of anaphoric macros and free variable injection macros. Once the most useful combinations are found, we can merge the macros together and replace all anaphora used during development with with gensyms. Like <b>let-hotpatch</b> does, this technique can use <b>defmacro!</b> to move the anaphor's scope from the macro expansion to the macro definition. Instead of lexically introducing an anaphor, we introduced another type of anaphor—one that doesn't take effect in the full lexical scope of the expansion but only in another, more limited scope. This scope is described further in the following section.</p><h3 id="sec_6">Sub-Lexical Scope</h3>
<p>Our <b>defmacro!</b> macro-defining macros that we defined in <a href="https://letoverlambda.com/textmode.cl/guest/chap3.html#sec_5">section 3.5, Unwanted Capture</a> look for the presence of automatic gensyms in the provided code using Graham's <b>flatten</b> utility. Now is the time to confess a small lie we have been telling through this book. Before now, because we hadn't explained free variable injection and anaphora, we pretended that the G-bang symbol names in <b>defmacro!</b> definitions are applicable in the lexical scope of the macro definition. This is actually not true—<b>defmacro!</b> provides these bindings under a slightly different type of scope called <i>sub-lexical scope</i>.</p><p>Remember that scope means where references to a variable are valid and lexical scope means that the name is applicable to code in the textual body of a binding construct such as <b>let</b>. The important distinction between lexical scope and sub-lexical scope is that for lexical scope this includes all macroexpansions of code in the <b>let</b> body. So describing lexical scope as creating variables only accessible to code in the textual body of a binding construct is actually a lie too—macros can <i>inject</i> variable references. Such variables are injected from outside the textual body of the binding construct.</p><p>Implementing genuine textual scoping by limiting the possible ways to access lexical variables results in sub-lexical scope. References to a sub-lexically scoped variable are only valid if the symbols representing them occur in the raw lists that were passed to lisp before macro-expansion.</p><p>Because <b>defmacro!</b> pre-processes the code it was given and creates the list of all the G-bang symbols before the code gets expanded, the G-bang symbols are sub-lexically bound. We can't write macros that inject G-bang symbols into <b>defmacro!</b> because lexical bindings for the G-bang symbols were never created. Here is a typical use of a sub-lexical G-bang symbol:</p><p></p><pre class="lol_pre">* (defmacro! junk ()
    `(let ((,g!var))
       ,g!var))

JUNK</pre><p></p><p>Both G-bang symbols were found in the sub-lexical scope of <b>defmacro!</b> so expansion is as we would expect:</p><p></p><pre class="lol_pre">* (macroexpand '(junk))

(LET ()
  (LET ((#:VAR1663))
    #:VAR1663))
T</pre><p></p><p>However, in order to explore the concept of sub-lexical scope, we will define a macro that injects a G-bang symbol:</p><p></p><pre class="lol_pre">* (defmacro injector-for-g!var ()
    ''g!var)

INJECTOR-FOR-G!VAR</pre><p></p><p>Now we can write <b>junk2</b>. <b>Junk2</b> is identical to <b>junk</b> except that we have replaced our G-bang symbols with a macro that expands into a G-bang symbol:</p><p></p><pre class="lol_pre">* (defmacro! junk2 ()
    `(let ((,(injector-for-g!var)))
       ,(injector-for-g!var)))

JUNK2</pre><p></p><p>But since the G-bang symbols are sub-lexically bound—and thus don't look into the macro expansions of forms—<b>defmacro!</b> doesn't convert the symbols into automatic gensyms:</p><p></p><pre class="lol_pre">* (macroexpand '(junk2))

(LET ()
  (LET ((G!VAR))
    G!VAR))
T</pre><p></p><p>Although the above code will still function, sub-lexically scoped variable references can break expressions when some references that refer to a variable exist in sub-lexical scope and others don't:</p><p></p><pre class="lol_pre">* (defmacro! junk3 ()
   `(let ((,g!var))
      ,(injector-for-g!var)))

JUNK3
* (macroexpand '(junk3))

(LET ()
  (LET ((#:VAR1672))
    G!VAR))
T</pre><p></p><p>Sub-lexical scoping turns up surprisingly often in complex macros. As well as <b>defmacro!</b>, we've seen it in at least one other example: the <b>with-all-cxrs</b> macro from <a href="https://letoverlambda.com/textmode.cl/guest/chap5.html#sec_6">section 5.6, Recursive Solutions</a> sub-lexically binds list accessor functions. The consequence of sub-lexical binding is that we can't refer to such bindings from macro expansions. Sometimes this access limitation is useful, sometimes not. In <b>with-all-cxrs</b>, sub-lexicality could be considered undesirable. When our accessor is in <b>with-all-cxrs</b>'s sub-lexical scope, there is no problem:</p><p></p><pre class="lol_pre">* (with-all-cxrs
    (cadadadr nil))

NIL</pre><p></p><p>And we can even write macros that expand into these accessors, as long as the macro definitions are in the sub-lexical scope of <b>with-all-cxrs</b>:</p><p></p><pre class="lol_pre">* (with-all-cxrs
    (macrolet ((accessor (l)
                 `(cadadadr ,l)))
      (accessor nil)))

NIL</pre><p></p><p>But notice that <b>with-all-cxrs</b> binds the accessor function sub-lexically so we can't define a macro to inject the accessor:</p><p></p><pre class="lol_pre">* (macrolet ((accessor (l)
               `(cadadadr ,l)))
    (with-all-cxrs
      (accessor nil)))

This function is undefined: CADADADR</pre><p></p><p>Now that we are familiar with <i>anaphora</i> and have seen numerous examples of complex macros—including some that utilise sub-lexical scope—we can discuss an interesting theoretical macro: <b>sublet</b>. This macro is designed to create sub-lexical bindings for code using a syntax similar to the usual let form syntax. The discussion of <b>sublet</b>, as with many lisp macros, begins with a utility.</p><p></p><fieldset><legend>LET-BINDING-TRANSFORM</legend><pre class="lol_code">(defun let-binding-transform (bs)
  (if bs
    (cons
      (cond ((symbolp (car bs))
              (list (car bs)))
            ((consp (car bs))
              (car bs))
            (t
              (error "Bad let bindings")))
      (let-binding-transform (cdr bs)))))</pre></fieldset><p></p><p><b>Let-binding-transform</b> is a simple utility that handles the case of a let form binding being a single symbol. In the following, <b>a</b> is normalised to <b>(a)</b>:</p><p></p><pre class="lol_pre">* (let-binding-transform
    '(a (b) (c nil)))

((A) (B) (C NIL))</pre><p></p><p><b>Sublet</b> also uses the <b>tree-leaves</b> utility we defined in <a href="https://letoverlambda.com/textmode.cl/guest/chap5.html#sec_3">section 5.3, Implicit Contexts</a>. Recall that the <b>tree-leaves</b> macro takes three arguments: an arbitrary list structure, an expression that can make use of an <b>x</b> variable to determine whether a leaf should be changed, and another expression that can make use of a different <b>x</b> to determine what valid leaves should be changed to.</p><p>The choice to implicitise the bindings of <b>x</b> with the same name turns out to be a useful <i>duality of syntax</i>. When we can't factor common code in an expression the usual way, sometimes we can gain this brevity advantage by using syntactic duals in other ways. The definition of <b>sublet</b> uses the self-referential read macros described in <a href="https://letoverlambda.com/textmode.cl/guest/chap4.html#sec_5">section 4.5, Cyclic Expressions</a>. Especially for things like accessors that can change many times throughout the writing of a program, read macros allow us to have one and only one form representing the accessor. Thanks to our use of <i>implicitisation</i> with the <b>tree-leaves</b> macro, it is easy to find and understand the code duplication because the code is close together.</p><p></p><fieldset><legend>SUBLET</legend><pre class="lol_code">(defmacro sublet (bindings% &amp;rest body)
  (let ((bindings (let-binding-transform
                    bindings%)))
    (setq bindings
      (mapcar
        (lambda (x)
          (cons (gensym (symbol-name (car x))) x))
        bindings))
    `(let (,@(mapcar #'list
                     (mapcar #'car bindings)
                     (mapcar #'caddr bindings)))
       ,@(tree-leaves
           body
           #1=(member x bindings :key #'cadr)
           (caar #1#)))))</pre></fieldset><p></p><p><b>Sublet</b> takes the form representing the let bindings and applies our <b>let-binding-transform</b> utility, generating new list structure in the process. It then prepends<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(14); return false"><sup>14</sup></a><span id="note_14" style="display:none"> <sup><i>Prepends instead of appends so we can still support bindings without default values, such as <b>(a)</b>.</i></sup> </span> a gensym to each binding with a print name corresponding to the binding name. <b>Sublet</b> expands into a let form which binds these gensym symbols to the values passed into the binding form, then uses <b>tree-leaves</b> to replace all occurrences of the binding name symbols in the provided code with their corresponding gensyms. <b>Sublet</b> does not expand any macros or parse any special forms in the body to look for occurrences of these binding name symbols because <b>sublet</b> creates sub-lexical bindings. For example, if all references to <b>a</b> are sub-lexical, it will replace them with gensyms:</p><p></p><pre class="lol_pre">* (macroexpand
   '(sublet ((a 0))
      (list a)))

(LET ((#:A1657 0))
  (LIST #:A1657))
T</pre><p></p><p>However, because sub-lexical scope doesn't involve expanding macros, and thus necessarily doesn't involve interpreting special forms like <b>quote</b>, instances of the symbol <b>a</b> that aren't supposed to be variable references are also changed:</p><p></p><pre class="lol_pre">* (macroexpand
   '(sublet ((a 0))
      (list 'a)))

(LET ((#:A1658 0))
  (LIST '#:A1658))
T</pre><p></p><p>Sub-lexical scope takes effect before list structure is interpreted as lisp code by your system's code-walker. That is an important observation—one with ramifications still not completely explored. <b>Sublet</b> interprets your code differently than does the code-walker provided with C<small>OMMON</small> L<small>ISP</small>.</p><p>Here we are standing on one of the many edges of macro understanding. What sort of interesting types of scoping lie between unexpanded sub-lexical scope and fully expanded lexical scope? For lack of a better name, we will call this infinitely large category of scopes <i>super sub-lexical scopes</i><a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(15); return false"><sup>15</sup></a><span id="note_15" style="display:none"> <sup><i>I am giving it this silly name because I expect better names to become obvious when the concept is better understood.</i></sup> </span>.</p><p></p><fieldset><legend>SUBLET*</legend><pre class="lol_code">(defmacro sublet* (bindings &amp;rest body)
  `(sublet ,bindings
     ,@(mapcar #'macroexpand-1 body)))</pre></fieldset><p></p><p>A fairly obvious super sub-lexical scope uses <b>sublet*</b>. This macro uses <b>sublet</b> underneath but changes each form in the body by macro expanding them with the <b>macroexpand-1</b> function. Now, instead of appearing in the raw list structure, references to symbols must occur after the first step of macro expansion. This type of super sub-lexical scope allows a macro in each of the let form's body to inject or remove references from the scope. If the macros don't do either of these things—or if the forms aren't macros at all—this type of super sub-lexical scope acts just like sub-lexical scope:</p><p></p><pre class="lol_pre">* (macroexpand
   '(sublet* ((a 0))
      (list a)))

(LET ((#:A1659 0))
  (LIST #:A1659))
T</pre><p></p><p>But we can define another injector macro to test this super sub-lexical scope:</p><p></p><pre class="lol_pre">* (defmacro injector-for-a ()
    'a)

INJECTOR-FOR-A</pre><p></p><p><b>Sublet*</b> will expand this injector macro:</p><p></p><pre class="lol_pre">* (macroexpand-1
   '(sublet* ((a 0))
      (injector-for-a)))

(SUBLET ((A 0))
  A)
T</pre><p></p><p>Which will then be interpreted sub-lexically by <b>sublet</b>, meaning that the injected variable <b>a</b> exists within the type of super sub-lexical scope provided by <b>sublet*</b>:</p><p></p><pre class="lol_pre">* (macroexpand-1 *)

(LET ((#:A1663 0))
  #:A1663)</pre><p></p><p>But nested macros in the expression are not expanded by <b>macroexpand-1</b> so <b>sublet*</b> doesn't put them into sub-lexical scope for <b>sublet</b> to see:</p><p></p><pre class="lol_pre">* (macroexpand-1
   '(sublet* ((a 0))
      (list (injector-for-a))))

(SUBLET ((A 0))
  (LIST (INJECTOR-FOR-A)))
T</pre><p></p><p>So <b>a</b> is not captured sub-lexically<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(16); return false"><sup>16</sup></a><span id="note_16" style="display:none"> <sup><i><b>Walker:macroexpand-all</b> is a CMUCL component of a complete code-walker.</i></sup> </span>:</p><p></p><pre class="lol_pre">* (walker:macroexpand-all *)

(LET ((#:A1666 0))
  (LIST A))</pre><p></p><p>With <b>sublet</b> and <b>sublet*</b> we can control at what level of macro expansion the <b>a</b> variable is considered valid by using sub-lexical or super sub-lexical scopes. As mentioned above, super sub-lexical scope is actually an infinite class of scopes, one that is almost completely unexplored intellectually. As many ways as there are to walk code (a lot) there are super sub-lexical scopes. This class of scoping leads into another category of mostly unexplored macros: macros that change how lisp macros work, when they are expanded, where references are valid, how special forms are interpreted, etc. Eventually, a macro-programmable macro expander.</p><h3 id="sec_7">Pandoric Macros</h3>
<p><i>Pandora's box</i> is a Greek myth about the world's first woman: Pandora. Pandora, the U-language symbol, translates from Greek into all-gifted. Pandora, the woman, was tempted by curiosity to open a small box which irreparably unleashed all of humanity's evil and sins upon the world. While the macros described in this section are very powerful and might teach you a way of programming you never forget, rest assured that our outcome will be far better than poor Pandora's. Open the box.</p><p>First we take a slight detour through another famous lisp book: <i>Lisp in Small Pieces</i><sup><small>[SMALL-PIECES]</small></sup> by Christian Queinnec. Queinnec is a widely respected lisp expert and has contributed much to our lisp knowledge. Queinnec's book is about implementing compilers and interpreters of varying sophistication in and for the Scheme programming language<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(17); return false"><sup>17</sup></a><span id="note_17" style="display:none"> <sup><i>Though it sometimes describes other lisps and their features.</i></sup> </span>.</p><p>In <i>Lisp in Small Pieces</i> there is a short but interesting discussion on macros. Much of it relates to describing the different macro system variations possible thanks to the ambiguity of the Scheme macro specification<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(18); return false"><sup>18</sup></a><span id="note_18" style="display:none"> <sup><i>Thanks, but no thanks.</i></sup> </span>, but there are also a few interesting notes on why we might want to use macros and how to go about using them. If you have read and understood <a href="https://letoverlambda.com/textmode.cl/guest/chap3.html">chapter 3, Macro Basics</a>, most of the macros presented in the chapter of <i>Lisp in Small Pieces</i> about macros will, to you, belong in the trivial category, save one enticing macro that we will now discuss.</p><p>Like many programming books, <i>Lisp in Small Pieces</i> takes us to and leaves us at an implementation of a system for <i>object-oriented</i> programming. Usually these implementations serve to outline a subset of <i>CLOS</i>, the C<small>OMMON</small> L<small>ISP</small> Object System. Queinnec calls his subset <i>MEROONET</i>. Queinnec remarks that when defining a method for a MEROONET class it would be nice to be able to directly refer to the fields of the object being defined instead of using accessors. In Queinnec's (translated) words<sup><small>[SMALL-PIECES-P340-341]</small></sup>:</p><p><i>Let's take the case, for example, of the macro <b>with-slots</b> from CLOS; we'll adapt it to a MEROONET context. The fields of an object—let's say the fields of an instance of <b>Point</b>—are handled by read and write functions like <b>Point-x</b> or <b>set-Point-y!</b>. It would be simpler to handle them directly by the name of their fields, <b>x</b> or <b>y</b>, for example, in the context of defining a method.</i></p><p>Here is Queinnec's desired interface (which he has called <b>define-handy-method</b>) defining a new method, <b>double</b>:</p><p></p><pre class="lol_pre">(define-handy-method (double (o Point))
  (set! x (* 2 x))
  (set! y (* 2 y))
  o )</pre><p></p><p>Which is more pleasing for programmers than the otherwise necessary MEROONET syntax:</p><p></p><pre class="lol_pre">(define-method (double (o Point))
  (set-Point-x! o (* 2 (Point-x o)))
  (set-Point-y! o (* 2 (Point-y o)))
  o )</pre><p></p><p>In other words, it would be nice if we could use macros to access foreign bindings—in this case object slots—as if they were lexical bindings. Although this is undeniably useful for abbreviation purposes, its most important implication is its ability to give <i>dualities of syntax</i> to our existing and future macros.</p><p>As Queinnec notes, C<small>OMMON</small> L<small>ISP</small> implements this functionality for CLOS with a macro called <b>with-slots</b>. This is an example of C<small>OMMON</small> L<small>ISP</small> doing what it was designed to do: allowing abstractions based on a refined, standardised macro system. While most languages are designed to be easy to implement, C<small>OMMON</small> L<small>ISP</small> is designed to be powerful to program. Queinnec's conclusion was that language limitations make this mostly impossible in Scheme, especially where portability is required:</p><p><i>[L]acking reflective information about the language and its implementations, we cannot write a portable code-walker in Scheme, so we have to give up writing <b>define-handy-method</b>.</i></p><p>Although C<small>OMMON</small> L<small>ISP</small> still allows a large number of legal ways to implement macro systems, it is designed to provide general meta-programming tools that come together in standard and portable ways. The two advanced C<small>OMMON</small> L<small>ISP</small> macro features that allow us to implement things like CLOS's <b>with-slots</b> are <i>generalised variables</i> and <i>symbol macros</i>. This section takes advantage of an opportunity to show off this wonderful confluence of C<small>OMMON</small> L<small>ISP</small> features as well as to bring together everything we have seen so far regarding anaphoric macros, in the process discovering an interesting class of macros called <i>pandoric macros</i>.</p><p></p><fieldset><legend>PANDORICLET</legend><pre class="lol_code">(defmacro pandoriclet (letargs &amp;rest body)
  (let ((letargs (cons
                   '(this)
                   (let-binding-transform
                     letargs))))
    `(let (,@letargs)
       (setq this ,@(last body))
       ,@(butlast body)
       (dlambda
         (:pandoric-get (sym)
           ,(pandoriclet-get letargs))
         (:pandoric-set (sym val)
           ,(pandoriclet-set letargs))
         (t (&amp;rest args)
           (apply this args))))))</pre></fieldset><p></p><p>The idea behind <b>pandoriclet</b> is to <i>open closures</i>, allowing their otherwise closed-over lexical variables to be accessed externally. As with some of our previous macros like <b>alet-hotpatch</b>, <b>pandoriclet</b> compiles an indirection environment that chooses different run-time behaviours depending on the arguments passed.</p><p>We again started with an <i>inside out</i> expansion of <b>alet</b>, keeping in mind the introduction of an anaphor called <b>this</b>. <b>Pandoriclet</b> is similar to other macros we've seen. As with all of our anaphoric <b>let</b> variants, we assume the final form in the <b>pandoriclet</b> body will be a lambda form. Like <b>alet-hotpatch</b>, <b>pandoriclet</b> uses the <b>dlambda</b> macro to dispatch between different possible pieces of code to execute when the closure returned from <b>pandoriclet</b> is invoked. <b>Pandoriclet</b> uses the <b>let-binding-transform</b> utility function introduced in the previous section to deal with null bindings created—like <b>(let (a) ...)</b>. This utility function is necessary to <b>pandoriclet</b> for the same reason that it was necessary for <b>sublet</b>: these macros code-walk the bindings provided to <b>let</b> where our previous macros blindly spliced the bindings into another <b>let</b>.</p><p>We have put in two calls to list-creating utility functions yet to be defined: <b>pandoriclet-get</b> and <b>pandoriclet-set</b>, each of which accept a list of let bindings. Notice we can reference functions that don't yet exist as long as we define them before the macro is expanded which obviously can't occur before we use the macro. Using auxiliary functions to help with defining macros is a good habit to pick up. Not only can it make your definitions more readable, but also can help when testing components of the macro and can prove useful in future macros. The best part about this sort of abstraction is that, as when combining macros, we keep our lexical context available for utilities to make use of.</p><p></p><fieldset><legend>PANDORICLET-ACCESSORS</legend><pre class="lol_code">(defun pandoriclet-get (letargs)
  `(case sym
     ,@(mapcar #`((,(car a1)) ,(car a1))
               letargs)
     (t (error
          "Unknown pandoric get: ~a"
          sym))))

(defun pandoriclet-set (letargs)
  `(case sym
     ,@(mapcar #`((,(car a1))
                   (setq ,(car a1) val))
               letargs)
     (t (error
          "Unknown pandoric set: ~a"
          sym val))))</pre></fieldset><p></p><p>So, remembering the lexical context, we write <b>pandoriclet-get</b> and <b>pandoriclet-set</b>. For <b>pandoriclet-get</b>, we remember that <b>dlambda</b> has bound a variable <b>sym</b> around where our list will be spliced in. We use <b>sym</b> in a <b>case</b> form that compares it to the symbols that were passed to <b>pandoriclet</b><a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(19); return false"><sup>19</sup></a><span id="note_19" style="display:none"> <sup><i>Recall that <b>case</b> with symbols compiles to a single pointer comparison per case.</i></sup> </span>. If we find a symbol, the current value of the binding it refers to is returned. If not, an error is thrown. <b>Pandoriclet-set</b> is nearly identical, except that <b>dlambda</b> bound one extra symbol for it to use: <b>val</b>. <b>Pandoriclet-set</b> uses <b>setq</b> to change the binding referred to by <b>sym</b> to <b>val</b>.</p><p><b>Pandoriclet</b> provides the same interface as all our anaphoric let variants so we can use it to make our usual counter closure:</p><p></p><pre class="lol_pre">* (setf (symbol-function 'pantest)
    (pandoriclet ((acc 0))
      (lambda (n) (incf acc n))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Which works as expected:</p><p></p><pre class="lol_pre">* (pantest 3)

3
* (pantest 5)

8</pre><p></p><p>However, now we have direct access to the binding that was called <b>acc</b> when the closure was created:</p><p></p><pre class="lol_pre">* (pantest :pandoric-get 'acc)

8</pre><p></p><p>And we can similarly change the value of this binding:</p><p></p><pre class="lol_pre">* (pantest :pandoric-set 'acc 100)

100
* (pantest 3)

103</pre><p></p><p>Even the value of our <b>this</b> anaphor is accessible, since we deliberately left the anaphor open and added the symbol <b>this</b> to the <b>letargs</b> binding list when the macro was expanded:</p><p></p><pre class="lol_pre">* (pantest :pandoric-get 'this)

#&lt;Interpreted Function&gt;</pre><p></p><p>So this closure we've created with <b>pandoriclet</b> is actually no longer closed. The environment used by this closure—even when all lexical variable symbols have been removed by the compiler—is still accessible through our anonymous function returned from <b>pandoriclet</b>. How does this work? With pandoric macros, additional code is compiled in to provide a way to access the closure from outside. But the power of pandoric macros can't be seen by looking at this low-level view of what is happening. What we have done is created an <i>inter-closure protocol</i>, or message passing system, for communicating between closures.</p><p>Before we continue with pandoric macros, first we need to point out one of the most important examples of <i>duality of syntax</i> in C<small>OMMON</small> L<small>ISP</small>: <i>generalised variables</i>. The details of this are complicated, and I won't describe all of them here. For that I recommend Graham's <i>On Lisp</i> which has the best treatment I am aware of. The finer points are subtle the idea is simple: accessing a generalised variable is syntactically dual to setting it. You have only one setter form, <b>setf</b>, which is capable of setting all types of variables by using the same syntax you would use to access them.</p><p>For example, with a regular variable you usually access its value through its symbol, say, <b>x</b>. To set it, you can use <b>(setf x 5)</b>. Similarly, to access the car slot of a cons called, say, <b>x</b>, you use <b>(car x)</b>. To set it, you can use the form <b>(setf (car x) 5)</b>. This hides the fact that the actual way to set a cons is to use the function <b>rplaca</b>. By implementing this duality of syntax we cut in half the number of accessors/setters we need to memorise and, most importantly, enable new ways for us to use macros.</p><p></p><fieldset><legend>GET-PANDORIC</legend><pre class="lol_code">(declaim (inline get-pandoric))

(defun get-pandoric (box sym)
  (funcall box :pandoric-get sym))

(defsetf get-pandoric (box sym) (val)
  `(progn
     (funcall ,box :pandoric-set ,sym ,val)
     ,val))</pre></fieldset><p></p><p>The function <b>get-pandoric</b> is a wrapper around the inter-closure protocol getter syntax. It is declaimed inline to eliminate any performance impact caused by this wrapping.</p><p><b>Defsetf</b> is an interesting C<small>OMMON</small> L<small>ISP</small> macro not entirely unlike our <b>defmacro!</b> extension to <b>defmacro</b> in that it implicitly binds gensyms around provided forms. <b>Defsetf</b> works great for defining the setter side of a generalised variable duality as long as the getter can be expressed as a function or macro that evaluates all of its arguments exactly once. Note that while <b>get-pandoric</b> could have been defined as a macro, the only reason to do that would be for inlining purposes. Macros are not for inlining, compilers are for inlining.</p><p>So going back to our pandoric counter stored in the symbol-function of <b>pantest</b>, we can use this new getter function to retrieve the current value of <b>pantest</b>'s <b>acc</b> binding:</p><p></p><pre class="lol_pre">* (get-pandoric #'pantest 'acc)

103</pre><p></p><p>And now, thanks to generalised variables and <b>defsetf</b>, we can use a syntactic dual to set it:</p><p></p><pre class="lol_pre">* (setf (get-pandoric #'pantest 'acc) -10)

-10
* (pantest 3)

-7</pre><p></p><p>The environments that close over functions—what we've been calling the let in <i>let over lambda</i>—are starting to look like regularly accessible generalised variables, just like a cons cell or a hash-table entry. Closures are now even more <i>first-class</i> data structures than they used to be. Bindings that were previously closed to outside code are now wide open for us to tinker with, even if those bindings were compiled to something efficient and have long since had their accessor symbols forgotten.</p><p>But any discussion of generalised variables is incomplete without a mention of its close relative: the <i>symbol macro</i>. <b>Symbol-macrolet</b>, like its name implies, allows us to expand symbols into general lisp forms. Since it is intuitive and more flexible to use forms that look like function calls to represent macro transformations<a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#" onclick="toggle_note(20); return false"><sup>20</sup></a><span id="note_20" style="display:none"> <sup><i>Symbol macros take no arguments so a symbol macro definition always expands the same.</i></sup> </span>, there isn't much use for <b>symbol-macrolet</b> save one important application for which it is vital: symbol macros let us hide generalised variables such that users of our macro think they are accessing regular lexical variables.</p><p>The introduction of symbol macros has resulted in one of the strangest <i>kludges</i> to the C<small>OMMON</small> L<small>ISP</small> language: normally when setting a variable accessed through a regular symbol, like <b>(setf x t)</b>, <b>setf</b> will expand into a <b>setq</b> form because this is what <b>setq</b> was originally designed to do: set lexical and dynamic variables (which are always referred to by symbols). But the <b>setq</b> special form cannot set generalised variables, so when symbol macros were introduced and it became possible for symbols to represent not just a lexical/dynamic binding but instead any generalised variable, it was necessary to mandate that <b>setq</b> forms setting symbols with symbol macro definitions are to be converted back into <b>setf</b> forms. Strangely, this really is the <i>right</i> thing to do because it allows macros that completely hide the presence of generalised variables from the macro's users, even if they choose to use <b>setq</b>. The <i>really right</i> solution would be to remove the redundant <b>setq</b> from the language in favour of the more general <b>setf</b>, but this will not happen for obvious compatibility reasons and because during macro creation <b>setq</b> can also be a useful safety shortcut—<b>setf</b> plus a check that a symbol has been spliced in instead of a list form. When using <b>setq</b> for this remember that it only helps for its splicing safety property; as we've seen, a symbol can reference any generalised variable thanks to <b>symbol-macrolet</b>.</p><p></p><fieldset><legend>WITH-PANDORIC</legend><pre class="lol_code">(defmacro! with-pandoric (syms o!box &amp;rest body)
  `(symbol-macrolet
     (,@(mapcar #`(,a1 (get-pandoric ,g!box ',a1))
                syms))
     ,@body))</pre></fieldset><p></p><p>The <b>with-pandoric</b> macro expands into a <b>symbol-macrolet</b> which defines a symbol macro for each symbol provided in <b>syms</b>. Each symbol macro will expand references to its symbol in the lexical scope of the <b>symbol-macrolet</b> into generalised variable references using our <b>get-pandoric</b> accessor/setter to access the result of evaluating the second argument to the macro: <b>o!box</b> (stored in <b>g!box</b>).</p><p>So <b>with-pandoric</b> lets us peek into a closure's closed over variable bindings:</p><p></p><pre class="lol_pre">* (with-pandoric (acc) #'pantest
    (format t "Value of acc: ~a~%" acc))
Value of acc: -7
NIL</pre><p></p><p>As per our design of using generalised variables to form a syntactic dual for the setting and getting of this variable, we can even pretend it is a regular lexical variable and set it with <b>setq</b>:</p><p></p><pre class="lol_pre">* (with-pandoric (acc) #'pantest
    (setq acc 5))

5
* (pantest 1)

6</pre><p></p><p>We have now looked at most of the pieces that make up pandoric macros. First, a macro for creating closures: <b>pandoriclet</b>, which captures an anaphor, <b>this</b>, referring to the actual function used when invoking the closure. This macro also compiles in some special code that intercepts certain invocations of this closure and instead accesses or modifies its closed-over lexical variables. Second, a single syntax for both accessing and setting an accessor is is implemented with <b>get-pandoric</b> and <b>defsetf</b>. Finally, the macro <b>with-pandoric</b> uses <b>symbol-macrolet</b> to install these generalised variables as seemingly new lexical variables with the same names as the closed-over variables. These variables refer to the original environment created with <b>pandoriclet</b>, but from separate lexical contexts.</p><p>As an example, we relate this ability to open up closures by comparing it to the <i>hotpatching</i> macros from <a href="https://letoverlambda.com/textmode.cl/guest/chap6.html#sec_5">section 6.5, Hotpatching Closures</a>. Recall that <b>alet-hotpatch</b> and its closed anaphor cousin, <b>let-hotpatch</b>, create closures with an indirection environment so that the function that is called when the closure is invoked can be changed on the fly. The biggest limitation with these macros is that they force you to throw out all the lexical bindings that closed over the previous anonymous function when you hotpatched it. This was unavoidable because when we wrote those macros, closures were closed to us.</p><p>With <b>alet-hotpatch</b> and <b>let-hotpatch</b>, we had to compile special purpose code into each closure that was capable of setting the <b>this</b> anaphoric lexical binding to its new value. But since we can now open up a closure defined with <b>pandoriclet</b> and run this setter code externally, we can define a hotpatching function <b>pandoric-hotpatch</b> that will work with any pandoric closure.</p><p></p><fieldset><legend>PANDORIC-HOTPATCH</legend><pre class="lol_code">(defun pandoric-hotpatch (box new)
  (with-pandoric (this) box
    (setq this new)))</pre></fieldset><p></p><p>Sometimes abstractions just feel right and it is hard to exactly say why. Probably because most programming is the disharmonious combining of disjoint parts, it is surprising and pleasant when you discover abstractions that—seemingly by chance—fit together perfectly. <b>Pandoric-hotpatch</b> just seems to read exactly like how it works: it opens a pandoric interface, takes the variable <b>this</b> from the lexical scope of the closure <b>box</b>, and then uses <b>setq</b> to set <b>this</b> to the closure to be hotpatched in, <b>new</b>.</p><p>We can even use <b>pandoric-hotpatch</b> on a pandoric closure we created before we knew we wanted it to be hotpatchable. Remember the counter closure we have been playing with throughout this section? It should still be bound to the <b>symbol-function</b> of the symbol <b>pantest</b>. We were at 6 and counting up when we left off:</p><p></p><pre class="lol_pre">* (pantest 0)

6</pre><p></p><p>Let's install a new closure—one that has a new binding for <b>acc</b> starting at 100, and is counting down:</p><p></p><pre class="lol_pre">* (pandoric-hotpatch #'pantest
    (let ((acc 100))
      (lambda (n) (decf acc n))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Sure enough, the hotpatch went through:</p><p></p><pre class="lol_pre">* (pantest 3)

97</pre><p></p><p>So now our counter closure has a new value bound to <b>this</b> that it uses to perform the counting. However, did this hotpatch change the pandoric value of <b>acc</b> binding?</p><p></p><pre class="lol_pre">* (with-pandoric (acc) #'pantest
    acc)

6</pre><p></p><p>No. <b>Acc</b> is still the previous value, 6, because the only binding we changed in the pandoric environment was <b>this</b>, and we changed that to a new closure with its own binding for <b>acc</b>.</p><p></p><fieldset><legend>PANDORIC-RECODE</legend><pre class="lol_code">(defmacro pandoric-recode (vars box new)
  `(with-pandoric (this ,@vars) ,box
     (setq this ,new)))</pre></fieldset><p></p><p>The macro <b>pandoric-recode</b> takes a slightly different approach to hotpatching. It conserves the original lexical environment of the code while still managing to change the function to be executed when the closure is invoked to something coded and compiled externally. Sound too good to be true? Remembering that the current value for <b>acc</b> is 6 in the original pandoric environment, we can use <b>pandoric-recode</b> to install a new function that makes use of this original value and, oh, let's say, decrements the counter by half the value of the provided <b>n</b>:</p><p></p><pre class="lol_pre">* (pandoric-recode (acc) #'pantest
    (lambda (n)
      (decf acc (/ n 2))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Sure enough, we have the new behaviour, which decrements <b>acc</b> by <b>(* 1/2 2)</b>, from 6 to 5:</p><p></p><pre class="lol_pre">* (pantest 2)

5</pre><p></p><p>And is it associated with the original pandoric binding?</p><p></p><pre class="lol_pre">* (with-pandoric (acc) #'pantest
    acc)

5</pre><p></p><p>Yes. How does <b>pandoric-recode</b> work? It closes over the provided lambda form with the pandorically opened bindings of the original closure.</p><p></p><fieldset><legend>PLAMBDA</legend><pre class="lol_code">(defmacro plambda (largs pargs &amp;rest body)
  (let ((pargs (mapcar #'list pargs)))
    `(let (this self)
       (setq
         this (lambda ,largs ,@body)
         self (dlambda
                (:pandoric-get (sym)
                  ,(pandoriclet-get pargs))
                (:pandoric-set (sym val)
                  ,(pandoriclet-set pargs))
                (t (&amp;rest args)
                  (apply this args)))))))</pre></fieldset><p></p><p>The macro we have used so far to create pandoric closures is <b>pandoriclet</b>. <b>Plambda</b> is an inside out re-write of <b>pandoriclet</b> that adds a few important features. First and foremost, <b>plambda</b> no longer creates the let environment to be used through our pandoric accessors. Instead, <b>plambda</b> takes a list of symbols that refer to variables that are expected to be in the caller's lexical environment. <b>Plambda</b> can <i>export</i> any variables in your lexical environment, transparently making them available for other lexical scopes to access—even ones written and compiled before or after the <b>plambda</b> form is.</p><p>This is an incremental improvement to our <i>let over lambda</i> closure system designed to maximise dual syntax. Thanks to pandoric macros, the most important of which are <b>plambda</b> and <b>with-pandoric</b>, we can easily and efficiently transcend the boundaries of lexical scope when we need to. Closures are no longer closed; we can open closures as easily as re-writing our lambda forms to be plambda forms. We use <b>plambda</b> to export lexical variables and <b>with-pandoric</b> to import them as completely equivalent lexical variables. In fact these new variables are so equivalent that they aren't even really new variables at all. A better way of thinking about pandoric variables are that they are simply an extension of the original lexical scope. As a simple example use of <b>plambda</b>, here is a pandoric counter that exports variables from two potentially different lexical environments:</p><p></p><pre class="lol_pre">* (setf (symbol-function 'pantest)
    (let ((a 0))
      (let ((b 1))
        (plambda (n) (a b)
          (incf a n)
          (setq b (* b n))))))

#&lt;Interpreted Function&gt;</pre><p></p><p>Notice how easy it was to export these lexical references. Making a closure pandoric is as easy as adding a <b>p</b> character before the <b>lambda</b> and adding a list of variables to export after the lambda arguments. We can the open this closure—and any pandoric closure that exports the symbols <b>a</b> and <b>b</b>—by using <b>with-pandoric</b> like so:</p><p></p><pre class="lol_pre">* (defun pantest-peek ()
    (with-pandoric (a b) #'pantest
      (format t "a=~a, b=~a~%" a b)))

PANTEST-PEEK
* (pantest-peek)

a=0, b=1
NIL</pre><p></p><p><b>Plambda</b> is an example of how factoring out general components of macro expansions can be helpful. Remember when we wrote <b>pandoriclet</b> and decided to move the creation of <b>case</b> statements for the getter code to the function <b>pandoriclet-get</b> and the setter code to <b>pandoriclet-get</b>? <b>Plambda</b> makes use of these same functions. Even though these macros splice the results from these functions into fairly different lexical contexts, since both macros have been written to use the same variable naming convention and inter-closure protocol, the code is re-usable.</p><p>So pandoric macros break down lexical boundaries. They allow you to open up closures whenever needed and represent a beautiful confluence of a variety of C<small>OMMON</small> L<small>ISP</small> language features: anaphoric macros, generalised variables, and symbol macros. But what good are they, really?</p><p></p><fieldset><legend>MAKE-STATS-COUNTER</legend><pre class="lol_code">(defun make-stats-counter
       (&amp;key (count 0)
             (sum 0)
             (sum-of-squares 0))
  (plambda (n) (sum count sum-of-squares)
    (incf sum-of-squares (expt n 2))
    (incf sum n)
    (incf count)))</pre></fieldset><p></p><p>Pandoric macros are important because they give us the main advantages of object systems like CLOS without requiring us to depart from the more natural let-lambda combination programming style. In particular, we can add functionality, or <i>methods</i>, for closures to use without having to re-instantiate instances of already created objects.</p><p><b>Make-stats-counter</b> is a lambda over let over plambda we have created to create counters, except that it maintains three pieces of information. In addition to the sum, the sum of the squares, and the number of items so far processed are also kept. If we had used <b>lambda</b> instead of <b>plambda</b> in the definition of <b>make-stats-counter</b>, most of this information would be inaccessible to us. We would be locked out because these variables would be closed to us.</p><p>How do we write pandoric methods? We can simply access the variables using <b>with-pandoric</b> as we have demonstrated above, or, since this is lisp, design a more specific interface.</p><p></p><fieldset><legend>DEFPAN</legend><pre class="lol_code">(defmacro defpan (name args &amp;rest body)
  `(defun ,name (self)
     ,(if args
        `(with-pandoric ,args self
           ,@body)
        `(progn ,@body))))</pre></fieldset><p></p><p><b>Defpan</b> is a <i>combination</i> of the <b>defun</b> and <b>with-pandoric</b> macros. <b>Defpan</b>'s main purpose is to enable a <i>duality of syntax</i> between function writing using <b>defun</b> and foreign lexical scope access using <b>with-pandoric</b>. Although we provide arguments to <b>defpan</b> using the same syntax as in lambda forms—a list of symbols—the arguments to <b>defpan</b> mean something different. Instead of creating a new lexical environment, these <i>pandoric functions</i> extend the lexical environment of the pandoric closures they are applied to. With <b>defun</b> and regular lambda forms, the name (symbol) you give a variable is unimportant. With pandoric functions, it is everything. Furthermore, with pandoric functions the order of the arguments doesn't matter and you can elect to use as few or as many of the exported lexical variables as you please.</p><p><b>Defpan</b> also provides an anaphor called <b>self</b> that allows us to perform a useful technique called <i>anaphor chaining</i>. By invisibly passing the value of <b>self</b> between pandoric functions, we can maintain the value of this anaphor throughout a chain of function calls. As with all chaining constructs, be sure you don't end up in an infinite loop.</p><p></p><fieldset><legend>STATS-COUNTER-METHODS</legend><pre class="lol_code">(defpan stats-counter-mean (sum count)
  (/ sum count))

(defpan stats-counter-variance
        (sum-of-squares sum count)
  (if (&lt; count 2)
    0
    (/ (- sum-of-squares
          (* sum
             (stats-counter-mean self)))
       (- count 1))))

(defpan stats-counter-stddev ()
  (sqrt (stats-counter-variance self)))</pre></fieldset><p></p><p>Three methods are presented that can be used on our closures created with <b>make-stats-counter</b> or any other pandoric closure that exports the necessary variable names. <b>Stats-counter-mean</b> simply returns the averaged value of all the values that have been passed to the closure. <b>Stats-counter-variance</b> computes the variance of these values by following a link in the chain and <b>stats-counter-stddev</b> follows yet another to compute the standard deviation. Notice that each link in the chain only needs to pass on the anaphor <b>self</b> to refer to the full lexical context of the closure. We see that the individual pandoric functions only need to reference the variables they actually use and that these variables can be referred to in any order we wish.</p><p>So <b>plambda</b> creates another anaphor—<b>self</b>. While the anaphor <b>this</b> refers to the actual closure that is to be invoked, <b>self</b> refers to the indirection environment that calls this closure. Although it sounds a bit peculiar, code inside our <b>plambda</b> can use <b>self</b> to pandorically access its own lexical environment instead of directly accessing it. This so far only seems useful for <b>defpan</b> methods that have been written to work inside our lexical scope.</p><p></p><fieldset><legend>MAKE-NOISY-STATS-COUNTER</legend><pre class="lol_code">(defun make-noisy-stats-counter
       (&amp;key (count 0)
             (sum 0)
             (sum-of-squares 0))
  (plambda (n) (sum count sum-of-squares)
    (incf sum-of-squares (expt n 2))
    (incf sum n)
    (incf count)

    (format t
      "~&amp;MEAN=~a~%VAR=~a~%STDDEV=~a~%"
           (stats-counter-mean self)
           (stats-counter-variance self)
           (stats-counter-stddev self))))</pre></fieldset><p></p><p><b>Make-noisy-stats-counter</b> is identical to <b>make-stats-counter</b> except that it uses the <b>self</b> anaphor to invoke our <b>defpan</b> functions <b>stats-counter-mean</b>, <b>stats-counter-variance</b>, and <b>stats-counter-stddev</b>.</p><p><b>Plambda</b> and <b>with-pandoric</b> can re-write lexical scope in any way we please. We conclude this chapter with such an example. A limitation of lexical scope sometimes lamented upon is the fact that the C<small>OMMON</small> L<small>ISP</small> function <b>eval</b> will throw out your current lexical environment when it evaluates the form passed to it. In other words, <b>eval</b> evaluates the form in a <i>null lexical environment</i>. In C<small>OMMON</small> L<small>ISP</small> it couldn't be any other way: <b>eval</b> is a function. Here is the problem:</p><p></p><pre class="lol_pre">* (let ((x 1))
    (eval
      '(+ x 1)))

Error: The variable X is unbound.</pre><p></p><p>Sometimes it would apparently be desirable to extend your lexical environment to <b>eval</b>. But be careful. Often it is said that if you are using <b>eval</b> you are probably doing something wrong. Misuse of <b>eval</b> can result in slower programs because <b>eval</b> can be a very expensive operation—mostly because it needs to expand macros present in the form passed to it. Should you suddenly find a need for <b>eval</b> when programming, ask yourself why you didn't do whatever it is you want to do a lot earlier. If the answer is that you couldn't have, say because you just read the form in, then congratulations, you have found one of the rare legitimate uses of <b>eval</b>. Any other answers will lead straight back to the way you probably should have done it in the first place: with a macro.</p><p></p><fieldset><legend>PANDORIC-EVAL</legend><pre class="lol_code">(defvar pandoric-eval-tunnel)

(defmacro pandoric-eval (vars expr)
  `(let ((pandoric-eval-tunnel
           (plambda () ,vars t)))
     (eval `(with-pandoric
              ,',vars pandoric-eval-tunnel
              ,,expr))))</pre></fieldset><p></p><p>But let's say that you really do want to <b>eval</b> something, if only you could carry along that pesky lexical context. The <b>pandoric-eval</b> macro is a fun example use <b>plambda</b> and <b>with-pandoric</b>. <b>Pandoric-eval</b> uses a special variable that we have named <b>pandoric-eval-tunnel</b> to make a pandoric closure available to the <b>eval</b> function through the dynamic environment. We choose exactly which lexical variables to <i>tunnel</i> through the dynamic environment by providing a list of all their symbols as the first argument to <b>pandoric-eval</b>. Here it is applied to our earlier example:</p><p></p><pre class="lol_pre">* (let ((x 1))
    (pandoric-eval (x)
      '(+ 1 x)))

2</pre><p></p><p>And the expression evaluated by <b>pandoric-eval</b> can modify the original lexical environment; <b>pandoric-eval</b> is a two way tunnel:</p><p></p><pre class="lol_pre">* (let ((x 1))
    (pandoric-eval (x)
      '(incf x))
    x)

2</pre><p></p><p>This section, although very lengthy, has still only scratched the surface of what is possible with pandoric macros and their many possible variations. I am looking forward to the many interesting future developments that will come out of them.</p><p>Exercise: Can <b>pandoric-eval</b> calls nest? That is, can you use <b>pandoric-eval</b> to evaluate a form that evaluates <b>pandoric-eval</b>? Why or why not?</p><p>Exercise: Although the implementation of pandoric macros here is fairly efficient, it could be improved. Try replacing <b>pandoriclet-get</b> and <b>pandoriclet-set</b> to generate code that uses a hash-table instead of <b>case</b> and benchmark these two implementations for small and large numbers of pandoric variables. Investigate your favourite CLOS implementation, imitate how dispatching is done there, re-benchmark.</p><center><p>All material is (C) Doug Hoyte unless otherwise noted or implied. All rights reserved.</p></center>

</body></html>